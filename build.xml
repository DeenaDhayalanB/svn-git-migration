<!-- Ant script for migrating Talend SVN repositories to Git repostiories for the Studio -->    
<project name="svn2gitMigration" default="migration">
	<property name="svn2gitMigration.file.path" value="${ant.file.svn2gitMigration}"/>
	<dirname property="svn2gitMigration.dir.path" file="${svn2gitMigration.file.path}"/>	
	<property name="repo.root.folder" location="${svn2gitMigration.dir.path}/.."/>
    <property name="svn-migration-scripts.jar.path" value="${svn2gitMigration.dir.path}/svn-migration-scripts.jar"/>
    <property name="bfg.jar.path" value="${svn2gitMigration.dir.path}/bfg-1.11.1.jar"/>
    <property name="not.existing.migration.data.file" value="${svn2gitMigration.dir.path}/not_existing_migration_data.txt"/>
    <property name="talend.git.base.url" value="ssh://git@bitbucket.org/talend"/>
    <property name="commit.prefix" value="[GIT Migration]"/>
	<taskdef resource="net/sf/antcontrib/antlib.xml">
      <classpath>
        <pathelement location="${svn2gitMigration.dir.path}/ant-contrib-1.0b3.jar"/>
      </classpath>
    </taskdef>
	
    <property name="migration.data.branches.folder.path" value="${migration.data.folder.path}/branches"/>
    <property name="refactor.ant.file" value="${migration.data.folder.path}/refactor_ant.xml"/><!--if it does not exist then it will be ignored-->
    <property name="error.log.path" value="${migration.data.folder.path}/error.log"/>
    
    <property name="svn.git.repos.path" value="${repo.root.folder}/svn_git_repos"/>

    <property name="migration.workspace.path" value="${repo.root.folder}/migration_workspace"/>
    <property name="final.repos.path" value="${repo.root.folder}/final_repos"/>
    <path id="svn.git.repo.dirset">
        <dirset dir="${svn.git.repos.path}" >
            <include name="*"/>
        </dirset>
    </path>

    <!-- load specific migration properties-->
    <property file="${migration.data.folder.path}/migration_ant.properties"/>
    <import file="${refactor.ant.file}" optional="true"/>
    
<!-- - - - - - - - - - - - - - - - - - 
          target: check.properties     
          check initial properties that are required for this script.                 
         - - - - - - - - - - - - - - - - - -->
    <target name="check.properties">
        <fail message="You must specify a &quot;repo.root.folder&quot; that contains a folder named [svn_git_repos] ">
            <condition>
               <not>
                <available file="${svn.git.repos.path}"/>
               </not>
             </condition>
        </fail>
        <fail message="You must specify a &quot;remote.git.username&quot; and &quot;remote.git.password&quot; property ">
            <condition>
                <or>
                    <not>
                        <isset property="remote.git.username"/>
                    </not>
                    <not>
                        <isset property="remote.git.password"/>
                    </not>
                </or>
             </condition>
        </fail>
        <fail message="You must specify a &quot;migration.data.folder.path&quot; property (using -D in the commandline)">
            <condition>
                <or>
                    <not>
                        <isset property="migration.data.folder.path"/>
                    </not>
                </or>
             </condition>
        </fail>
    </target>

<!-- - - - - - - - - - - - - - - - - - 
          target: init                      
         - - - - - - - - - - - - - - - - - -->
    <target name="init" depends="check.properties,compute.list.of.git.repos">
        <delete file="${error.log.path}"/>
        <echo message="--------------------- STARTING SVN -> GIT MIGRATION --------------------"/>
        <echo message="root of svn-git, workspace and final folders for git repos is [${repo.root.folder}]"/>
        <echo message="migration data folder is [${migration.data.folder.path}]"/>
        <echo message="final git repos list is [${list.of.final.git.repos}]"/>
        <echo message="error log may be create at [${error.log.path}]"/>
    </target>

    <!-- - - - - - - - - - - - - - - - - - 
          target: compute.list.of.git.repos
          look at the migration data file name and strip what is before the 2 and the .txt to know the name of the remote repos.                      
         - - - - - - - - - - - - - - - - - -->
    <target name="compute.list.of.git.repos">
        <resources id="all.master.migration.files.id">
            <fileset dir="${migration.data.branches.folder.path}/master">
                <include name="*.txt"/>
            </fileset>
       </resources>
        <pathconvert property="all.master.migration.files" refid="all.master.migration.files.id" pathsep=","/>
        <propertyregex property="all.final.git.repos.multiple" input="${all.master.migration.files}," regexp="(.*?)2(.*?).txt," replace="\2,"/>
        <resources id="final.git.repos.res" >
            <union>
                <tokens>
                    <string value="${all.final.git.repos.multiple}"/>
                    <stringtokenizer delims=","/>
                </tokens>
            </union>
        </resources>
        <pathconvert property="list.of.final.git.repos" refid="final.git.repos.res" pathsep=","/>
    </target> 

    
<!-- - - - - - - - - - - - - - - - - - 
          target: clean.final.repos                      
         - - - - - - - - - - - - - - - - - -->
    <target name="clean.final.repos">
        <!-- remove all final repos -->
        <echo message="clean final repo : ${final.repos.path}"/>
        <delete dir="${final.repos.path}" />
        <mkdir dir="${final.repos.path}" />
    </target>

<!-- - - - - - - - - - - - - - - - - - 
          target: clean.workspace                      
         - - - - - - - - - - - - - - - - - -->
    <target name="clean.workspace">
        <echo message="clean temporary workspace : ${migration.workspace.path} "/>
        <delete dir="${migration.workspace.path}" />
        <mkdir dir="${migration.workspace.path}" />
    </target>
	
	
	
	<!-- main target to launche the svn to git migration -->
    <!-- is assumes that all the svn repositories are already cloned in local git prepositories -->
	<target name="migration" depends="init,clean.final.repos" description="main migration script">
	    <trycatch>
	        <try>
	           <runtarget  target="update.all.git.svn.repos"/>
	           <runtarget  target="perform.each.repo.migration"/>
	       </try>
	       <finally>
	           <dump-error-log/>
            </finally>
	    </trycatch>
	    
	</target>

<!-- ================================= 
          target: update.all.git.svn.repos              
         ================================= -->
    <target name="update.all.git.svn.repos" description="this updates all local git repositories with the latest svn commits" unless="skip.svn.upadte">
        <foreach target="update.git.svn.repo" param="svn.git.repo.path">
        	<path refid ="svn.git.repo.dirset"/>
    	</foreach>
    </target>
	
<!-- ================================= 
          target: update.git.svn.repo              
         ================================= -->
    <target name="update.git.svn.repo" description="update the local git repo from remote svn">
        <echo message="updating ${svn.git.repo.path}"/>
        <git argline="svn fetch" dir="${svn.git.repo.path}/" showoutput="true"/>	
        <echo message="fixing branches and tags..."/>
        <exec executable="java" dir="${svn.git.repo.path}/">
           <arg line="-Dfile.encoding=utf-8 -Djava.io.tmpdir=${final.repos.path} -jar ${svn-migration-scripts.jar.path} sync-rebase"/>
        </exec>
        <exec executable="java" dir="${svn.git.repo.path}/">
           <arg line="-Dfile.encoding=utf-8 -Djava.io.tmpdir=${final.repos.path} -jar ${svn-migration-scripts.jar.path} clean-git --force"/>
        </exec>
        <keep-branches list="${list.of.branches}" repoPath="${svn.git.repo.path}" />
        <keep-tags list="${list.of.tags}" repoPath="${svn.git.repo.path}" />
    </target>
	
<!-- ================================= 
          target: perform.each.repo.migration
          1) creates all the git final repos
          2) loop on each target git repo and tries to fill it with content from svn_git source repos
          3) pushes the git repositories.              
         ================================= -->
    <target name="perform.each.repo.migration" description="this will loop to call all the targets">
        <!-- loop on all final repos -->
    	<for list="${list.of.final.git.repos}" param="git.final.repo.name">
    		<sequential>
    		    <antcall target="clean.workspace"/>
  	            <echo message="initialize the final repo : @{git.final.repo.name}"/>
    		    <local name="final.repo.path"/>
    		    <property name="final.repo.path" value="${final.repos.path}/@{git.final.repo.name}"/>
    		    <!-- initialize the final git repo-->
    		    <git-init-final-repo name="@{git.final.repo.name}"/>
                <!-- migrate each source repos into it-->
    		    <for param="svn.git.repo.path">
    		       <path refid ="svn.git.repo.dirset"/>
    	               <sequential>
    	                  <local name="svn.git.name"/>
    	            	  <basename file="@{svn.git.repo.path}" property="svn.git.name"/>
    	            	  <migrate.single.svn.to.git svnrepo="${svn.git.name}" gitrepo="@{git.final.repo.name}"/>
    	               </sequential>
    		    </for>
                <!-- refactor the final repo before pushing it if the refactor ant script exists -->
    		    <if>
    		        <and>
    		            <available file="${refactor.ant.file}" />
    		            <not>
    		                <equals arg1="${@{git.final.repo.name}.skip.refactor}" arg2="true"/>
    		            </not>
    		        </and>
    		        <then>
    		            <!-- refactor the final repo before pushing it -->
    		            <refactor-final-repo path="${final.repo.path}"/>
    		        </then>
    		        <else>
    		            <echo message="skip the refactoring of ${final.repo.path}"/>
    		        </else>
  		        </if>
                <!--removes all empty commits-->
                <git argline="filter-branch -f --commit-filter 'git_commit_non_empty_tree &quot;$@&quot;' --tag-name-filter cat -- --all" dir="@{final.repo.path}"/>
                <!--this should remove object no related to any commit -->
                <git argline="reflog expire --expire=now --all" dir="@{final.repo.path}"/>
                <git argline="gc --prune=now --aggressive" dir="@{final.repo.path}"/>

         	    <!-- check that repo contains what is expected -->
    		    <check-final-repo repo="@{git.final.repo.name}"/>
                <!-- push the final repos-->
                <git-push-repo localrepo="${final.repo.path}" remoteRepo="@{git.final.repo.name}"/>
    		</sequential>
    	</for>
    </target>
	
                    	
<!-- = = = = = = = = = = = = = = = = =
          macrodef: git-mv-set
          1) create subfolder
          2) add it to git 
          3) move a set of files to a folder using git mv command          
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-mv-set">
        <attribute name="dir" description="root folder of the git repo"/>
        <attribute name="dest" description="destination folder relative to 'dir'"/>
    	<element name="resset-elem" description="resource set element that will be used to select the folders or files to be moved"/>
        <sequential>
            <mkdir dir="@{dir}/@{dest}"/>
            <git argline="add @{dest}" dir="@{dir}/"/>  
            <resources id="all.resources.to.move.set">
                <fileset dir="@{dir}">
                    <resset-elem/>
                </fileset>
                <dirset dir="@{dir}">
                    <resset-elem/>
                </dirset>
            </resources>
            <local name="all.resources.to.move"/>
            <pathconvert property="all.resources.to.move" refid="all.resources.to.move.set" pathsep=" "/>            
            <if>
                <not>
                	<length string="${all.resources.to.move}" trim="true" length="0" />                    
                </not>
            	<then>
                    <echo message="move to [@{dir}/@{dest}] the plugins : ${all.resources.to.move}"/>
                    <git dir="@{dir}" argline="mv ${all.resources.to.move} @{dest}"/>
            	</then>
            </if>
        </sequential>
    </macrodef>
	
	
	<!-- = = = = = = = = = = = = = = = = =
          macrodef: check-final-repo          
          this will check that in the final repository for each branches it contains all the desired folders. 
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="check-final-repo">
        <attribute name="repo" default="name of the final repo to check" />
        <sequential>
            <for param="branch" list="${list.of.branches}">
                <sequential>
                    <git argline="checkout @{branch}" dir="${final.repos.path}/@{repo}"/>
                    <!-- create a resource with all files that should be in the final repo from the migration data files-->
                    <fileset dir="${migration.data.branches.folder.path}/@{branch}" id="all.migration.files">
                        <include name="*@{repo}.txt"/>
                    </fileset>
                    <echo message="Checking [@{repo}] files from the migration data files:${toString:all.migration.files}"/>
                    <local name="temp.file"/>
                    <tempfile property="temp.file"/>
                    <trycatch>
                        <try>
                            <local name="all.files.to.check"/>
                            <local name="all.files.to.check.concat"/>
                            <concat destfile="${temp.file}">
                                <fileset refid="all.migration.files"/>
                            </concat>
                            <loadresource property="all.files.to.check.concat" failonerror="false">
                                <file file="${temp.file}"/>
                            </loadresource>
                            <!-- if there is no migration files on this branch then all.files.to.check is unset instead of being empty -->
                            <condition property="all.files.to.check" value="${all.files.to.check.concat}" else="">
                                <isset property="all.files.to.check.concat"/>
                            </condition>
                            <resources id="all.files.to.check.res">
                                <union>
                                    <tokens>
                                        <string value="${all.files.to.check}" />
                                        <stringtokenizer delims="\n"/>
                                    </tokens>
                                </union>                               
                            </resources>            
                            <!-- create a resource with all files that are found in the final repo from the migration data files-->
                            <dirset dir="${final.repos.path}/@{repo}" id="all.existing.dir.set">
                                <include name="*/*/*"/>
                             </dirset>
                            <!-- convert direset to property to remove the full path and only keep the folders name using a regexp-->
                            <local name="all.existing.dir.path"/>
                            <pathconvert property="all.existing.dir.path" refid="all.existing.dir.set" pathsep="#"/>
                            <local name="all.existing.dir"/>
                            <local name="all.existing.dir.replaced"/>
                            <!-- this convert /a/b/ccc#/a/bbb#/eee# into ccc#bbb#eee#-->
                            <propertyregex property="all.existing.dir.replaced" input="${all.existing.dir.path}#" regexp="(.*?)/([^/]*?)#" replace="\2#"/>
                            <!-- all.existing.dir.replaced may not be set if nothing is found in the branch so set it to empty istead of unset -->
                            <condition property="all.existing.dir" value="${all.existing.dir.replaced}" else="">
                                <isset property="all.existing.dir.replaced"/>
                            </condition>
                            <resources id="all.existing.files.res" >
                                <tokens>
                                    <string value="${all.existing.dir}"/>
                                    <stringtokenizer delims="#"/>
                                </tokens>
                            </resources>
                            <!-- compare the expected resources with the existing ones and stores the failure if they don't match-->
                            <difference id="diff.expected.existing.res">
                                <resources refid="all.files.to.check.res"/>
                                <resources refid="all.existing.files.res"/>
                            </difference>
                            <if>
                                <not>
                                    <length length="0">
                                        <resources refid="diff.expected.existing.res"/>
                                    </length>
                                </not>
                                <then>
                                    <echo message="Check of [@{repo}/@{branch}] failed : see error.log." level="error"/>
                                    <echo message="here is the diff : ${toString:diff.expected.existing.res}" />
                                    <echo file="${error.log.path}" append="true" message="${line.separator}Check of repo @{repo} Failed on branch [@{branch}] because ${line.separator}expected files set : ${toString:all.files.to.check.res} ${line.separator}does not match${line.separator}existing files set :${toString:all.existing.files.res}${line.separator}here is the diff:${toString:diff.expected.existing.res}">
                                    </echo>
                                </then>
                            </if>    
                        </try>
                        <finally>
                            <delete file="${temp.file}"/>
                        </finally>
                    </trycatch>
                </sequential>
            </for>
        </sequential>
    </macrodef>

	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: migrate.single.svn.to.git   
              1) check that a migration is required by finding the txt definition file for migration
              2) copies the svnrepo repo into the workspace
              3) removes unwanted branches and tags
              4) removes all non requested folders from the repository
              5) update the git final repository from workspace repo.  
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="migrate.single.svn.to.git">
        <attribute name="svnrepo" description="name of the svn.git repo"/>
        <attribute name="gitrepo" description="name of the git repository"/>
        <sequential>
            <!-- check there is something to migrate -->
            <fileset dir="${migration.data.branches.folder.path}" id="migration.data.files.id">
                <include name="**/@{svnrepo}2@{gitrepo}.txt"/>
            </fileset>
            <if>
                <not>
                  <length length="0">
                      <fileset refid="migration.data.files.id"/>
                  </length>
                </not>
            <then>
                <echo message="migrating svn repo [@{svnrepo}] to git repo [@{gitrepo}]"/>
                <copy-original-to-workspace from="@{svnrepo}"/>
                <prepare.svn.git.repo svnrepo="@{svnrepo}" gitrepo="@{gitRepo}"/>
                <git-merge-repo from="@{svnrepo}" to="@{gitrepo}"/>
            </then><!-- else nothing to migrate -->
            </if>           
        </sequential>
    </macrodef>


    <!-- = = = = = = = = = = = = = = = = =
          macrodef: keep-branches
          this removes all local branches excpet the ones in the list attribute (comma separated list)
          this removes all remote branches           
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="keep-branches">
        <attribute name="list" description="list of branches to keep" />
        <attribute name="repoPath" description="path of the git repository" />
        <sequential>
            <!-- compute local branches to be removed -->
            <resources id="branches.to.keep.res">
                <tokens>
                    <string value="@{list}" />
                    <stringtokenizer delims=","/>
                </tokens>
            </resources>
        	<local name="all.branches"/>
            <exec executable="git" dir="@{repoPath}/" outputproperty="all.branches">
                <arg line="branch -a"/>
            </exec>
            <resources id="all.local.branches.res">
            	<restrict>
                    <tokens>
                        <string value="${all.branches}" />
                        <stringtokenizer delims="\n, *" suppressdelims="true" />
                    </tokens>
            		<not>
            			  <contains text="remotes/" casesensitive="no"/>
            		</not>
            	</restrict>
            </resources>
            <difference id="local.branches.to.remove.res">
                <resources refid="all.local.branches.res"/>
                <intersect id="intersect"><resources refid="branches.to.keep.res"/><resources refid="all.local.branches.res"/></intersect>
            </difference>
            <local name="local.branches.to.remove"/>
            <pathconvert property="local.branches.to.remove" refid="local.branches.to.remove.res" pathsep=" "/>
        	<if>
                <not>
                    <length string="${local.branches.to.remove}" trim="true" length="0" />                    
                </not>        	    
        	<then>
                <!-- remove all calculated local branches -->
                <echo message="remove the following branches : ${local.branches.to.remove}"/>
                <git dir="@{repoPath}" argline="branch -D ${local.branches.to.remove}"/>
        	</then>
        	<else>
                <echo message="no branches to remove."/>
        	</else>
        	</if>
            <!-- compute remote branches to be removed -->
            <resources id="all.remote.branches.res">
            	<mappedresources>
                    <restrict>
                        <tokens>
                            <string value="${all.branches}" />
                            <stringtokenizer delims="\n, *" suppressdelims="true" />
                        </tokens>
                        <contains text="remotes/" casesensitive="no"/>
                    </restrict>
            		<globmapper from="remotes/*" to="*"/>
            	</mappedresources>
            </resources>
            <local name="remote.branches.to.remove"/>
            <pathconvert property="remote.branches.to.remove" refid="all.remote.branches.res" pathsep=" "/>
            
            <!-- remove all calculated local branches -->
            <if>
                <not>
                    <length string="${remote.branches.to.remove}" trim="true" length="0" />                    
                </not>              
            <then>
                <echo message="remove the following remote branches : ${remote.branches.to.remove}"/>
                <git dir="@{repoPath}" argline="branch -rD ${remote.branches.to.remove}"/>
            </then>
            <else>
                <echo message="no remote branches to remove."/>
            </else>
            </if>
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: keep-tags
          this removes all tags excpet the ones in the list attribute (comma separated list)
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="keep-tags">
        <attribute name="list" description="list of tags to keep" />
        <attribute name="repoPath" description="path of the git repository" />
        <sequential>
            <!-- compute local branches to be removed -->
            <resources id="tags.to.keep.res">
                <tokens>
                    <string value="@{list}" />
                    <stringtokenizer delims=","/>
                </tokens>
            </resources>
            <local name="all.tags"/>
            <exec executable="git" dir="@{repoPath}/" outputproperty="all.tags">
                <arg line="tag"/>
            </exec>
            <resources id="all.tags.res">
                <tokens>
                    <string value="${all.tags}" />
                    <stringtokenizer delims="\n" suppressdelims="true" />
                </tokens>
            </resources>
            <difference id="tags.to.remove.res">
                <resources refid="all.tags.res"/>
                <intersect id="intersect"><resources refid="tags.to.keep.res"/><resources refid="all.tags.res"/></intersect>
            </difference>
            <local name="local.branches.to.remove"/>
            <pathconvert property="tags.to.remove" refid="tags.to.remove.res" pathsep=" "/>
            
            <if>
                <not>
                    <length string="${tags.to.remove}" trim="true" length="0" />                    
                </not>              
                <then>
                    <!-- remove all calculated tags -->
                    <echo message="remove the following tags : ${tags.to.remove}"/>
                    <git dir="@{repoPath}" argline="tag -d ${tags.to.remove}"/>
                </then>
                <else>
                    <echo message="no tabs to remove."/>
                </else>
            </if>

        </sequential>
    </macrodef>
	
	
	<!-- = = = = = = = = = = = = = = = = =
          macrodef: copy svn           
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="copy-original-to-workspace">
        <attribute name="from" description="repo name to be found in ${svn.git.repos.path}" />
        <sequential>
            <!-- copy the @{from} repos -->
            <echo message="copy [@{from}] from [${svn.git.repos.path}] to [${migration.workspace.path}]"/>
        	<!-- native cp is much faster than the Ant one but it is not multiplatform and should not work on Windows-->
            <exec executable="cp">
                <arg line="-r ${svn.git.repos.path}/@{from} ${migration.workspace.path}/@{from}"/>
            </exec>
        </sequential>
    </macrodef>


	
	<!-- = = = = = = = = = = = = = = = = =
          macrodef: prepare.svn.git.repo
          1) loop on all branches to remove the unnecessary folders not matching the migration data pattern
          2) removes all unused folders from the whole git history       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="prepare.svn.git.repo">
        <attribute name="svnrepo" description="name of the svn.git repo found in ${svn.git.repos.path}"/>
        <attribute name="gitrepo" description="name of the final git repo found in ${final.repos.path}"/>
        <sequential>
            <var name="all.removed.files" value=""/>
            <local name="destination.dir"/>
            <property name="destination.dir" value="${migration.workspace.path}/@{svnrepo}/"/>
            <for param="branch" list="${list.of.branches}">
                <sequential><!-- remove all root files and folders unecessary for the branch -->
                    <local name="migration.data.file"/>
                    <!-- if not data migration file exists then use the empty one -->
                    <condition property="migration.data.file" value="${migration.data.branches.folder.path}/@{branch}/@{svnrepo}2@{gitrepo}.txt" else="${not.existing.migration.data.file}">
                        <available file="${migration.data.branches.folder.path}/@{branch}/@{svnrepo}2@{gitrepo}.txt"/>
                    </condition>
                    <echo message="using migration data file [${migration.data.file}]"/>
                    <git argline="checkout @{branch}" dir="${destination.dir}"/>
                    <git argline="clean -fd -q" dir="${destination.dir}"/>
                    <compute-root-files-diff folder="${migration.workspace.path}/@{svnrepo}" resultid="files.to.remove.res">
                        <resources-compare>
                            <fileset dir="${destination.dir}" includesfile="${migration.data.file}"/>
                            <dirset dir="${destination.dir}" includesfile="${migration.data.file}"/>
                        </resources-compare>
                    </compute-root-files-diff>
                    <local name="files.to.remove"/>
                    <pathconvert property="files.to.remove" refid="files.to.remove.res" pathsep=" ">
                          <map from="${destination.dir}" to=""/>
                    </pathconvert>
                    <!-- only remove if necessary -->
                    <if>
                        <not>
                            <length string="${files.to.remove}" trim="true" length="0" />                    
                        </not>              
                        <then>
                            <echo message="[@{branch}] remove this : ${files.to.remove}"/>
                            <git argline="rm -q -r ${files.to.remove}" dir="${destination.dir}"/>
                            <!-- remove the remaining folders cause git rm does not remove them -->
                            <exec executable="rm" dir="${destination.dir}" ><arg line="-rf  ${files.to.remove}"/></exec>
                            <git argline="commit -qam &quot;${commit.prefix} Removed unnecessary root files on branch @{branch}&quot;" dir="${destination.dir}"/>
                            <var name="all.removed.files" value="${all.removed.files} ${files.to.remove}"/>
                        </then>
                        <else>
                            <echo message="no folder to remove."/>
                        </else>
                    </if>
                </sequential>
            </for>
            <git-remove-history alreadyremoved="${all.removed.files}" gitrepo="@{gitrepo}" svnrepo="@{svnrepo}"/>
        </sequential>
    </macrodef>


<!-- = = = = = = = = = = = = = = = = =
          macrodef: git-remove-history
          compute the folder that are not at all in all branches and remove them completly from the history          
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-remove-history">
        <attribute name="alreadyremoved" description="list of all files (space separated) that have been removed on each branches" />
        <attribute name="svnrepo"/>
        <attribute name="gitrepo"/>
        <sequential>
            <resources id="all.removed.files.res">
                <union><!-- removes duplicates -->
                    <tokens>
                        <string value="@{alreadyremoved}" />
                        <stringtokenizer delims=" " suppressdelims="true" />
                    </tokens>
                </union>
            </resources>
            <fileset dir="${migration.data.branches.folder.path}" id="all.migration.files">
                <include name="**/@{svnrepo}2@{gitrepo}.txt"/>
            </fileset>
            <tempfile property="temp.file"/>
            <trycatch>
                <try>
                    <concat destfile="${temp.file}">
                        <fileset refid="all.migration.files"/>
                    </concat>
                    <local name="all.files.to.keep"/>
                    <loadresource property="all.files.to.keep">
                        <file file="${temp.file}"/>
                    </loadresource>
                    <resources id="all.files.to.keep.res">
                        <union>
                            <tokens>
                                <string value="${all.files.to.keep}" />
                                <stringtokenizer delims="\n"/>
                            </tokens>
                        </union>
                    </resources>            
                    <!-- compare the expected resources with the existing ones and stores the failure if they don't match-->
                     <difference id="real.files.to.remove.res">
                        <resources refid="all.removed.files.res"/>
                         <intersect id="files.not.to.remove"><resources refid="all.files.to.keep.res"/><resources refid="all.removed.files.res"/></intersect>
                    </difference>
                    <local name="files.to.remove"/>
                    <pathconvert property="files.to.remove" refid="real.files.to.remove.res" pathsep=","/>
                    <echo message="removing [${files.to.remove}] from the history using bfg."/>
                    <java jar="${bfg.jar.path}" dir="${migration.workspace.path}/@{svnrepo}" fork="true">
                        <arg line="--no-blob-protection --delete-folders '{${files.to.remove}}'"/>
                    </java>
                    <!--reset the current master branch to remove files that where removed above in the index-->
                    <git argline="reset --hard" dir="${migration.workspace.path}/@{svnrepo}"/>
                    <git argline="clean -fd" dir="${migration.workspace.path}/@{svnrepo}"/>
                </try>
                <finally>
                    <delete file="${temp.file}"/>
                </finally>
            </trycatch>
        </sequential>
    </macrodef>
    
    
    
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: compute the full path of root folder and files that are in folder dir and not matching "resources-compare"        
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="compute-root-files-diff">
        <attribute name="folder" description="folder to check files against." />
        <attribute name="resultid" description="property to be set with the result." />
        <element name="resources-compare" description="resources to make the diff with." />
        <sequential>
           <resources id="all.root.files.id">
                <fileset dir="@{folder}">
                    <include name="*"/>
                </fileset>
                <dirset dir="@{folder}">
                    <include name="*"/>
                </dirset>
           </resources>
           <resources id="root.files.to.be.kept">
                <resources-compare/>
           </resources>
           <difference id="@{resultid}">
                <resources refid="all.root.files.id"/>
                <resources refid="root.files.to.be.kept"/>
           </difference>
            <echo>
                all.root.files.id=${toString:all.root.files.id}
                root.files.to.be.kept=${toString:root.files.to.be.kept}
                @{resultid}=${toString:@{resultid}}
        </echo>
        </sequential>
    </macrodef>
    
    
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-merge-repo   
          this will merge the workspace from repo into the final_repo to repo 
          1) add the from repo to the remotes of the to final repos
          2) fetch branches and tags from the from repo
          3) then merge each branches from the from into the final repos
          4) removes the remote repo        
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-merge-repo">
        <attribute name="from" description="name of the workspace repo to import"/>
        <attribute name="to" description="name of the remote repo to import to"/>
        <sequential>
        	<local name="final.git.repo.path"/>
        	<property name="final.git.repo.path" value="${final.repos.path}/@{to}"/>
            <echo message="merging the workspace repo [@{from}] into the final repos [/@{to}]"/>
            <git argline="remote add @{from} ${migration.workspace.path}/@{from}" dir="${final.git.repo.path}" />
            <git argline="fetch @{from}" dir="${final.git.repo.path}" />
            <git argline="fetch --tags @{from}" dir="${final.git.repo.path}" />
        	
        	<for list="${list.of.branches}" param="branch.name">
        		<sequential>
                    <git argline="checkout @{branch.name}" dir="${final.git.repo.path}" />
        		    <!-- compute the merge strategy because of an unknow conflict I change strategy when first merging or when already merged something-->
        		    <!-- if the merge is the first (only one commit) the use the recusive default strategy else use the resolve strategy-->
                    <git argline="rev-list HEAD --count" dir="${final.git.repo.path}" output="commit.counts"/>
        		    <if>
        		        <isset property="@{from}2@{to}.merge.strategy"/>
        		        <then>
                            <git argline="merge -s ${@{from}2@{to}.merge.strategy} @{from}/@{branch.name} -m &quot;migration merge @{from}/@{branch.name}&quot;" dir="${final.git.repo.path}" />
        		        </then>
        		        <else>
                            <git argline="merge @{from}/@{branch.name} -m &quot;migration merge @{from}/@{branch.name}&quot;" dir="${final.git.repo.path}" />
        		        </else>
        		    </if>
        		</sequential>
        	</for>
            <git argline="remote rm @{from}" dir="${final.git.repo.path}" />
        </sequential>
    </macrodef>

	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-push-repo   
          this will push all local branches and tags to the remote repo       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-push-repo">
        <attribute name="localrepo" description="path to the local repo to be pushed"/>
        <attribute name="remoteRepo" description="remote repository name"/>
        <sequential>
        	<local name="remote.repo.url"/>
        	<property name="remote.repo.url" value="${talend.git.base.url}/@{remoteRepo}"/> 
            <echo message="push the final repo : @{localrepo} to [@{remoteRepo}]"/>
        	<git-create-remote-repo name="@{remoteRepo}"/>
            <echo message="setting the remote url to repo [@{localrepo}] on
            	[${remote.repo.url}]"/>
            <git argline="remote add origin ${remote.repo.url}" dir="@{localrepo}/" />
            <echo message="pushing all branches to [${remote.repo.url}]"/>
            <git argline="push origin --all" dir="@{localrepo}/" />
            <echo message="pushing all tags to [${remote.repo.url}]"/>
            <git argline="push origin --tags" dir="@{localrepo}/" />
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-create-remote-repo   
          this creates a remote repo on bitBucket right after deleting it, this will fail if creation fails       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-create-remote-repo">
        <attribute name="name" description="name of the repo"/>
        <sequential>
            <echo message="deleting remote [@{name}] "/>
            <exec executable="curl" resultproperty="curl.result">
               <arg line="-f -X DELETE -u ${remote.git.username}:${remote.git.password} https://api.bitbucket.org/2.0/repositories/talend/@{name}"/>
           </exec>
            <echo message="creating remote [@{name}] "/>
            <exec executable="curl" failonerror="true">
               <arg line="-f -X POST -u ${remote.git.username}:${remote.git.password} -H &quot;Content-Type: application/json&quot; https://api.bitbucket.org/2.0/repositories/talend/@{name} -d '{&quot;scm&quot;: &quot;git&quot;, &quot;is_private&quot;: true}'"/>
           </exec>
        </sequential>
    </macrodef>
	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-init-final-repo   
          this initialise the final repo and creates an initial commit to have the master branch and be able to use it.   
          It also creates the branches 
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-init-final-repo">
        <attribute name="name" description="name of the repo"/>
        <sequential>
            <local name="repo.path"/><!-- make the property local-->
        	<property name="repo.path" value="${final.repos.path}/@{name}"/>
            <echo message="initializing  [${repo.path}] "/>
            <git argline="init ${repo.path}/" dir="${svn2gitMigration.dir.path}" />
            <exec executable="touch" dir="${repo.path}" failonerror="true">
                <arg line=".gitignore"/>
           </exec>
            <git argline="add .gitignore" dir="${repo.path}" />
            <git argline="commit -qam &quot;${commit.prefix} Initial commit for migration&quot;" dir="${repo.path}" />
            <for list="${list.of.branches.no.master}" param="branch.name">
                <sequential>
                    <git argline="branch @{branch.name}" dir="${repo.path}" />
                </sequential>     
            </for>
        </sequential>
    </macrodef>

	<!-- = = = = = = = = = = = = = = = = =
          macrodef: git          
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git">
        <attribute name="argline" description="argument line passed to the git command"/>
        <attribute name="dir" description="directory where to run the git command"/>
        <attribute name="failonerror" default="true" description="argument line passed to the git command"/>
        <attribute name="output" default="git.output" description="name of the property to be filled with the git output"/>
        <attribute name="showoutput" default="false" description="display the stdout after the command was executed, default is false"/>
        <sequential>
            <echo message="in folder [@{dir}]"/>
        	<echo message="git @{argline}"/>
            <local name="error.prop"/>
            <var name="@{output}" unset="true"/>
            
            <trycatch reference="exception.to.rethrown">
                <try>
                    <exec executable="git" dir="@{dir}" failonerror="@{failonerror}" errorproperty="error.prop" outputproperty="@{output}">
                          <arg line="@{argline}"/>
                    </exec>
                    <!-- log the stdout if desired  -->
                    <if>
                        <and>
                            <equals arg1="@{showoutput}" arg2="true"/>
                        </and>
                        <then>
                            <echo message="git command stdout : ${line.separator}${@{output}}"/>
                        </then>
                    </if>
                    <!-- log the error that occured if failonerror was false -->
                    <if>
                        <and>
                            <equals arg1="failonerror" arg2="false"/><!-- because some git command with success output text to stderr :(-->
                            <not>
                            	<length string="${error.prop}" trim="true" length="0" />                    
                            </not>
                        </and>
                    	<then>
                            <echo message="previous git command failed (but keep going) : ${error.prop}"/>
                            <!-- also log in the error log  -->
                            <echo file="${error.log.path}" append="true" message="${line.separator}git commande failed [@{argline}] ${line.separator}on repos [@{dir}]${line.separator}with the error :${error.prop}."/>
                    	</then>
                    </if>
                </try>
                <catch><!-- in case of failure output the git command stderr and stdout -->
                    <echo message="git command failed (stderr): --------------------------${line.separator}${error.prop}${line.separator}----------------end of (stderr)"/>
                    <echo message="git command failed (stdout): --------------------------${line.separator}${@{output}}${line.separator}----------------end of (stdout)"/>
                    <throw refid="exception.to.rethrown"/>
                </catch>
            </trycatch>
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: dump-error-log          
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="dump-error-log">
        <sequential>
            <loadfile property="error.log.content" srcFile="${error.log.path}" quiet="true"/>
            <if>
                <isset property="error.log.content"/>
            <then>
                <echo message="Dumping the file error.log : -------------------------------------------${line.separator}${error.log.content}${line.separator}end of error log dump------------------------------------"/>
            </then>
            <else>
                <echo message="no error log found so enjoy :)."/>
            </else>
            </if>
        </sequential>
    </macrodef>

	
    <!-- ================================= 
          target: git-init-final-repo.test              
         ================================= -->
    <target name="test.git-init-final-repo" depends="clean.final.repos" >
        <git-init-final-repo name="testRepo"/>
        <dump-error-log/>
    </target>

	<!-- ================================= 
	      target: test.prepare.svn.git.repo              
	     ================================= -->
    <target name="test.prepare.svn.git.repo" depends="clean.workspace">
          <copy-original-to-workspace from="tis_shared"/>

        <prepare.svn.git.repo svnrepo="tis_shared" gitrepo="tmdm-studio-ee"/>
        <dump-error-log/>
    </target>
	
	<!-- ================================= 
          target: git-merge-repo.test              
         ================================= -->
    <target name="test.git-merge-repo"><!--  depends="clean.workspace, clean.final.repos">-->
<!--     	<copy-original-to-workspace from="tos/"/>
-->
        
        <git-init-final-repo name="tcommon-studio-ee"/>

    	<git-merge-repo to="tcommon-studio-ee" from="tis_private"/> 
        <dump-error-log/>
    </target>

    <!-- ================================= 
          target: test.keep-branches             
         ================================= -->
    <target name="test.keep-branches" > <!-- depends="clean.workspace">-->
<!--     	<copy-original-to-workspace from="tis_private"/>
-->
        <keep-branches list="${list.of.branches}" repopath="${svn.git.repos.path}/tis_private"/>
        <dump-error-log/>
    </target>

    <!-- ================================= 
          target: test.keep-tags              
         ================================= -->
    <target name="test.keep-tags" ><!--depends="clean.workspace">
        <copy-original-to-workspace from="tis_private"/>-->

        <keep-tags list="${list.of.tags}" repopath="${svn.git.repos.path}/tis_private"/>
        <dump-error-log/>
    </target>
	
    <!-- ================================= 
          target: test.reousource-diff              
         ================================= -->
    <target name="test.reousource-diff" depends="">
    	<property name="branches" value="branch1,branch2,branch3"/>

    	<resources id="branches_to_keep">
    		<restrict>
        		<tokens>
        		    <string value="${branches}" />
        		    <stringtokenizer delims=","/>
        		</tokens>
    			<contains text="2" casesensitive="no"/>
    		</restrict>
    	</resources>
    	<echo message="branches_to_keep=${toString:branches_to_keep}"/>
    	<resources id="A">
    	    <string value="a"/>
    	    <string value="b"/>
    	</resources>
    	<resources id="B">
    	      <string value="b"/>
    	      <string value="c"/>
    	</resources>
    	<union id="union"><resources refid="A"/><resources refid="B"/></union>
    	<intersect id="intersect"><resources refid="A"/><resources refid="B"/></intersect>
    	<difference id="difference"><resources refid="A"/><resources refid="B"/></difference>
    	<difference id="no.in.A">
    		<resources refid="B"/>
    		<intersect id="intersect"><resources refid="A"/><resources refid="B"/></intersect>
    	</difference>
    	<echo>
    	      A: ${toString:A}                    = a;b
    	      B: ${toString:B}                    = b;c

    	      union     : ${toString:union}       = a;b;c
    	      intersect : ${toString:intersect}   = b
    	      difference: ${toString:difference}  = a;c
    		  B not in A: ${toString:no.in.A}     = c
    	    </echo>
    </target>
	
<!-- ================================= 
          target: test-file-set              
         ================================= -->
    <target name="test-file-set" >
    	<resources id="all.res.id">
        	<fileset dir="${svn2gitMigration.dir.path}" id="file.set.id">
        		<include name="*"/>
        	</fileset>
            <dirset dir="${svn2gitMigration.dir.path}" id="dir.set.id">
                <include name="*"/>
            </dirset>
    	</resources>
    	<echo >
    		file.set.id=${toString:file.set.id}
            dir.set.id=${toString:dir.set.id}
    		all.res.id=${toString:all.res.id}
    	</echo>
    </target>

	<!-- ================================= 
          target: test.refactor-final-repo              
         ================================= -->
    <target name="test.refactor-final-repo" >
    	<property name="git.repo.dir"  value="${final.repos.path}/tuj"/>
        <git argline="reset --hard" dir="${git.repo.dir}" />
        <git argline="clean -fd" dir="${git.repo.dir}" />

    	<refactor-final-repo path="${git.repo.dir}"/>
    </target>

    

<!-- ================================= 
          target: test.check-final-repo              
         ================================= -->
    <target name="test.check-final-repo">
        <delete file="${error.log.path}"/>
        <check-final-repo repo="tbd-studio-se"/>
        <dump-error-log/>
    </target>

<!-- ================================= 
          target: test-compute-root-files-diff              
         ================================= -->
    <target name="test-compute-root-files-diff" >
        <compute-root-files-diff folder="${svn2gitMigration.dir.path}" resultid="my.id">
            <resources-compare>
                <fileset dir="${svn2gitMigration.dir.path}" includes="build.xml"/>
                <dirset dir="${svn2gitMigration.dir.path}" includes="build.xml"/>                
            </resources-compare>
        </compute-root-files-diff>
        <echo>res.id=${toString:my.id}</echo>

    </target>

<!-- ================================= 
          target: test-git-remove-history              
         ================================= -->
    <target name="test-git-remove-history" depends="clean.workspace">
        <copy-original-to-workspace from="tis_private"/>

        <property name="all.file.removed" value="pom.xml drools-guvnor-custom org.talend.administrator org.talend.ant.build org.talend.commanline.test org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.oryx org.talend.remote.jobserver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance pom.xml drools-guvnor-custom org.talend.administrator org.talend.ant.build org.talend.commanline.test org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.oryx org.talend.remote.jobserver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance pom.xml drools-guvnor-custom org.talend.administrator org.talend.ant.build org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.mavenUrlHandler org.talend.oryx org.talend.remote.jobserver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance pom.xml drools-guvnor-custom org.talend.administrator org.talend.ant.build org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.mavenUrlHandler org.talend.oryx org.talend.remote.jobserver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance pom.xml drools-guvnor-custom org.talend.administrator org.talend.ant.build org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.mavenUrlHandler org.talend.oryx org.talend.remote.jobserver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance pom.xml drools-guvnor-custom org.talend.administrator org.talend.administrator-feature org.talend.administrator.quartz org.talend.ant.build org.talend.gadget.admindashboard org.talend.jobserver.karaf.feature org.talend.mavenUrlHandler org.talend.oryx org.talend.remote.jobser ver.sigar org.talend.remote.server org.talend.soamanager org.talend.soamanager.commons org.talend.test.build org.talend.test.performance"/>
        <git-remove-history alreadyremoved="${all.file.removed}" svnrepo="tis_private" gitrepo="tcommon-studio-ee"/>
        
    </target>
    
 <!-- ================================= 
          target: test              
         ================================= -->
    <target name="test" >
        <resources id="all.resources.to.move.set">
            <fileset dir="/Applications/java/talend/git/final_repos/tcommon-studio-ee" id="all.files.to.move.set">
                <include name="pom.xml"/>
            </fileset>
            <dirset dir="/Applications/java/talend/git/final_repos/tcommon-studio-ee" id="all.folders.to.move.set">
                <include name="*.test"/>
            </dirset>
        </resources>
        <local name="all.resources.to.move"/>
        <pathconvert property="all.resources.to.move" refid="all.resources.to.move.set" pathsep=" "/>
        <echo>all.resources.to.move=${all.resources.to.move}</echo>
        
        
        <echo message="list.of.branches=${list.of.branches}"/>

        <return-property return.property="tempfile"/>
        <echo message="tempfile=${tempfile}"/>
        <var name="tempfile" unset="true"/>
        <return-property return.property="tempfile"/>
        <echo message="tempfile=${tempfile}"/>
        <return-resources return.resources.id="res.id"/>
        <echo>res.id=${toString:res.id}</echo>
        <return-resources return.resources.id="res.id"/>
        <echo>res.id=${toString:res.id}</echo>
        <!-- check the git requires a commit -->
        <git argline="status -s" dir="/Applications/java/talend/git/talend-svn-git-migration/studio/migration_data" output="foo"/>
        <echo message="git command output=${foo}"/>
        <git argline="status -s" dir="/Applications/java/talend/git/example" output="foo"/>
        <echo message="git command output=${foo}"/>

    </target>
   
    

<!-- = = = = = = = = = = = = = = = = =
          macrodef: return-property          
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="return-property">
        <attribute name="return.property" />
        <sequential>
            <tempfile property="@{return.property}"/>
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
              macrodef: return-resources          
             = = = = = = = = = = = = = = = = = -->
        <macrodef name="return-resources">
            <attribute name="return.resources.id" />
            <attribute name="the.att" default="foo" />
            <sequential>
                <tstamp>
                    <format property="@{the.att}" pattern="MM/dd/yyyy hh:mm aa"/>
                </tstamp>                <local name="temfile"/>
                <tempfile property="temfile"/>
                <resources id="@{return.resources.id}">
                    <string value="${temfile}"/>
                </resources>
                <echo>test { @ {   = '{@{return.resources.id}}'</echo>
                <echo>foo=${foo}</echo>
                <echo>@the.att=${@{the.att}}</echo>
            </sequential>
        </macrodef>
 
</project>
