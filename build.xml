<!-- Ant script for migrating Talend SVN repositories to Git repostiories for the Studio -->    
<project name="svn2gitMigration" default="migration">
	<property name="svn2gitMigration.file.path" value="${ant.file.svn2gitMigration}"/>
	<dirname property="svn2gitMigration.dir.path" file="${svn2gitMigration.file.path}"/>	
	<property name="repo.root.folder" location="${svn2gitMigration.dir.path}/.."/>
    <property name="svn-migration-scripts.jar.path" value="${svn2gitMigration.dir.path}/svn-migration-scripts.jar"/>
    <property name="talend.git.base.url" value="ssh://git@bitbucket.org/talend"/>
	<taskdef resource="net/sf/antcontrib/antlib.xml">
      <classpath>
        <pathelement location="${svn2gitMigration.dir.path}/ant-contrib-1.0b3.jar"/>
      </classpath>
    </taskdef>
	
    <property name="migration.data.folder.path" value="${svn2gitMigration.dir.path}/migration_data"/>
    <property name="svn.git.repos.path" value="${repo.root.folder}/svn_git_repos"/>
	<property name="list.of.git.repos" value="tcommon-studio-se,tcommon-studio-ee,tdi-studio-se,tdi-studio-ee"/>
    <property name="list.of.branches" value="branch-5_4,branch-5_3,branch-5_2,branch-5_1,branch-5_0,branch-4_2,master"/>
	<property name="list.of.tags" value="release-4_2_0,release-4_2_1,release-4_2_2,release-4_2_3,release-4_2_4,release-5_0_0,release-5_0_1,release-5_0_2,release-5_0_3,release-5_1_0,release-5_1_1,release-5_1_2,release-5_1_3,release-5_2_0,release-5_2_1,release-5_2_2,release-5_2_3,release-5_3_0,release-5_3_1,release-5_4_0,release-5_4_1"/>
	<!-- 	    <property name="svn.git.tos" value="tos"/>
        <property name="svn.git.top" value="top"/>
        <property name="svn.git.tis_shared" value="tis_shared"/>
-->

	<property name="migration.workspace.path" value="${repo.root.folder}/migration_workspace"/>
	<property name="final.repos.path" value="${repo.root.folder}/final_repos"/>
	<path id="svn.git.repo.dirset">
    	<dirset dir="${svn.git.repos.path}" >
    	    <include name="*"/>
    	</dirset>
    </path>

	

<!-- - - - - - - - - - - - - - - - - - 
          target: init                      
         - - - - - - - - - - - - - - - - - -->
    <target name="init">
        <echo message="repo.root.folder is [${repo.root.folder}]"/>
        <fail message="You must specify a &quot;repo.root.folder&quot; that contains a folder named [svn_git_repos] ">
            <condition>
               <not>
                <available file="${svn.git.repos.path}"/>
               </not>
             </condition>
        </fail>
        <fail message="You must specify a &quot;remote.git.username&quot; and &quot;remote.git.password&quot; property ">
            <condition>
            	<or>
            	    <not>
            	        <isset property="remote.git.username"/>
            	    </not>
                    <not>
                        <isset property="remote.git.password"/>
                    </not>
            	</or>
             </condition>
        </fail>
    </target>
	
<!-- - - - - - - - - - - - - - - - - - 
          target: clean.final.repos                      
         - - - - - - - - - - - - - - - - - -->
    <target name="clean.final.repos">
        <!-- remove all final repos -->
        <echo message="clean final repo : ${final.repos.path}"/>
        <delete dir="${final.repos.path}" />
        <mkdir dir="${final.repos.path}" />
    </target>

<!-- - - - - - - - - - - - - - - - - - 
          target: clean.workspace                      
         - - - - - - - - - - - - - - - - - -->
    <target name="clean.workspace">
        <echo message="clean temporary workspace : ${migration.workspace.path} "/>
        <delete dir="${migration.workspace.path}" />
        <mkdir dir="${migration.workspace.path}" />
    </target>
	
	
	
	<!-- main target to launche the svn to git migration -->
    <!-- is assumes that all the svn repositories are already cloned in local git prepositories -->
	<target name="migration" depends="init,clean.final.repos" description="main migration script">
		<runtarget  target="update.all.git.svn.repos"/>
        <runtarget  target="perform.each.repo.migration"/>
	</target>

<!-- ================================= 
          target: update.all.git.svn.repos              
         ================================= -->
    <target name="update.all.git.svn.repos" description="this updates all local git repositories with the latest svn commits">
        <foreach target="update.git.svn.repo" param="svn.git.repo.path">
        	<path refid ="svn.git.repo.dirset"/>
    	</foreach>
    </target>
	
<!-- ================================= 
          target: update.git.svn.repo              
         ================================= -->
    <target name="update.git.svn.repo" description="update the local git repo from remote svn">
        <echo message="updating ${svn.git.repo.path}"/>
        <exec executable="git" dir="${svn.git.repo.path}/">
           <arg line="svn fetch"/>
       </exec>
       <echo message="fixing branches and tags..."/>
        <exec executable="java" dir="${svn.git.repo.path}/">
           <arg line="-Dfile.encoding=utf-8 -Djava.io.tmpdir=${final.repos.path} -jar ${svn-migration-scripts.jar.path} clean-git --force"/>
       </exec>
    </target>
	
<!-- ================================= 
          target: perform.each.repo.migration
          1) creates all the git final repos
          2) loop on each target git repo and tries to fill it with content from svn_git source repos
          3) pushes the git repositories.              
         ================================= -->
    <target name="perform.each.repo.migration" description="this will loop to call all the targets">
        <!-- loop on all final repos -->
    	<for list="${list.of.git.repos}" param="git.repo.name">
    		<sequential>
    			<antcall target="clean.workspace"/>
    	        <echo message="initialize the final repo : @{git.repo.name}"/>
    			<!-- initialize the final git repo-->
    			<git-init-final-repo name="@{git.repo.name}"/>
                <!-- migrate each source repos into it-->
    			<for param="svn.git.repo.path">
    			    <path refid ="svn.git.repo.dirset"/>
    	            <sequential>
    	            	<local name="svn.git.name"/><!-- make the property local-->
    	            	<basename file="@{svn.git.repo.path}" property="svn.git.name"/>
    	            	<migrate.single.svn.to.git svnrepo="${svn.git.name}" gitrepo="@{git.repo.name}"/>
    	            </sequential>
    			</for>
                <!-- push the final repos-->
                <git-push-repo localrepo="${final.repos.path}/@{git.repo.name}" remoteRepo="@{git.repo.name}"/>
    		</sequential>
    	</for>
    </target>
	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: migrate.single.svn.to.git   
              1) check that a migration is required by finding the txt definition file for migration
              2) copies the svnrepo repo into the workspace
              3) removes unwanted branches and tags
              4) removes all non requested folders from the repository
              5) update the git final repository from workspace repo.  
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="migrate.single.svn.to.git">
        <attribute name="svnrepo" description="name of the svn.git repo"/>
        <attribute name="gitRepo" description="name of the git repository"/>
        <sequential>
        	<if>
        		   <available file="${migration.data.folder.path}/@{svnrepo}2@{gitrepo}.txt"/>
            <then>
            	<copy-original-to-workspace from="@{svnrepo}"/>
            	<echo>data file used : @{svnrepo}2@{gitrepo}.txt</echo>
            	<keep-branches list="${list.of.branches}" repoPath="${migration.workspace.path}/@{gitrepo}" />
            	<keep-tags list="${list.of.tags}" repoPath="${migration.workspace.path}/@{gitrepo}" />
            	<git-keep-folders from="@{svnrepo}" includesfile="${migration.data.folder.path}/@{svnrepo}2@{gitrepo}.txt"/>
            	<git-merge-repo from="@{svnrepo}" to="@{gitrepo}"/>
        	</then> <!-- else nothing to migrate -->
        	</if>            
        </sequential>
    </macrodef>


    <!-- = = = = = = = = = = = = = = = = =
          macrodef: keep-branches
          this removes all local branches excpet the ones in the list attribute (comma separated list)
          this removes all remote branches           
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="keep-branches">
        <attribute name="list" description="list of branches to keep" />
        <attribute name="repoPath" description="path of the git repository" />
        <sequential>
            <!-- compute local branches to be removed -->
            <resources id="branches.to.keep.res">
                <tokens>
                    <string value="@{list}" />
                    <stringtokenizer delims=","/>
                </tokens>
            </resources>
        	<local name="all.branches"/>
            <exec executable="git" dir="@{repoPath}/" outputproperty="all.branches">
                <arg line="branch -a"/>
            </exec>
            <resources id="all.local.branches.res">
            	<restrict>
                    <tokens>
                        <string value="${all.branches}" />
                        <stringtokenizer delims="\n, *" suppressdelims="true" />
                    </tokens>
            		<not>
            			  <contains text="remotes/" casesensitive="no"/>
            		</not>
            	</restrict>
            </resources>
            <difference id="local.branches.to.remove.res">
                <resources refid="branches.to.keep.res"/>
                <resources refid="all.local.branches.res"/>
            </difference>
        	<local name="local.branches.to.remove"/>
            <pathconvert property="local.branches.to.remove" refid="local.branches.to.remove.res" pathsep=" "/>
        	
            <!-- remove all calculated local branches -->
            <echo message="remove the following branches : ${local.branches.to.remove}"/>
            <exec executable="git" dir="@{repoPath}/">
                <arg line="branch -D ${local.branches.to.remove}"/>
            </exec>
        	
            <!-- compute remote branches to be removed -->
            <resources id="all.remote.branches.res">
            	<mappedresources>
                    <restrict>
                        <tokens>
                            <string value="${all.branches}" />
                            <stringtokenizer delims="\n, *" suppressdelims="true" />
                        </tokens>
                        <contains text="remotes/" casesensitive="no"/>
                    </restrict>
            		<globmapper from="remotes/*" to="*"/>
            	</mappedresources>
            </resources>
            <local name="remote.branches.to.remove"/>
            <pathconvert property="remote.branches.to.remove" refid="all.remote.branches.res" pathsep=" "/>
            
            <!-- remove all calculated local branches -->
            <echo message="remove the following remote branches : ${remote.branches.to.remove}"/>
            <exec executable="git" dir="@{repoPath}/">
                <arg line="branch -rD ${remote.branches.to.remove}"/>
            </exec>
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: keep-tags
          this removes all tags excpet the ones in the list attribute (comma separated list)
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="keep-tags">
        <attribute name="list" description="list of tags to keep" />
        <attribute name="repoPath" description="path of the git repository" />
        <sequential>
            <!-- compute local branches to be removed -->
            <resources id="tags.to.keep.res">
                <tokens>
                    <string value="@{list}" />
                    <stringtokenizer delims=","/>
                </tokens>
            </resources>
            <local name="all.tags"/>
            <exec executable="git" dir="@{repoPath}/" outputproperty="all.tags">
                <arg line="tag"/>
            </exec>
            <resources id="all.tags.res">
                <tokens>
                    <string value="${all.tags}" />
                    <stringtokenizer delims="\n" suppressdelims="true" />
                </tokens>
            </resources>
            <difference id="tags.to.remove.res">
                <resources refid="all.tags.res"/>
                <intersect id="intersect"><resources refid="tags.to.keep.res"/><resources refid="all.tags.res"/></intersect>
            </difference>
            <local name="local.branches.to.remove"/>
            <pathconvert property="tags.to.remove" refid="tags.to.remove.res" pathsep=" "/>
            
            <!-- remove all calculated local branches -->
            <echo message="remove the following tags : ${tags.to.remove}"/>
             <exec executable="git" dir="@{repoPath}/">
                <arg line="tag -d ${tags.to.remove}"/>
            </exec>

        </sequential>
    </macrodef>
	
	
	<!-- = = = = = = = = = = = = = = = = =
          macrodef: copy svn           
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="copy-original-to-workspace">
        <attribute name="from" description="repo name to be found in ${svn.git.repos.path}" />
        <sequential>
            <!-- copy the @{from} repos -->
            <echo message="copy [@{from}] from [${svn.git.repos.path}] to [${migration.workspace.path}]"/>
        	<!-- native cp is much faster than the Ant one but it is not multiplatform and should not work on Windows-->
            <exec executable="cp">
                <arg line="-r ${svn.git.repos.path}/@{from} ${migration.workspace.path}/@{from}"/>
            </exec>
        </sequential>
    </macrodef>


	
	<!-- = = = = = = = = = = = = = = = = =
          macrodef: git-keep-folders   
          this will duplicate the "from" folder into the workspace and remote the other folders than the one to be kept in the git history       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-keep-folders">
        <attribute name="from" description="name of the svn.git repo found in ${svn.git.repos.path}"/>
        <attribute name="includesfile" description="file path to the list of pattern to include in the git repo"/>
        <sequential>
        	<!-- compute folders to remove from folders to be keeps -->
        	<local name="destination.dir"/>
        	<property name="destination.dir" value="${migration.workspace.path}/@{from}/"/>

            <dirset dir="${destination.dir}" id="all.folders.id"><!-- id do not need to be local it works -->
                <include name="*"/>
            </dirset>
        	<difference id="folders.to.remove.res">
        		<dirset refid="all.folders.id"/>
                <dirset dir="${destination.dir}" includesfile="@{includesfile}">
                </dirset>
            </difference>
        	<local name="folders.to.remove"/>
        	<pathconvert property="folders.to.remove" refid="folders.to.remove.res" pathsep=" ">
        	      <map from="${destination.dir}" to=""/>
       	    </pathconvert>
            <!-- remove all unncessary folders from the local repos -->
        	<echo message="remove the following folders : ${folders.to.remove}"/>
            <exec executable="git" dir="${destination.dir}/">
                <arg line="filter-branch --tag-name-filter cat --index-filter 'git rm -q --cached --ignore-unmatch -r ${folders.to.remove}' -- --all --tags"/>
            </exec>
        	
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-merge-repo   
          this will merge the workspace from repo into the final_repo to repo 
          1) add the from repo to the remotes of the to final repos
          2) fetch branches and tags from the from repo
          3) then merge each branches from the from into the final repos
          4) removes the remote repo        
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-merge-repo">
        <attribute name="from" description="name of the workspace repo to import"/>
        <attribute name="to" description="name of the remote repo to import to"/>
        <sequential>
        	<local name="repo.path"/>
        	<property name="final.repo.path" value="${final.repos.path}/@{to}"/>
            <echo message="merging the workspace repo [@{from}] into the final repos [/@{to}]"/>
            <exec executable="git" dir="${final.repo.path}" failonerror="true">
                 <arg line="remote add @{from} ${migration.workspace.path}/@{from}"/>
            </exec>
            <exec executable="git" dir="${final.repo.path}" failonerror="true">
                 <arg line="fetch @{from}"/>
            </exec>
            <exec executable="git" dir="${final.repo.path}" failonerror="true">
                 <arg line="fetch --tags @{from}"/>
            </exec>
        	
        	<for list="${list.of.branches}" param="branch.name">
        		<sequential>
                    <exec executable="git" dir="${final.repo.path}" failonerror="true">
                         <arg line="checkout @{branch.name}"/>
                    </exec>
                    <exec executable="git" dir="${final.repo.path}">
                         <arg line="merge @{from}/@{branch.name} -m &quot;migration merge @{from}/@{branch.name}&quot;"/>
                    </exec>
        		</sequential>
        	</for>
            <exec executable="git" dir="${final.repo.path}" failonerror="true">
                 <arg line="remote rm @{from}"/>
            </exec>
        </sequential>
    </macrodef>

	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-push-repo   
          this will push all local branches and tags to the remote repo       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-push-repo">
        <attribute name="localrepo" description="path to the local repo to be pushed"/>
        <attribute name="remoteRepo" description="remote repository name"/>
        <sequential>
        	<local name="remote.repo.url"/>
        	<property name="remote.repo.url" value="${talend.git.base.url}/@{remoteRepo}"/> 
            <echo message="push the final repo : @{localrepo} to [@{remoteRepo}]"/>
        	<git-create-remote-repo name="@{remoteRepo}"/>
            <echo message="setting the remote url to repo [@{localrepo}] on
            	[${remote.repo.url}]"/>
             <exec executable="git" dir="@{localrepo}/">
                <arg line="remote add origin ${remote.repo.url}"/>
            </exec>
            <echo message="pushing all branches to [${remote.repo.url}]"/>
            <exec executable="git" dir="@{localrepo}/">
               <arg line="push origin --all"/>
           </exec>
            <echo message="pushing all tags to [${remote.repo.url}]"/>
            <exec executable="git" dir="@{localrepo}/">
               <arg line="push origin --tags"/>
           </exec>
        </sequential>
    </macrodef>

    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-create-remote-repo   
          this creates a remote repo on bitBucket right after deleting it, this will fail if creation fails       
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-create-remote-repo">
        <attribute name="name" description="name of the repo"/>
        <sequential>
            <echo message="deleting remote [@{name}] "/>
            <exec executable="curl" resultproperty="curl.result">
               <arg line="-f -X DELETE -u ${remote.git.username}:${remote.git.password} https://api.bitbucket.org/2.0/repositories/talend/@{name}"/>
           </exec>
            <echo message="creating remote [@{name}] "/>
             <exec executable="curl" failonerror="true">
               <arg line="-f -X POST -u ${remote.git.username}:${remote.git.password} -H &quot;Content-Type: application/json&quot; https://api.bitbucket.org/2.0/repositories/talend/@{name} -d '{&quot;scm&quot;: &quot;git&quot;, &quot;is_private&quot;: true}'"/>
           </exec>
        </sequential>
    </macrodef>
	
    <!-- = = = = = = = = = = = = = = = = =
          macrodef: git-init-final-repo   
          this initialise the final repo and creates an initial commit to have the master branch and be able to use it.   
          It also creates the branches 
         = = = = = = = = = = = = = = = = = -->
    <macrodef name="git-init-final-repo">
        <attribute name="name" description="name of the repo"/>
        <sequential>
            <local name="repo.path"/><!-- make the property local-->
        	<property name="repo.path" value="${final.repos.path}/@{name}"/>
            <echo message="initializing  [${repo.path}] "/>
            <exec executable="git" failonerror="true">
                <arg line="init ${repo.path}/"/>
           </exec>
            <exec executable="touch" dir="${repo.path}" failonerror="true">
                <arg line=".gitignore"/>
           </exec>
            <exec executable="git" dir="${repo.path}" failonerror="true">
                <arg line="add .gitignore"/>
            </exec>
           <exec executable="git" dir="${repo.path}" failonerror="true">
                <arg line="commit -am &quot;intial commit for migration&quot;"/>
           </exec>
            <for list="${list.of.branches}" param="branch.name">
                <sequential>
                    <exec executable="git" dir="${repo.path}" failonerror="true">
                         <arg line="branch @{branch.name}"/>
                    </exec>
                </sequential>     
            </for>
        </sequential>
    </macrodef>

<!-- ================================= 
          target: git-init-final-repo.test              
         ================================= -->
    <target name="test.git-init-final-repo" depends="clean.final.repos" >
        <git-init-final-repo name="testRepo"/>
    </target>

	<!-- ================================= 
          target: git-merge-repo.test              
         ================================= -->
    <target name="test.git-merge-repo" depends="clean.workspace, clean.final.repos">
    	<copy-original-to-workspace from="tos/"/>
    	<git-init-final-repo name="remote-tos"/>
    	<git-merge-repo to="remote-tos" from="tos"/> 
    </target>

    <!-- ================================= 
          target: git-merge-repo.test              
         ================================= -->
    <target name="test.keep-branches" > <!-- depends="clean.workspace">-->
<!--     	<copy-original-to-workspace from="tis_private"/>
-->
        <keep-branches list="${list.of.branches}" repopath="${migration.workspace.path}/tis_private"/>
    </target>

    <!-- ================================= 
          target: git-merge-repo.test              
         ================================= -->
    <target name="test.keep-tags" ><!--depends="clean.workspace">
        <copy-original-to-workspace from="tis_private"/>-->

        <keep-tags list="${list.of.tags}" repopath="${migration.workspace.path}/tis_private"/>
    </target>
	
    <!-- ================================= 
          target: git-merge-repo.test              
         ================================= -->
    <target name="test.reousource-diff" depends="">
    	<property name="branches" value="branch1,branch2,branch3"/>

    	<resources id="branches_to_keep">
    		<restrict>
        		<tokens>
        		    <string value="${branches}" />
        		    <stringtokenizer delims=","/>
        		</tokens>
    			<contains text="2" casesensitive="no"/>
    		</restrict>
    	</resources>
    	<echo message="branches_to_keep=${toString:branches_to_keep}"/>
    	<resources id="A">
    	    <string value="a"/>
    	    <string value="b"/>
    	</resources>
    	<resources id="B">
    	      <string value="b"/>
    	      <string value="c"/>
    	</resources>
    	<union id="union"><resources refid="A"/><resources refid="B"/></union>
    	<intersect id="intersect"><resources refid="A"/><resources refid="B"/></intersect>
    	<difference id="difference"><resources refid="A"/><resources refid="B"/></difference>
    	<difference id="no.in.A">
    		<resources refid="B"/>
    		<intersect id="intersect"><resources refid="A"/><resources refid="B"/></intersect>
    	</difference>
    	<echo>
    	      A: ${toString:A}                    = a;b
    	      B: ${toString:B}                    = b;c

    	      union     : ${toString:union}       = a;b;c
    	      intersect : ${toString:intersect}   = b
    	      difference: ${toString:difference}  = a;c
    		  B not in A: ${toString:no.in.A}     = c
    	    </echo>
    </target>
	
	
</project>
