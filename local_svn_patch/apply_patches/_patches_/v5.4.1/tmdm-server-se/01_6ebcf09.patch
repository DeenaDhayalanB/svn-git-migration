diff --git a/org.talend.mdm.core/src/com/amalto/core/history/accessor/record/SimpleValue.java b/org.talend.mdm.core/src/com/amalto/core/history/accessor/record/SimpleValue.java
index 3ac7e06..e092733 100644
--- a/org.talend.mdm.core/src/com/amalto/core/history/accessor/record/SimpleValue.java
+++ b/org.talend.mdm.core/src/com/amalto/core/history/accessor/record/SimpleValue.java
@@ -44,7 +44,8 @@ class SimpleValue implements Setter, Getter {
         if (element.field instanceof ReferenceFieldMetadata) {
             StringBuilder builder = new StringBuilder();
             for (FieldMetadata keyField : ((ReferenceFieldMetadata) element.field).getReferencedType().getKeyFields()) {
-                builder.append('[').append(record.get(keyField)).append(']');
+                DataRecord referencedRecord = (DataRecord) record.get(element.field);
+                builder.append('[').append(referencedRecord.get(keyField)).append(']');
             }
             return builder.toString();
         } else {
diff --git a/org.talend.mdm.core/src/com/amalto/core/integrity/DefaultCheckDataSource.java b/org.talend.mdm.core/src/com/amalto/core/integrity/DefaultCheckDataSource.java
index 02cb8c1..1288a77 100644
--- a/org.talend.mdm.core/src/com/amalto/core/integrity/DefaultCheckDataSource.java
+++ b/org.talend.mdm.core/src/com/amalto/core/integrity/DefaultCheckDataSource.java
@@ -15,23 +15,20 @@ package com.amalto.core.integrity;
 
 import com.amalto.core.ejb.ItemPOJO;
 import com.amalto.core.ejb.ItemPOJOPK;
+import com.amalto.core.metadata.MetadataUtils;
 import com.amalto.core.objects.datacluster.ejb.DataClusterPOJOPK;
 import com.amalto.core.server.ServerContext;
+import com.amalto.core.server.StorageAdmin;
+import com.amalto.core.storage.Storage;
 import com.amalto.core.util.Util;
 import com.amalto.core.util.XtentisException;
 import com.amalto.xmlserver.interfaces.IWhereItem;
 import com.amalto.xmlserver.interfaces.WhereCondition;
 import org.apache.commons.lang.StringUtils;
 import org.apache.log4j.Logger;
-import org.talend.mdm.commmon.metadata.FieldMetadata;
-import org.talend.mdm.commmon.metadata.MetadataRepository;
-import org.talend.mdm.commmon.metadata.ReferenceFieldMetadata;
-import org.talend.mdm.commmon.metadata.TypeMetadata;
+import org.talend.mdm.commmon.metadata.*;
 
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
 import static com.amalto.core.integrity.FKIntegrityCheckResult.*;
 
@@ -67,30 +64,53 @@ class DefaultCheckDataSource implements FKIntegrityCheckDataSource {
 
     public long countInboundReferences(String clusterName, String[] ids, String fromTypeName, ReferenceFieldMetadata fromReference)
             throws XtentisException {
-
         // For the anonymous type and leave the type name empty
-        if (fromTypeName == null || fromTypeName.trim().equals("")) //$NON-NLS-1$
+        if (fromTypeName == null || fromTypeName.trim().equals("")) { //$NON-NLS-1$
             return 0;
-
+        }
         // Transform ids into the string format expected in base
         StringBuilder referencedId = new StringBuilder(); //$NON-NLS-1$
         for (String id : ids) {
             referencedId.append('[').append(id).append(']');
         }
-
         LinkedHashMap<String, String> conceptPatternsToClusterName = new LinkedHashMap<String, String>();
         conceptPatternsToClusterName.put(".*", clusterName); //$NON-NLS-1$
-
-        String leftPath = fromReference.getEntityTypeName() + '/' + fromReference.getPath();
-        IWhereItem whereItem = new WhereCondition(leftPath,
-                WhereCondition.EQUALS,
-                referencedId.toString(),
-                WhereCondition.NO_OPERATOR);
-
-        return Util.getXmlServerCtrlLocal().countItems(new LinkedHashMap(),
-                conceptPatternsToClusterName,
-                fromTypeName,
-                whereItem);
+        StorageAdmin storageAdmin = ServerContext.INSTANCE.get().getStorageAdmin();
+        Storage storage = storageAdmin.get(clusterName, null);
+        if (storage != null) {
+            MetadataRepository repository = storage.getMetadataRepository();
+            ComplexTypeMetadata complexType = repository.getComplexType(fromTypeName);
+            Set<List<FieldMetadata>> paths = MetadataUtils.paths(complexType, fromReference);
+            long inboundReferenceCount = 0;
+            for (List<FieldMetadata> path : paths) {
+                StringBuilder builder = new StringBuilder();
+                builder.append(complexType.getName()).append('/');
+                for (FieldMetadata fieldMetadata : path) {
+                    builder.append(fieldMetadata.getName()).append('/');
+                }
+                String leftPath = builder.toString();
+                IWhereItem whereItem = new WhereCondition(leftPath,
+                        WhereCondition.EQUALS,
+                        referencedId.toString(),
+                        WhereCondition.NO_OPERATOR);
+                inboundReferenceCount += Util.getXmlServerCtrlLocal().countItems(new LinkedHashMap<String, String>(),
+                        conceptPatternsToClusterName,
+                        fromTypeName,
+                        whereItem);
+            }
+            return inboundReferenceCount;
+        } else {
+            // For XML based storage
+            String leftPath = fromReference.getEntityTypeName() + '/' + fromReference.getPath();
+            IWhereItem whereItem = new WhereCondition(leftPath,
+                    WhereCondition.EQUALS,
+                    referencedId.toString(),
+                    WhereCondition.NO_OPERATOR);
+            return Util.getXmlServerCtrlLocal().countItems(new LinkedHashMap<String, String>(),
+                    conceptPatternsToClusterName,
+                    fromTypeName,
+                    whereItem);
+        }
     }
 
     public Set<ReferenceFieldMetadata> getForeignKeyList(String concept, String dataModel) throws XtentisException {
diff --git a/org.talend.mdm.core/src/com/amalto/core/metadata/ClassRepository.java b/org.talend.mdm.core/src/com/amalto/core/metadata/ClassRepository.java
index d177c14..c68a69e 100644
--- a/org.talend.mdm.core/src/com/amalto/core/metadata/ClassRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/metadata/ClassRepository.java
@@ -60,10 +60,10 @@ public class ClassRepository extends MetadataRepository {
         // Create a type for MAPs
         ComplexTypeMetadata internalMapType = new ComplexTypeMetadataImpl(getUserNamespace(), MAP_TYPE_NAME, false);
         SimpleTypeMetadata embeddedXml = new SimpleTypeMetadata(StringUtils.EMPTY, EMBEDDED_XML);
-        embeddedXml.addSuperType(STRING, this);
+        embeddedXml.addSuperType(STRING);
         embeddedXml.setData(MetadataRepository.DATA_MAX_LENGTH, String.valueOf(Integer.MAX_VALUE));
-        internalMapType.addField(new SimpleTypeFieldMetadata(internalMapType, false, false, false, "key", STRING, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        internalMapType.addField(new SimpleTypeFieldMetadata(internalMapType, false, false, false, "value", embeddedXml, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
+        internalMapType.addField(new SimpleTypeFieldMetadata(internalMapType, false, false, false, "key", STRING, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        internalMapType.addField(new SimpleTypeFieldMetadata(internalMapType, false, false, false, "value", embeddedXml, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
         MAP_TYPE = (ComplexTypeMetadata) internalMapType.freeze();
         addTypeMetadata(MAP_TYPE);
         // Register known subclasses
@@ -80,10 +80,16 @@ public class ClassRepository extends MetadataRepository {
         for (Class clazz : classes) {
             loadClass(clazz);
         }
-        // Freeze (and validate) types
+        // Freeze types
         for (TypeMetadata typeMetadata : getTypes()) {
             typeMetadata.freeze();
         }
+        // Freeze usages
+        for (TypeMetadata typeMetadata : getTypes()) {
+            if (typeMetadata instanceof ComplexTypeMetadata) {
+                ((ComplexTypeMetadata) typeMetadata).freezeUsages();
+            }
+        }
     }
 
     public Class getJavaClass(String entityTypeName) {
@@ -118,8 +124,7 @@ public class ClassRepository extends MetadataRepository {
                     STRING,
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    StringUtils.EMPTY);
+                    Collections.<String>emptyList());
             keyField.setData(LINK, "PK/unique-id"); //$NON-NLS-1$
             classType.addField(keyField);
         } else if (isEntity && ServiceBean.class.isAssignableFrom(clazz)) {
@@ -137,7 +142,7 @@ public class ClassRepository extends MetadataRepository {
             for (Class subClass : subClasses) {
                 TypeMetadata typeMetadata = loadClass(subClass);
                 typeMetadata.setInstantiable(superType.isInstantiable());
-                typeMetadata.addSuperType(superType, this);
+                typeMetadata.addSuperType(superType);
             }
             if (superType.isInstantiable()) {
                 typeStack.push(superType);
@@ -173,7 +178,7 @@ public class ClassRepository extends MetadataRepository {
                         continue;
                     } else if (Class.class.equals(returnType)) {
                         continue;
-                    } else if (returnType.getPackage() != null && returnType.getPackage().getName().startsWith("java.io")) {
+                    } else if (returnType.getPackage() != null && returnType.getPackage().getName().startsWith("java.io")) { //$NON-NLS-1$
                         continue;
                     }
                     if (returnType.isPrimitive() || returnType.getName().startsWith(JAVA_LANG_PREFIX)) {
@@ -195,8 +200,7 @@ public class ClassRepository extends MetadataRepository {
                                 fieldType,
                                 Collections.<String>emptyList(),
                                 Collections.<String>emptyList(),
-                                Collections.<String>emptyList(),
-                                StringUtils.EMPTY);
+                                Collections.<String>emptyList());
                         LongString annotation = declaredMethod.getAnnotation(LongString.class);
                         if (Types.STRING.equals(fieldTypeName) && annotation != null) {
                             fieldType.setData(MetadataRepository.DATA_MAX_LENGTH, String.valueOf(Integer.MAX_VALUE));
@@ -213,15 +217,13 @@ public class ClassRepository extends MetadataRepository {
                                     isMany,
                                     false,
                                     fieldName,
-                                    new ContainedComplexTypeRef(
-                                            typeStack.peek(),
+                                    new SoftTypeRef(this,
                                             StringUtils.EMPTY,
                                             fieldType.getName(),
-                                            fieldType),
-                                    Collections.<String>emptyList(),
+                                            false),
                                     Collections.<String>emptyList(),
                                     Collections.<String>emptyList(),
-                                    StringUtils.EMPTY);
+                                    Collections.<String>emptyList());
                         } else {
                             newField = new ReferenceFieldMetadata(typeStack.peek(),
                                     false,
@@ -236,8 +238,7 @@ public class ClassRepository extends MetadataRepository {
                                     STRING,
                                     Collections.<String>emptyList(),
                                     Collections.<String>emptyList(),
-                                    Collections.<String>emptyList(),
-                                    StringUtils.EMPTY);
+                                    Collections.<String>emptyList());
                         }
                     }
                     typeStack.peek().addField(newField);
@@ -253,8 +254,7 @@ public class ClassRepository extends MetadataRepository {
                 new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                 Collections.<String>emptyList(),
                 Collections.<String>emptyList(),
-                Collections.<String>emptyList(),
-                StringUtils.EMPTY));
+                Collections.<String>emptyList()));
         
         return typeStack.pop();
     }
@@ -313,13 +313,13 @@ public class ClassRepository extends MetadataRepository {
     }
 
     private static boolean isBooleanGetter(Method declaredMethod) {
-        return declaredMethod.getName().startsWith(BOOLEAN_PREFIX)
-                && declaredMethod.getName().length() > BOOLEAN_PREFIX.length();
+        String name = declaredMethod.getName();
+        return name.startsWith(BOOLEAN_PREFIX) && name.length() > BOOLEAN_PREFIX.length();
     }
 
     private static boolean isGetter(Method declaredMethod) {
-        return declaredMethod.getName().startsWith(GETTER_PREFIX)
-                && declaredMethod.getName().length() > GETTER_PREFIX.length();
+        String name = declaredMethod.getName();
+        return name.startsWith(GETTER_PREFIX) && name.length() > GETTER_PREFIX.length();
     }
 
     private static Class<?> getListItemClass(Method declaredMethod, Class<?> returnType) {
diff --git a/org.talend.mdm.core/src/com/amalto/core/metadata/MetadataUtils.java b/org.talend.mdm.core/src/com/amalto/core/metadata/MetadataUtils.java
index 7aa8b8a..ff3ce3d 100644
--- a/org.talend.mdm.core/src/com/amalto/core/metadata/MetadataUtils.java
+++ b/org.talend.mdm.core/src/com/amalto/core/metadata/MetadataUtils.java
@@ -50,7 +50,7 @@ public class MetadataUtils {
      * <ul>
      * <li>ER(E) is the entity rank of E.</li>
      * <li>N the number of entities in <code>repository</code></li>
-     * <li>d an adjustement factor (between 0 and 1)</li>
+     * <li>d an adjustment factor (between 0 and 1)</li>
      * <li>ER(Ei) is the entity rank for entity Ei that E references via a reference field</li>
      * <li>C(Ei) the number of entities in <code>repository</code> that reference Ei in the repository.</li>
      * </ul>
@@ -118,100 +118,166 @@ public class MetadataUtils {
      * </ul>
      * </p>
      *
-     * @param origin Point of entry in the metadata graph.
+     * @param type Point of entry in the metadata graph.
      * @param target Field to look for as end of path.
-     * @return A path from type <code>origin</code> to field <code>target</code>. Returns empty stack if no path could be found.
+     * @return A path from type <code>origin</code> to field <code>target</code>. Returns empty list if no path could be found.
      * @throws IllegalArgumentException If either <code>origin</code> or <code>path</code> is null.
      */
-    public static List<FieldMetadata> path(ComplexTypeMetadata origin, FieldMetadata target, boolean includeReferences) {
-        if (origin == null) {
+    public static List<FieldMetadata> path(ComplexTypeMetadata type, FieldMetadata target, boolean includeReferences) {
+        Stack<FieldMetadata> path = new Stack<FieldMetadata>();
+        _path(type, target, path, new HashSet<ComplexTypeMetadata>(), includeReferences);
+        return path;
+    }
+
+    private static void _path(ComplexTypeMetadata type,
+                              FieldMetadata target,
+                              Stack<FieldMetadata> path,
+                              Set<ComplexTypeMetadata> processedTypes,
+                              boolean includeReferences) {
+        // Various optimizations for very simple cases
+        if (type == null) {
             throw new IllegalArgumentException("Origin can not be null");
         }
         if (target == null) {
             throw new IllegalArgumentException("Target field can not be null");
         }
-        if (Storage.PROJECTION_TYPE.equals(origin.getName()) && origin.hasField(target.getName())) {
-            return Collections.singletonList(origin.getField(target.getName()));
+        if (Storage.PROJECTION_TYPE.equals(type.getName()) && type.hasField(target.getName())) {
+            path.push(type.getField(target.getName()));
         }
-        if (target.getContainingType().equals(origin)) { // Optimization: don't compute paths if field is defined in origin type.
-            return Collections.singletonList(origin.getField(target.getName()));
+        if (target.getContainingType() instanceof ContainedComplexTypeMetadata) {
+            String targetPath = target.getPath();
+            if (type.hasField(targetPath)) {
+                StringTokenizer tokenizer = new StringTokenizer(targetPath, "/"); //$NON-NLS-1$
+                StringBuilder currentPath = new StringBuilder();
+                while (tokenizer.hasMoreTokens()) {
+                    currentPath.append(tokenizer.nextToken()).append('/');
+                    path.add(type.getField(currentPath.toString()));
+                }
+                return;
+            }
         }
-        Stack<FieldMetadata> processStack = new Stack<FieldMetadata>();
-        LinkedList<FieldMetadata> path = new LinkedList<FieldMetadata>();
-        processStack.addAll(origin.getFields());
-        Set<FieldMetadata> processedFields = new HashSet<FieldMetadata>();
-        while (!processStack.isEmpty()) {
-            FieldMetadata current = processStack.pop();
-            if (!path.isEmpty() && path.getLast().getContainingType().equals(current.getContainingType())) {
-                path.removeLast();
-            }
-            if (current.equals(target)) {
-                path.add(current);
-                int lastIndex = path.size() - 1;
-                Iterator<FieldMetadata> iterator = path.descendingIterator();
-                while (iterator.hasNext()) {
-                    if (iterator.next().getContainingType().equals(origin)) {
-                        break;
-                    }
-                    lastIndex--;
+        //
+        if (processedTypes.contains(type)) {
+            return;
+        }
+        processedTypes.add(type);
+        Collection<FieldMetadata> fields = type.getFields();
+        for (FieldMetadata current : fields) {
+            path.push(current);
+            if (current == target) {
+                return;
+            }
+            if (current instanceof ContainedTypeFieldMetadata) {
+                ComplexTypeMetadata containedType = ((ContainedTypeFieldMetadata) current).getContainedType();
+                _path(containedType, target, path, processedTypes, includeReferences);
+                if (path.peek() == target) {
+                    return;
                 }
-                for (int j = 0; j < lastIndex; j++) {
-                    path.remove(0);
+                for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
+                    for (FieldMetadata field : subType.getFields()) {
+                        if (field.getDeclaringType() == subType) {
+                            _path(subType, target, path, processedTypes, includeReferences);
+                            if (path.peek() == target) {
+                                return;
+                            }
+                        }
+                    }
                 }
-                return path;
-            } else if (!(current instanceof SimpleTypeFieldMetadata || current instanceof EnumerationFieldMetadata)) {
-                path.add(current);
-            }
-            if (!processedFields.contains(current)) {
-                processedFields.add(current);
-                if (current instanceof ContainedTypeFieldMetadata) {
-                    ContainedComplexTypeMetadata containedType = ((ContainedTypeFieldMetadata) current).getContainedType();
-                    if (includeReferences) {
-                        processStack.addAll(containedType.getFields());
-                        for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
-                            for (FieldMetadata field : subType.getFields()) {
-                                if (field.getDeclaringType() == subType) {
-                                    processStack.add(field);
+            } else if (current instanceof ReferenceFieldMetadata) {
+                if (includeReferences) {
+                    ComplexTypeMetadata referencedType = ((ReferenceFieldMetadata) current).getReferencedType();
+                    _path(referencedType, target, path, processedTypes, true);
+                    if (path.peek() == target) {
+                        return;
+                    }
+                    for (ComplexTypeMetadata subType : referencedType.getSubTypes()) {
+                        for (FieldMetadata field : subType.getFields()) {
+                            if (field.getDeclaringType() == subType) {
+                                _path(subType, target, path,processedTypes,  true);
+                                if (path.peek() == target) {
+                                    return;
                                 }
                             }
                         }
-                    } else {
-                        for (FieldMetadata fieldMetadata : containedType.getFields()) {
-                            if (includeFieldInPath(fieldMetadata, target)) {
-                                processStack.add(fieldMetadata);
+                    }
+                }
+            }
+            path.pop();
+        }
+    }
+
+    /**
+     * <p>
+     * Find <b>all</b> paths from type <code>origin</code> to field <code>target</code>.
+     * </p>
+     * <p>
+     * This is a rather expensive operation, so use this method only when needed. When you need only <b>a</b> path to
+     * field <code>target</code>, prefer usage of {@link #path(org.talend.mdm.commmon.metadata.ComplexTypeMetadata, org.talend.mdm.commmon.metadata.FieldMetadata)}.
+     * </p>
+     * <p>
+     * This method follows references to other type <b>only</b> when type is not instantiable (see {@link org.talend.mdm.commmon.metadata.TypeMetadata#isInstantiable()}).
+     * </p>
+     *
+     * @param type Point of entry in the metadata graph.
+     * @param target Field to look for as end of path.
+     * @return A path from type <code>origin</code> to field <code>target</code>. Returns empty list if no path could be found.
+     * @throws IllegalArgumentException If either <code>origin</code> or <code>path</code> is null.
+     * @see #path(org.talend.mdm.commmon.metadata.ComplexTypeMetadata, org.talend.mdm.commmon.metadata.FieldMetadata)
+     */
+    public static Set<List<FieldMetadata>> paths(ComplexTypeMetadata type, FieldMetadata target) {
+        Stack<FieldMetadata> path = new Stack<FieldMetadata>();
+        HashSet<List<FieldMetadata>> foundPaths = new HashSet<List<FieldMetadata>>();
+        _paths(type, target, path, foundPaths);
+        return foundPaths;
+    }
+
+    private static void _paths(ComplexTypeMetadata type,
+                               FieldMetadata target,
+                               Stack<FieldMetadata> currentPath,
+                               Set<List<FieldMetadata>> foundPaths) {
+            // Various optimizations for very simple cases
+            if (type == null) {
+                throw new IllegalArgumentException("Origin can not be null");
+            }
+            if (target == null) {
+                throw new IllegalArgumentException("Target field can not be null");
+            }
+            if (Storage.PROJECTION_TYPE.equals(type.getName()) && type.hasField(target.getName())) {
+                currentPath.push(type.getField(target.getName()));
+            }
+            //
+            Collection<FieldMetadata> fields = type.getFields();
+            for (FieldMetadata current : fields) {
+                currentPath.push(current);
+                if (current == target) {
+                    foundPaths.add(new ArrayList<FieldMetadata>(currentPath));
+                }
+                if (current instanceof ContainedTypeFieldMetadata) {
+                    ComplexTypeMetadata containedType = ((ContainedTypeFieldMetadata) current).getContainedType();
+                    _paths(containedType, target, currentPath, foundPaths);
+                    for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
+                        for (FieldMetadata field : subType.getFields()) {
+                            if (field.getDeclaringType() == subType) {
+                                _paths(subType, target, currentPath, foundPaths);
                             }
                         }
                     }
                 } else if (current instanceof ReferenceFieldMetadata) {
                     ComplexTypeMetadata referencedType = ((ReferenceFieldMetadata) current).getReferencedType();
-                    if (includeReferences) {
-                        processStack.addAll(referencedType.getFields());
+                    if (!referencedType.isInstantiable()) {
+                        _paths(referencedType, target, currentPath, foundPaths);
                         for (ComplexTypeMetadata subType : referencedType.getSubTypes()) {
                             for (FieldMetadata field : subType.getFields()) {
                                 if (field.getDeclaringType() == subType) {
-                                    processStack.add(field);
+                                    _paths(subType, target, currentPath, foundPaths);
                                 }
                             }
                         }
-                    } else {
-                        for (FieldMetadata fieldMetadata : referencedType.getFields()) {
-                            if (includeFieldInPath(fieldMetadata, target)) {
-                                processStack.add(fieldMetadata);
-                            }
-                        }
                     }
                 }
+                currentPath.pop();
             }
         }
-        return path;
-    }
-
-    private static boolean includeFieldInPath(FieldMetadata fieldMetadata, FieldMetadata target) {
-        Collection<FieldMetadata> keyFields = fieldMetadata.getContainingType().getKeyFields();
-        return fieldMetadata.equals(target)
-                || !(fieldMetadata instanceof ReferenceFieldMetadata)
-                || (!keyFields.isEmpty() && "x_talend_id".equals(keyFields.iterator().next().getName())); //$NON-NLS-1$
-    }
 
     /**
      * Creates a value from <code>dataAsString</code>. Type and/or format of the returned value depends on <code>field</code>.
diff --git a/org.talend.mdm.core/src/com/amalto/core/query/user/BinaryLogicOperator.java b/org.talend.mdm.core/src/com/amalto/core/query/user/BinaryLogicOperator.java
index 1946935..ceaf7dc 100644
--- a/org.talend.mdm.core/src/com/amalto/core/query/user/BinaryLogicOperator.java
+++ b/org.talend.mdm.core/src/com/amalto/core/query/user/BinaryLogicOperator.java
@@ -29,6 +29,10 @@ public class BinaryLogicOperator implements Condition {
     public Expression normalize() {
         left = (Condition) left.normalize();
         right = (Condition) right.normalize();
+        // If left and right are same (cond1 OR cond1 = cond1 / cond1 AND cond1 = cond1), return one of the side
+        if (left.equals(right)) {
+            return left;
+        }
         // If right or left is a no op condition, simplify a bit the query.
         if (right == UserQueryHelper.NO_OP_CONDITION && left == UserQueryHelper.NO_OP_CONDITION) {
             return UserQueryHelper.NO_OP_CONDITION;
diff --git a/org.talend.mdm.core/src/com/amalto/core/query/user/Field.java b/org.talend.mdm.core/src/com/amalto/core/query/user/Field.java
index b42dbb4..64a4a34 100644
--- a/org.talend.mdm.core/src/com/amalto/core/query/user/Field.java
+++ b/org.talend.mdm.core/src/com/amalto/core/query/user/Field.java
@@ -16,10 +16,15 @@ import com.amalto.core.metadata.MetadataUtils;
 import org.talend.mdm.commmon.metadata.FieldMetadata;
 import org.talend.mdm.commmon.metadata.TypeMetadata;
 
+import java.util.Collections;
+import java.util.List;
+
 public class Field implements TypedExpression {
 
     private final FieldMetadata fieldMetadata;
 
+    private List<FieldMetadata> path = Collections.emptyList();
+
     public Field(FieldMetadata fieldMetadata) {
         if (fieldMetadata == null) {
             throw new IllegalArgumentException("Field can not be null.");
@@ -44,6 +49,14 @@ public class Field implements TypedExpression {
         return type.getName();
     }
 
+    public void setPath(List<FieldMetadata> path) {
+        this.path = path;
+    }
+
+    public List<FieldMetadata> getPath() {
+        return path;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) {
diff --git a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryBuilder.java b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryBuilder.java
index 720bd1a..5e69102 100644
--- a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryBuilder.java
+++ b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryBuilder.java
@@ -170,7 +170,20 @@ public class UserQueryBuilder {
         if (field instanceof ReferenceFieldMetadata) {
             throw new IllegalArgumentException("Cannot perform type check on a foreign key.");
         }
-        Condition current = new Isa(new Field(field), type);
+        // Get the matching type from the field definition (field uses a contained version of the type).
+        ComplexTypeMetadata fieldType = type;
+        if (!(fieldType instanceof ContainedComplexTypeMetadata)) {
+            fieldType = (ComplexTypeMetadata) field.getType();
+            if (!fieldType.getName().equals(type.getName())) {
+                for (ComplexTypeMetadata subType : fieldType.getSubTypes()) {
+                    if (subType.getName().equals(type.getName())) {
+                        fieldType = subType;
+                        break;
+                    }
+                }
+            }
+        }
+        Condition current = new Isa(new Field(field), fieldType);
         if (!type.getSubTypes().isEmpty()) {
             for (ComplexTypeMetadata subType : type.getSubTypes()) {
                 current = or(current, isa(field, subType));
diff --git a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryDumpConsole.java b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryDumpConsole.java
index 8838684..e0275ea 100644
--- a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryDumpConsole.java
+++ b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryDumpConsole.java
@@ -16,6 +16,7 @@ import org.apache.log4j.Level;
 import org.talend.mdm.commmon.metadata.*;
 import org.apache.log4j.Logger;
 
+import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -320,49 +321,45 @@ public class UserQueryDumpConsole implements Visitor<Void> {
     }
 
     public Void visit(Field field) {
-        print("[FIELD]"); //$NON-NLS-1$
-        increaseIndent();
-        {
-            field.getFieldMetadata().accept(new DefaultMetadataVisitor<Void>() {
-                @Override
-                public Void visit(ReferenceFieldMetadata referenceField) {
-                    print(getFieldPath(referenceField));
-                    return null;
-                }
+        DefaultMetadataVisitor<String> fieldPrinter = new DefaultMetadataVisitor<String>() {
+            @Override
+            public String visit(ReferenceFieldMetadata referenceField) {
+                return referenceField.getEntityTypeName() + '/' + referenceField.getPath();
+            }
 
-                @Override
-                public Void visit(SimpleTypeFieldMetadata simpleField) {
-                    print(getFieldPath(simpleField));
-                    return null;
-                }
+            @Override
+            public String visit(SimpleTypeFieldMetadata simpleField) {
+                return simpleField.getEntityTypeName() + '/' + simpleField.getPath();
+            }
 
-                @Override
-                public Void visit(EnumerationFieldMetadata enumField) {
-                    print(getFieldPath(enumField));
-                    return null;
-                }
+            @Override
+            public String visit(EnumerationFieldMetadata enumField) {
+                return enumField.getEntityTypeName() + '/' + enumField.getPath();
+            }
 
-                @Override
-                public Void visit(ContainedTypeFieldMetadata containedField) {
-                    print(containedField.getName());
-                    return null;
-                }
+            @Override
+            public String visit(ContainedTypeFieldMetadata containedField) {
+                return containedField.getEntityTypeName() + '/' + containedField.getPath();
+            }
+        };
 
-                private String getFieldPath(FieldMetadata field) {
-                    StringBuilder path = new StringBuilder();
-                    ComplexTypeMetadata containingType = field.getContainingType();
-                    while (containingType != null) {
-                        path.insert(0, containingType.getName() + '/');
-                        if (containingType instanceof ContainedComplexTypeMetadata) {
-                            containingType = ((ContainedComplexTypeMetadata) containingType).getContainerType();
-                        } else {
-                            containingType = null;
-                        }
+        print("[FIELD]"); //$NON-NLS-1$
+        {
+            increaseIndent();
+            {
+                print(field.getFieldMetadata().accept(fieldPrinter));
+            }
+            increaseIndent();
+            {
+                if (field.getPath().size() > 1) {
+                    print("[PATH]"); //$NON-NLS-1$
+                    Iterator<FieldMetadata> pathIterator = field.getPath().iterator();
+                    for (int i = 1; pathIterator.hasNext(); i++) {
+                        print(i + ") " + pathIterator.next().accept(fieldPrinter)); //$NON-NLS-1$
                     }
-                    path.append(field.getName());
-                    return path.toString();
                 }
-            });
+            }
+            decreaseIndent();
         }
         decreaseIndent();
         return null;
diff --git a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryHelper.java b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryHelper.java
index 186bdd4..70704b8 100644
--- a/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryHelper.java
+++ b/org.talend.mdm.core/src/com/amalto/core/query/user/UserQueryHelper.java
@@ -93,22 +93,34 @@ public class UserQueryHelper {
                 // Field comparisons
                 if (!whereCondition.isRightValueXPath()) { // Value based comparison
                     if (isPerformingTypeCheck) {
-                        TypeMetadata typeForCheck = repository.getNonInstantiableType(repository.getUserNamespace(), value);
-                        if (typeForCheck == null) {
-                            throw new IllegalArgumentException("Type '" + value + "' was not found.");
-                        }
-                        if (!(typeForCheck instanceof ComplexTypeMetadata)) {
-                            throw new IllegalArgumentException("Expected type '" + value + "' to be a complex type.");
-                        }
-                        if (!(field instanceof Alias)) {
-                            throw new IllegalArgumentException("Expected field '" + leftFieldName + "' to be an alias.");
-                        }
-                        Alias alias = (Alias) field;
-                        if (!(alias.getTypedExpression() instanceof Type)) {
-                            throw new IllegalArgumentException("Expected alias '" + leftFieldName + "' to be an alias of type.");
+                        if (!WhereCondition.EMPTY_NULL.equals(whereCondition.getOperator())) {
+                            if (!(field instanceof Alias)) {
+                                throw new IllegalArgumentException("Expected field '" + leftFieldName + "' to be an alias.");
+                            }
+                            Alias alias = (Alias) field;
+                            if (!(alias.getTypedExpression() instanceof Type)) {
+                                throw new IllegalArgumentException("Expected alias '" + leftFieldName + "' to be an alias of type.");
+                            }
+                            Type fieldExpression = (Type) alias.getTypedExpression();
+                            ComplexTypeMetadata typeForCheck = (ComplexTypeMetadata) fieldExpression.getField().getFieldMetadata().getType();
+                            if (!typeForCheck.getName().equals(value)) {
+                                for (ComplexTypeMetadata subType : typeForCheck.getSubTypes()) {
+                                    if (subType.getName().equals(value)) {
+                                        typeForCheck = subType;
+                                        break;
+                                    }
+                                }
+                            }
+                            condition = isa(fieldExpression.getField().getFieldMetadata(), typeForCheck);
+                        } else {
+                            // TMDM-6831: Consider a "emptyOrNull(type)" as a "isa(field, actual_field_type)".
+                            Alias alias = (Alias) field;
+                            if (!(alias.getTypedExpression() instanceof Type)) {
+                                throw new IllegalArgumentException("Expected alias '" + leftFieldName + "' to be an alias of type.");
+                            }
+                            Type fieldExpression = (Type) alias.getTypedExpression();
+                            condition = emptyOrNull(fieldExpression);
                         }
-                        Type fieldExpression = (Type) alias.getTypedExpression();
-                        condition = isa(fieldExpression.getField().getFieldMetadata(), ((ComplexTypeMetadata) typeForCheck));
                     }
                     String fieldTypeName = field.getTypeName();
                     boolean isFk = field instanceof Field && ((Field) field).getFieldMetadata() instanceof ReferenceFieldMetadata;
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/StorageWrapper.java b/org.talend.mdm.core/src/com/amalto/core/storage/StorageWrapper.java
index 288caa8..d4dc466 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/StorageWrapper.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/StorageWrapper.java
@@ -583,7 +583,7 @@ public class StorageWrapper implements IXmlServerSLWrapper {
     }
 
     private int getTypeItemCount(ItemPKCriteria criteria, ComplexTypeMetadata type, Storage storage) {        
-        StorageResults results = storage.fetch(buildQueryBuilder(from(type), criteria, type).getSelect());
+        StorageResults results = storage.fetch(buildQueryBuilder(from(type).selectId(type), criteria, type).getSelect());
         try {
             return results.getCount();
         } finally {
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/AbstractQueryHandler.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/AbstractQueryHandler.java
index dd8ae10..10eba26 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/AbstractQueryHandler.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/AbstractQueryHandler.java
@@ -74,10 +74,7 @@ abstract class AbstractQueryHandler extends VisitorAdapter<StorageResults> {
 
     String getFieldName(FieldMetadata fieldMetadata, boolean includeTypeName, boolean resolveReferencedField) {
         // Move up to the first complex type (contained type do not have any mapping).
-        TypeMetadata containingType = fieldMetadata.getContainingType();
-        while (containingType != null && containingType instanceof ContainedComplexTypeMetadata) {
-            containingType = ((ContainedComplexTypeMetadata) containingType).getContainerType();
-        }
+        TypeMetadata containingType = fieldMetadata.getContainingType().getEntity();
         if (containingType == null) {
             throw new IllegalStateException("Could not find containing type mapping for field '" + fieldMetadata.getName() + "'.");
         }
@@ -234,10 +231,12 @@ abstract class AbstractQueryHandler extends VisitorAdapter<StorageResults> {
 
         boolean isMany;
 
-        String criterionFieldName;
+        List<String> criterionFieldNames = new LinkedList<String>();
 
         FieldMetadata fieldMetadata;
 
+        Field field;
+
         boolean isProperty;
 
         int position = -1;
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FlatTypeMapping.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FlatTypeMapping.java
index 56c4847..270675b 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FlatTypeMapping.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FlatTypeMapping.java
@@ -39,11 +39,11 @@ class FlatTypeMapping extends TypeMapping {
     }
 
     protected void map(FieldMetadata user, FieldMetadata database) {
-        if (isFrozen) {
-            throw new IllegalStateException("Mapping is frozen.");
-        }
-        userToDatabase.put(user.getDeclaringType().getName() + '_' + user.getName(), database);
-        databaseToUser.put(database.getDeclaringType().getName() + '_' + database.getName(), user);
+        // TODO Investigate why map gets called after mapping is frozen.
+        String userKey = user.getDeclaringType().getName() + '_' + user.getName();
+        String databaseKey = database.getDeclaringType().getName() + '_' + database.getName();
+        userToDatabase.put(userKey, database);
+        databaseToUser.put(databaseKey, user);
     }
 
     public FieldMetadata getDatabase(FieldMetadata from) {
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FullTextQueryHandler.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FullTextQueryHandler.java
index 5782df5..62d14c8 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FullTextQueryHandler.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/FullTextQueryHandler.java
@@ -190,7 +190,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                             }
                             if (aliasName != null) {
                                 SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName == null ? fieldMetadata.getType().getName() : typeName);
-                                fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                                fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                                 explicitProjectionType.addField(fieldMetadata);
                             } else {
                                 explicitProjectionType.addField(fieldMetadata);
@@ -203,7 +203,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                         public Void visit(StringConstant constant) {
                             if (aliasName != null) {
                                 SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName);
-                                FieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                                FieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                                 explicitProjectionType.addField(fieldMetadata);
                                 nextRecord.set(fieldMetadata, constant.getValue());
                             } else {
@@ -216,7 +216,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                         public Void visit(Count count) {
                             if (aliasName != null) {
                                 SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName);
-                                FieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                                FieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                                 explicitProjectionType.addField(fieldMetadata);
                                 nextRecord.set(fieldMetadata, list.size());
                             }
@@ -238,7 +238,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                         @Override
                         public Void visit(Timestamp timestamp) {
                             SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName);
-                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                             explicitProjectionType.addField(aliasField);
                             nextRecord.set(aliasField, next.getRecordMetadata().getLastModificationTime());
                             return null;
@@ -247,7 +247,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                         @Override
                         public Void visit(TaskId taskId) {
                             SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName);
-                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                             explicitProjectionType.addField(aliasField);
                             nextRecord.set(aliasField, next.getRecordMetadata().getTaskId());
                             return null;
@@ -257,7 +257,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                         public Void visit(Type type) {
                             FieldMetadata fieldMetadata = type.getField().getFieldMetadata();
                             SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typeName);
-                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+                            SimpleTypeFieldMetadata aliasField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, aliasName, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                             explicitProjectionType.addField(aliasField);
                             DataRecord dataRecord = (DataRecord) next.get(fieldMetadata.getName());
                             if (dataRecord != null) {
@@ -321,8 +321,7 @@ class FullTextQueryHandler extends AbstractQueryHandler {
                                     fieldType,
                                     Collections.<String>emptyList(),
                                     Collections.<String>emptyList(),
-                                    Collections.<String>emptyList(),
-                                    StringUtils.EMPTY);
+                                    Collections.<String>emptyList());
                             explicitProjectionType.addField(newField);
                             TypedExpression typedExpression = alias.getTypedExpression();
                             if (typedExpression instanceof StringConstant) {
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/HibernateStorage.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/HibernateStorage.java
index 16daf30..36109af 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/HibernateStorage.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/HibernateStorage.java
@@ -279,10 +279,7 @@ public class HibernateStorage implements Storage {
                                 continue;
                             }
                             // Go up the containment tree in case containing type is anonymous.
-                            ComplexTypeMetadata containingType = indexedField.getContainingType();
-                            while (containingType instanceof ContainedComplexTypeMetadata) {
-                                containingType = ((ContainedComplexTypeMetadata) containingType).getContainerType();
-                            }
+                            ComplexTypeMetadata containingType = indexedField.getContainingType().getEntity();
                             TypeMapping mapping = mappingRepository.getMappingFromUser(containingType);
                             FieldMetadata databaseField = mapping.getDatabase(indexedField);
                             if (!isIndexable(databaseField.getType())) {
@@ -397,7 +394,7 @@ public class HibernateStorage implements Storage {
                 if (dataSource.getDialectName() == RDBMSDataSource.DataSourceDialect.ORACLE_10G) {
                     properties.setProperty(Environment.DEFAULT_SCHEMA, dataSource.getUserName());
                 }
-                // Logs DDL *before* initialization in case initialization (useful for debugging).
+                // Logs DDL *before* initialization in case initialization fails (useful for debugging).
                 if (LOGGER.isTraceEnabled()) {
                     traceDDL();
                 }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/IdQueryHandler.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/IdQueryHandler.java
index 8a6c079..dc90fcb 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/IdQueryHandler.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/IdQueryHandler.java
@@ -210,8 +210,7 @@ class IdQueryHandler extends AbstractQueryHandler {
                     new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, typedExpression.getTypeName()),
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    currentAliasName);
+                    Collections.<String>emptyList());
             explicitProjectionType.addField(fieldType);
             return fieldType;
         }
@@ -232,8 +231,7 @@ class IdQueryHandler extends AbstractQueryHandler {
                         fieldMetadata.getType(),
                         Collections.<String>emptyList(),
                         Collections.<String>emptyList(),
-                        Collections.<String>emptyList(),
-                        currentAliasName);
+                        Collections.<String>emptyList());
                 explicitProjectionType.addField(fieldType);
                 nextRecord.set(fieldType, o);
             }
@@ -251,8 +249,7 @@ class IdQueryHandler extends AbstractQueryHandler {
                     new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.LONG),
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    currentAliasName);
+                    Collections.<String>emptyList());
             explicitProjectionType.addField(fieldType);
             nextRecord.set(fieldType, 1L);
             return null;
@@ -272,8 +269,7 @@ class IdQueryHandler extends AbstractQueryHandler {
                     new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    currentAliasName);
+                    Collections.<String>emptyList());
             explicitProjectionType.addField(fieldType);
             nextRecord.set(fieldType, o.getType().getName());
             return null;
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/InternalRepository.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/InternalRepository.java
index d3373ef..a7de65f 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/InternalRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/InternalRepository.java
@@ -22,6 +22,8 @@ public abstract class InternalRepository implements MetadataVisitor<MetadataRepo
 
     private MetadataRepository userRepository;
 
+    private final MappingCreatorContext scatteredContext = new StatefulContext();
+
     final TypeMappingStrategy strategy;
 
     MappingRepository mappings;
@@ -47,9 +49,6 @@ public abstract class InternalRepository implements MetadataVisitor<MetadataRepo
         for (TypeMetadata type : repository.getUserComplexTypes()) {
             type.accept(this);
         }
-        for (TypeMetadata type : repository.getNonInstantiableTypes()) {
-            type.accept(this);
-        }
         for (TypeMapping typeMapping : mappings.getAllTypeMappings()) {
             typeMapping.freeze();
         }
@@ -83,6 +82,7 @@ public abstract class InternalRepository implements MetadataVisitor<MetadataRepo
                 }
                 return new ScatteredMappingCreator(internalRepository,
                         mappings,
+                        scatteredContext,
                         strategy.preferClobUse(),
                         strategy.useTechnicalFk());
             default:
@@ -97,7 +97,7 @@ public abstract class InternalRepository implements MetadataVisitor<MetadataRepo
     }
 
     public MetadataRepository visit(SimpleTypeMetadata simpleType) {
-        internalRepository.addTypeMetadata(simpleType.copy(internalRepository));
+        internalRepository.addTypeMetadata(simpleType.copy());
         return internalRepository;
     }
 
@@ -172,7 +172,7 @@ public abstract class InternalRepository implements MetadataVisitor<MetadataRepo
 
         @Override
         public TypeMappingStrategy visit(ContainedTypeFieldMetadata containedField) {
-            ContainedComplexTypeMetadata containedType = containedField.getContainedType();
+            ComplexTypeMetadata containedType = containedField.getContainedType();
             if (containedField.isMany()
                     || !containedType.getSubTypes().isEmpty()
                     || !containedType.getName().startsWith(MetadataRepository.ANONYMOUS_PREFIX)) {
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ManyFieldProjection.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ManyFieldProjection.java
index 2ff7a49..896dc0b 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ManyFieldProjection.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ManyFieldProjection.java
@@ -22,9 +22,11 @@ import org.hibernate.type.Type;
 import org.talend.mdm.commmon.metadata.ComplexTypeMetadata;
 import org.talend.mdm.commmon.metadata.FieldMetadata;
 
+import java.util.Set;
+
 class ManyFieldProjection extends SimpleProjection {
 
-    private final String alias;
+    private final Set<String> aliases;
 
     private final FieldMetadata field;
 
@@ -32,8 +34,8 @@ class ManyFieldProjection extends SimpleProjection {
 
     private final RDBMSDataSource dataSource;
 
-    ManyFieldProjection(String alias, FieldMetadata field, TableResolver resolver, RDBMSDataSource dataSource) {
-        this.alias = alias;
+    ManyFieldProjection(Set<String> aliases, FieldMetadata field, TableResolver resolver, RDBMSDataSource dataSource) {
+        this.aliases = aliases;
         this.field = field;
         this.resolver = resolver;
         this.dataSource = dataSource;
@@ -41,7 +43,7 @@ class ManyFieldProjection extends SimpleProjection {
 
     @Override
     public String toSqlString(Criteria criteria, int position, CriteriaQuery criteriaQuery) throws HibernateException {
-        Criteria subCriteria = StandardQueryHandler.findCriteria(criteria, alias);
+        Criteria subCriteria = StandardQueryHandler.findCriteria(criteria, aliases);
         ComplexTypeMetadata containingType = field.getContainingType();
         String containerTable = MappingGenerator.formatSQLName(resolver.get(containingType), resolver.getNameMaxLength());
         String collectionTable = MappingGenerator.formatSQLName((containerTable + '_' + field.getName()).toUpperCase(), resolver.getNameMaxLength());
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingCreatorContext.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingCreatorContext.java
new file mode 100644
index 0000000..8009e51
--- /dev/null
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingCreatorContext.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2006-2013 Talend Inc. - www.talend.com
+ *
+ * This source code is available under agreement available at
+ * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
+ *
+ * You should have received a copy of the agreement
+ * along with this program; if not, write to Talend SA
+ * 9 rue Pages 92150 Suresnes, France
+ */
+
+package com.amalto.core.storage.hibernate;
+
+import org.talend.mdm.commmon.metadata.FieldMetadata;
+
+/**
+ * A context interface used by {@link com.amalto.core.storage.hibernate.TypeMappingCreator} instances to get database
+ * column names.
+ */
+public interface MappingCreatorContext {
+    /**
+     * @param field A field from a type.
+     * @return The column name for the <code>field</code>.
+     */
+    String getFieldColumn(FieldMetadata field);
+
+    /**
+     * @param fieldName A field name (as returned by {@link org.talend.mdm.commmon.metadata.FieldMetadata#getName()}).
+     * @return The column name for the <code>fieldName</code>.
+     */
+    String getFieldColumn(String fieldName);
+}
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingExpressionTransformer.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingExpressionTransformer.java
index 0958c4e..761af42 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingExpressionTransformer.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingExpressionTransformer.java
@@ -19,6 +19,7 @@ import org.talend.mdm.commmon.metadata.CompoundFieldMetadata;
 import org.talend.mdm.commmon.metadata.FieldMetadata;
 import org.talend.mdm.commmon.metadata.Types;
 
+import java.util.*;
 public class MappingExpressionTransformer extends VisitorAdapter<Expression> {
 
     private final MappingRepository mappingRepository;
@@ -36,7 +37,7 @@ public class MappingExpressionTransformer extends VisitorAdapter<Expression> {
         if (mapping != null) {
             return mapping.getDatabase();
         } else {
-            throw new IllegalStateException();
+            throw new IllegalStateException("Type '" + type.getName() + "' does not have a mapping.");
         }
     }
 
@@ -59,12 +60,14 @@ public class MappingExpressionTransformer extends VisitorAdapter<Expression> {
                     if (databaseType.hasField(fieldMetadata.getName())) {
                         databaseField = fieldMetadata;
                     } else {
-                        throw new IllegalArgumentException("Field '" + fieldMetadata.getName() + "' does not exist in database mapping.");
+                        // Null means there's no mapping and may be used to indicate fields that shouldn't be taken into
+                        // account.
+                        return null;
                     }
                 }
                 return databaseField;
             } else {
-                throw new IllegalStateException();
+                throw new IllegalStateException("Field '" + fieldMetadata + "' is located in a type without mapping.");
             }
         }
     }
@@ -220,8 +223,51 @@ public class MappingExpressionTransformer extends VisitorAdapter<Expression> {
 
     @Override
     public Expression visit(Field field) {
-        FieldMetadata mappedFieldMetadata = getMapping(field.getFieldMetadata());
+        FieldMetadata fieldMetadata = field.getFieldMetadata();
+        FieldMetadata mappedFieldMetadata = getMapping(fieldMetadata);
+        // Compute the path from entity to field
+        ComplexTypeMetadata entity = fieldMetadata.getContainingType().getEntity();
+        List<FieldMetadata> mappingPath;
+        ComplexTypeMetadata mainType = builder.getSelect().getTypes().get(0);
+        if (!entity.equals(mainType)) { // Field is not in the main (first selected type) type, build path from join clause.
+            List<Join> joins = builder.getSelect().getJoins();
+            if (!joins.isEmpty()) {
+                List<FieldMetadata> joinPath = new LinkedList<FieldMetadata>();
+                joinPath.add(fieldMetadata);
+                FieldMetadata currentField = fieldMetadata;
+                while (!joinPath.get(0).getContainingType().equals(mainType)) {
+                    boolean foundMatchingJoin = false;
+                    for (Join join : joins) {
+                        ComplexTypeMetadata rightType = join.getRightField().getFieldMetadata().getContainingType();
+                        if (rightType.equals(currentField.getContainingType())) {
+                            currentField = join.getLeftField().getFieldMetadata();
+                            joinPath.add(0, currentField);
+                            foundMatchingJoin = true;
+                            break;
+                        }
+                    }
+                    if (!foundMatchingJoin) {
+                        // Cannot find a path in join: it'll be up to the storage to find a path (if needed).
+                        break;
+                    }
+                }
+                mappingPath = joinPath;
+            } else {
+                mappingPath = Collections.emptyList();
+            }
+        } else { // Field is in entity (could be a nested field).
+            List<FieldMetadata> path = MetadataUtils.path(entity, fieldMetadata);
+            mappingPath = new ArrayList<FieldMetadata>(path.size());
+            for (FieldMetadata pathElement : path) {
+                FieldMetadata mappedField = getMapping(pathElement);
+                if (mappedField != null) {
+                    mappingPath.add(mappedField);
+                }
+            }
+        }
+        // Create the new field (target is the mapping in database, and contains the path to field if any needs to be set).
         Field mappedField = new Field(mappedFieldMetadata);
+        mappedField.setPath(mappingPath);
         currentField = mappedField;
         return mappedField;
     }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingRepository.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingRepository.java
index 63f8cd6..40ce18e 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/MappingRepository.java
@@ -11,34 +11,44 @@
 
 package com.amalto.core.storage.hibernate;
 
-import org.apache.commons.collections.map.MultiKeyMap;
+import org.talend.mdm.commmon.metadata.ComplexTypeMetadata;
 import org.talend.mdm.commmon.metadata.TypeMetadata;
 
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
 
 public class MappingRepository {
 
-    private final MultiKeyMap userToMapping = new MultiKeyMap();
-
-    private final MultiKeyMap databaseToMapping = new MultiKeyMap();
+    private final Map<TypeMetadata, TypeMapping> userToMapping = new HashMap<TypeMetadata, TypeMapping>();
 
     public TypeMapping getMappingFromUser(TypeMetadata type) {
         if (type instanceof TypeMapping) {
             return (TypeMapping) type;
         }
-        return (TypeMapping) userToMapping.get(type.getName(), type.isInstantiable());
+        TypeMapping mapping = userToMapping.get(type);
+        if (mapping == null && type instanceof ComplexTypeMetadata) {
+            // In case, type is a nested type, only the entity type is in repository
+            mapping = userToMapping.get(((ComplexTypeMetadata) type).getEntity());
+        }
+        return mapping;
     }
 
     public TypeMapping getMappingFromDatabase(TypeMetadata type) {
         if (type instanceof TypeMapping) {
             return (TypeMapping) type;
         }
-        return (TypeMapping) databaseToMapping.get(type.getName(), type.isInstantiable());
+        for (Map.Entry<TypeMetadata, TypeMapping> entry : userToMapping.entrySet()) {
+            TypeMapping mapping = entry.getValue();
+            if (mapping.getDatabase().equals(type)) {
+                return mapping;
+            }
+        }
+        return null;
     }
 
-    public void addMapping(TypeMetadata type, TypeMapping mapping) {
-        userToMapping.put(type.getName(), type.isInstantiable(), mapping);
-        databaseToMapping.put(mapping.getDatabase().getName(), type.isInstantiable(), mapping);
+    public void addMapping(TypeMapping mapping) {
+        userToMapping.put(mapping.getUser(), mapping);
     }
 
     public Collection<TypeMapping> getAllTypeMappings() {
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/NativeQueryHandler.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/NativeQueryHandler.java
index 7877056..2a6de07 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/NativeQueryHandler.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/NativeQueryHandler.java
@@ -164,7 +164,7 @@ class NativeQueryHandler extends AbstractQueryHandler {
                     if (o != null) {
                         SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, MetadataUtils.getType(o.getClass().getName()));
                         String name = "col" + i++; //$NON-NLS-1$
-                        SimpleTypeFieldMetadata colField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, name, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), name);
+                        SimpleTypeFieldMetadata colField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, name, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                         explicitProjectionType.addField(colField);
                         nativeResult.set(colField, o);
                     }
@@ -172,7 +172,7 @@ class NativeQueryHandler extends AbstractQueryHandler {
             } else {
                 SimpleTypeMetadata fieldType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, MetadataUtils.getType(next.getClass().getName()));
                 String name = "col0"; //$NON-NLS-1$
-                SimpleTypeFieldMetadata colField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, name, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), name);
+                SimpleTypeFieldMetadata colField = new SimpleTypeFieldMetadata(explicitProjectionType, false, false, false, name, fieldType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
                 explicitProjectionType.addField(colField);
                 nativeResult.set(colField, next);
             }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ProjectionIterator.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ProjectionIterator.java
index bcaa9f2..7546ee0 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ProjectionIterator.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ProjectionIterator.java
@@ -186,8 +186,7 @@ class ProjectionIterator implements CloseableIterator<DataRecord> {
                     fieldType,
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    fieldName);
+                    Collections.<String>emptyList());
             currentElement = new ProjectionElement();
             currentElement.field = field;
         }
@@ -221,8 +220,7 @@ class ProjectionIterator implements CloseableIterator<DataRecord> {
                     new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                     Collections.<String>emptyList(),
                     Collections.<String>emptyList(),
-                    Collections.<String>emptyList(),
-                    StringUtils.EMPTY);
+                    Collections.<String>emptyList());
             currentElement = new ProjectionElement();
             currentElement.field = field;
         }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredMappingCreator.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredMappingCreator.java
index d730941..1f8a423 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredMappingCreator.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredMappingCreator.java
@@ -21,6 +21,8 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     public static final String GENERATED_ID = "x_talend_id"; //$NON-NLS-1$
 
+    protected static final int UUID_LENGTH = UUID.randomUUID().toString().length() + 10;
+
     private final MetadataRepository internalRepository;
 
     private final MappingRepository mappings;
@@ -33,38 +35,49 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     private final Stack<TypeMapping> currentMapping = new Stack<TypeMapping>();
 
-    private final Set<TypeMetadata> processedTypes = new HashSet<TypeMetadata>();
+    private final MappingCreatorContext context;
 
     private TypeMapping entityMapping;
 
+    private final Set<ComplexTypeMetadata> processedTypes = new HashSet<ComplexTypeMetadata>();
+
     public ScatteredMappingCreator(MetadataRepository repository,
                                    MappingRepository mappings,
+                                   MappingCreatorContext context,
                                    boolean shouldCompressLongStrings,
                                    boolean enforceTechnicalFK) {
-        internalRepository = repository;
+        this.internalRepository = repository;
         this.mappings = mappings;
+        this.context = context;
         this.preferClobUse = shouldCompressLongStrings;
         this.enforceTechnicalFK = enforceTechnicalFK;
     }
 
     private TypeMapping handleField(FieldMetadata field) {
-        SimpleTypeFieldMetadata newFlattenField;
-        newFlattenField = new SimpleTypeFieldMetadata(currentType.peek(),
+        String fieldName = getFieldName(field);
+        SimpleTypeFieldMetadata newFlattenField = new SimpleTypeFieldMetadata(currentType.peek(),
                 false,
                 field.isMany(),
                 field.isMandatory(),
-                getFieldName(field),
+                fieldName,
                 field.getType(),
                 field.getWriteUsers(),
                 field.getHideUsers(),
-                field.getWorkflowAccessRights(),
-                getPath(field));
+                field.getWorkflowAccessRights());
         TypeMetadata declaringType = field.getDeclaringType();
-        if (declaringType != field.getContainingType() && declaringType.isInstantiable()) {
-            SoftTypeRef type = new SoftTypeRef(internalRepository,
-                    declaringType.getNamespace(),
-                    declaringType.getName(),
-                    true);
+        if (declaringType != field.getContainingType()) {
+            SoftTypeRef type;
+            if (!declaringType.isInstantiable()) {
+                type = new SoftTypeRef(internalRepository,
+                        declaringType.getNamespace(),
+                        getNonInstantiableTypeName(declaringType.getName()),
+                        false);
+            } else {
+                type = new SoftTypeRef(internalRepository,
+                        declaringType.getNamespace(),
+                        declaringType.getName(),
+                        true);
+            }
             newFlattenField.setDeclaringType(type);
         }
         String data = field.getType().getData(MetadataRepository.DATA_MAX_LENGTH);
@@ -78,24 +91,27 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
         return null;
     }
 
-    private static String getPath(FieldMetadata field) {
-        StringTokenizer tokenizer = new StringTokenizer(field.getPath(), "/");
-        StringBuilder path = new StringBuilder();
-        while (tokenizer.hasMoreTokens()) {
-            path.append(getFieldColumn(tokenizer.nextToken()));
-            if (tokenizer.hasMoreTokens()) {
-                path.append('/');
+    private String getFieldName(FieldMetadata field) {
+        String fieldName = context.getFieldColumn(field);
+        ComplexTypeMetadata containingType = field.getContainingType();
+        if (containingType.getSubTypes().isEmpty() && containingType.getSuperTypes().isEmpty()) {
+            for (int i = 1; !field.isKey() && needUniqueFieldName(fieldName, currentType.peek()); i++) {
+                fieldName += i;
             }
         }
-        return path.toString();
-    }
-
-    private static String getFieldName(FieldMetadata field) {
-        return getFieldColumn(field.getName());
+        return fieldName;
     }
 
-    private static String getFieldColumn(String name) {
-        return "x_" + name.replace('-', '_').toLowerCase(); //$NON-NLS-1$
+    private boolean needUniqueFieldName(String fieldName, ComplexTypeMetadata type) {
+        boolean needUniqueFieldName = type.hasField(fieldName);
+        for (TypeMetadata superType : type.getSuperTypes()) {
+            if (superType instanceof ComplexTypeMetadata) {
+                if (((ComplexTypeMetadata) superType).hasField(fieldName)) {
+                    return true;
+                }
+            }
+        }
+        return needUniqueFieldName;
     }
 
     private static String newNonInstantiableTypeName(ComplexTypeMetadata fieldReferencedType) {
@@ -137,7 +153,7 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                 referenceField.isKey(),
                 referenceField.isMany(),
                 referenceField.isMandatory(),
-                getFieldName(referenceField),
+                context.getFieldColumn(referenceField),
                 referencedType,
                 referencedFieldCopy,
                 Collections.<FieldMetadata>emptyList(),
@@ -146,8 +162,8 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                 new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                 referenceField.getWriteUsers(),
                 referenceField.getHideUsers(),
-                referenceField.getWorkflowAccessRights(),
-                getPath(referenceField));
+                referenceField.getWorkflowAccessRights());
+        newFlattenField.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH); // TODO Not very true...
         database.addField(newFlattenField);
         entityMapping.map(referenceField, newFlattenField);
         currentMapping.peek().map(referenceField, newFlattenField);
@@ -166,7 +182,11 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
     }
 
     private String createContainedType(String typeName, String superTypeName, ComplexTypeMetadata originalContainedType) {
-        ComplexTypeMetadata internalContainedType = (ComplexTypeMetadata) internalRepository.getType(typeName);
+        if(!processedTypes.add(originalContainedType)) {
+            // Prevents re-entry for nested types with recursive references.
+            return typeName;
+        }
+        ComplexTypeMetadata internalContainedType = (ComplexTypeMetadata) internalRepository.getNonInstantiableType(internalRepository.getUserNamespace(), typeName);
         if (internalContainedType == null) {
             internalContainedType = new ComplexTypeMetadataImpl(originalContainedType.getNamespace(),
                     typeName,
@@ -181,8 +201,9 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                     false,
                     originalContainedType.getWorkflowAccessRights());
             internalRepository.addTypeMetadata(internalContainedType);
-            if (superTypeName == null) {  // Generate a technical ID only if contained type does not have super type (subclasses will inherit it).
-                internalContainedType.addField(new SimpleTypeFieldMetadata(internalContainedType,
+            if (superTypeName == null) {
+                // Generate a technical ID only if contained type does not have super type (subclasses will inherit it).
+                SimpleTypeFieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(internalContainedType,
                         true,
                         false,
                         true,
@@ -190,10 +211,15 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                         new SoftTypeRef(internalRepository, internalRepository.getUserNamespace(), Types.UUID, false),
                         originalContainedType.getWriteUsers(),
                         originalContainedType.getHideUsers(),
-                        originalContainedType.getWorkflowAccessRights(),
-                        StringUtils.EMPTY)); // TODO Compute path for generated id.
+                        originalContainedType.getWorkflowAccessRights());
+                internalContainedType.addField(fieldMetadata);
+                fieldMetadata.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
             } else {
-                internalContainedType.addSuperType(new SoftTypeRef(internalRepository, internalContainedType.getNamespace(), superTypeName, false), internalRepository);
+                SoftTypeRef type = new SoftTypeRef(internalRepository,
+                        internalContainedType.getNamespace(),
+                        superTypeName,
+                        false);
+                internalContainedType.addSuperType(type);
             }
             internalRepository.addTypeMetadata(internalContainedType);
         }
@@ -203,7 +229,7 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
             currentMapping.push(mapping);
         } else {
             mapping = new FlatTypeMapping(originalContainedType, internalContainedType, mappings);
-            mappings.addMapping(originalContainedType, mapping);
+            mappings.addMapping(mapping);
         }
         currentMapping.push(mapping);
         currentType.push(internalContainedType);
@@ -226,7 +252,7 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                 false,
                 containedField.isMany(),
                 containedField.isMandatory(),
-                getFieldName(containedField),
+                context.getFieldColumn(containedField),
                 typeRef,
                 new SoftIdFieldRef(internalRepository, containedTypeName),
                 Collections.<FieldMetadata>emptyList(),
@@ -235,16 +261,13 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                 new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                 containedField.getWriteUsers(),
                 containedField.getHideUsers(),
-                containedField.getWorkflowAccessRights(),
-                getPath(containedField));
-        newFlattenField.setData(MappingGenerator.SQL_DELETE_CASCADE, "true"); //$NON-NLS-1$
+                containedField.getWorkflowAccessRights());
+        newFlattenField.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
+        newFlattenField.setData(MappingGenerator.SQL_DELETE_CASCADE, Boolean.TRUE.toString());
         currentType.peek().addField(newFlattenField);
         currentMapping.peek().map(containedField, newFlattenField);
         entityMapping.map(containedField, newFlattenField);
-        if (!processedTypes.contains(containedField.getContainedType())) {
-            processedTypes.add(containedField.getContainedType());
-            containedField.getContainedType().accept(this);
-        }
+        containedField.getType().accept(this);
         return null;
     }
 
@@ -260,6 +283,9 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     @Override
     public TypeMapping visit(ComplexTypeMetadata complexType) {
+        if(!complexType.isInstantiable()) {
+            return null;
+        }
         entityMapping = new ScatteredTypeMapping(complexType, mappings);
         ComplexTypeMetadata database = entityMapping.getDatabase();
         if (!complexType.isInstantiable()) {
@@ -271,9 +297,10 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
         currentType.push(database);
         {
             internalRepository.addTypeMetadata(database);
-            if (complexType.getKeyFields().isEmpty() && complexType.getSuperTypes().isEmpty()) { // Assumes super type will define an id.
+            if (complexType.getKeyFields().isEmpty() && complexType.getSuperTypes().isEmpty()) {
+                // Assumes super type will define an id.
                 SoftTypeRef type = new SoftTypeRef(internalRepository, StringUtils.EMPTY, Types.UUID, false);
-                database.addField(new SimpleTypeFieldMetadata(database,
+                SimpleTypeFieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(database,
                         true,
                         false,
                         true,
@@ -281,8 +308,9 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                         type,
                         Collections.<String>emptyList(),
                         Collections.<String>emptyList(),
-                        Collections.<String>emptyList(),
-                        StringUtils.EMPTY));
+                        Collections.<String>emptyList());
+                database.addField(fieldMetadata);
+                fieldMetadata.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
             }
             for (TypeMetadata superType : complexType.getSuperTypes()) {
                 if (superType.isInstantiable()) {
@@ -290,18 +318,18 @@ class ScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                             superType.getNamespace(),
                             superType.getName().replace('-', '_'),
                             superType.isInstantiable());
-                    database.addSuperType(type, internalRepository);
+                    database.addSuperType(type);
                 } else {
                     SoftTypeRef type = new SoftTypeRef(internalRepository,
                             superType.getNamespace(),
                             getNonInstantiableTypeName(superType.getName()),
                             superType.isInstantiable());
-                    database.addSuperType(type, internalRepository);
+                    database.addSuperType(type);
                 }
             }
             super.visit(complexType);
             for (FieldMetadata keyField : complexType.getKeyFields()) {
-                database.registerKey(database.getField(getFieldColumn(keyField.getName()))); //$NON-NLS-1$
+                database.registerKey(database.getField(context.getFieldColumn(keyField.getName())));
             }
         }
         currentType.pop();
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredTypeMapping.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredTypeMapping.java
index 161b902..5e91ba5 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredTypeMapping.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/ScatteredTypeMapping.java
@@ -16,6 +16,7 @@ import com.amalto.core.storage.record.DataRecord;
 import com.amalto.core.storage.record.metadata.DataRecordMetadata;
 import com.amalto.core.storage.record.metadata.UnsupportedDataRecordMetadata;
 import org.apache.commons.lang.NotImplementedException;
+import org.apache.log4j.Logger;
 import org.hibernate.Session;
 import org.hibernate.collection.PersistentList;
 import org.hibernate.engine.CollectionEntry;
@@ -32,9 +33,11 @@ import java.util.*;
  */
 class ScatteredTypeMapping extends TypeMapping {
 
+    private static final Logger LOGGER = Logger.getLogger(ScatteredTypeMapping.class);
+
     private Map<String, FieldMetadata> userToDatabase = new HashMap<String, FieldMetadata>();
 
-    private Map<String, FieldMetadata> databaseToUser = new HashMap<String, FieldMetadata>();
+    private Map<FieldMetadata, FieldMetadata> databaseToUser = new HashMap<FieldMetadata, FieldMetadata>();
 
     public ScatteredTypeMapping(ComplexTypeMetadata user, MappingRepository mappings) {
         super(user, mappings);
@@ -46,20 +49,8 @@ class ScatteredTypeMapping extends TypeMapping {
 
     Object _setValues(Session session, DataRecord from, Wrapper to) {
         ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
-        TypeMapping mapping = mappings.getMappingFromUser(from.getType());
-        Collection<FieldMetadata> fields;
-        if (mapping != null) {
-            fields = mapping.getUser().getFields();
-        } else {
-            fields = from.getType().getFields();
-        }
-        for (FieldMetadata field : fields) {
-            FieldMetadata mappedDatabaseField;
-            if (mapping != null) {
-                mappedDatabaseField = mapping.getDatabase(field);
-            } else {
-                mappedDatabaseField = getDatabase(field);
-            }
+        for (FieldMetadata field : from.getType().getFields()) {
+            FieldMetadata mappedDatabaseField = getDatabase(field);
             if (mappedDatabaseField == null) {
                 throw new IllegalStateException("Field '" + field.getName() + "' was expected to have a database mapping");
             }
@@ -89,12 +80,7 @@ class ScatteredTypeMapping extends TypeMapping {
                     }
                 } else {
                     List<DataRecord> dataRecords = (List<DataRecord>) readValue(from, field, mappedDatabaseField, session);
-                    Object value;
-                    if (mapping != null) {
-                        value = to.get(mapping.getDatabase(field).getName());
-                    } else {
-                        value = to.get(getDatabase(field).getName());
-                    }
+                    Object value = to.get(getDatabase(field).getName());
                     if (dataRecords != null) {
                         List<Wrapper> existingValue = (List<Wrapper>) value;
                         if (existingValue != null) {
@@ -419,19 +405,28 @@ class ScatteredTypeMapping extends TypeMapping {
     }
 
     protected void map(FieldMetadata user, FieldMetadata database) {
+        ComplexTypeMetadata containingType = database.getContainingType();
+        TypeMetadata declaringType = database.getDeclaringType();
+        if (!containingType.isInstantiable() && !containingType.equals(declaringType)) {
+            return;
+        }
         if (isFrozen) {
             throw new IllegalStateException("Mapping is frozen.");
         }
-        userToDatabase.put(user.getContainingType().getName() + '_' + user.getName(), database);
-        databaseToUser.put(database.getContainingType().getName() + '_' + database.getName(), user);
+        String userFullPath = user.getEntityTypeName() + '/' + user.getPath();
+        if (LOGGER.isDebugEnabled()) {
+            LOGGER.debug("Map '" + userFullPath + "' to '" + database.getEntityTypeName() + '/' + database.getPath());
+        }
+        userToDatabase.put(userFullPath, database);
+        databaseToUser.put(database, user);
     }
 
     public FieldMetadata getDatabase(FieldMetadata from) {
-        return userToDatabase.get(from.getContainingType().getName() + '_' + from.getName());
+        return userToDatabase.get(from.getEntityTypeName() + '/' + from.getPath());
     }
 
     public FieldMetadata getUser(FieldMetadata to) {
-        return databaseToUser.get(to.getContainingType().getName() + '_' + to.getName());
+        return databaseToUser.get(to);
     }
 
     /**
@@ -445,16 +440,16 @@ class ScatteredTypeMapping extends TypeMapping {
             database.freeze();
             user.freeze();
             // Freeze field mappings.
-            Map<String, FieldMetadata> frozen = new HashMap<String, FieldMetadata>();
+            Map<String, FieldMetadata> frozenUser = new HashMap<String, FieldMetadata>();
             for (Map.Entry<String, FieldMetadata> entry : userToDatabase.entrySet()) {
-                frozen.put(entry.getKey(), entry.getValue().freeze());
+                frozenUser.put(entry.getKey(), entry.getValue().freeze());
             }
-            userToDatabase = frozen;
-            frozen = new HashMap<String, FieldMetadata>();
-            for (Map.Entry<String, FieldMetadata> entry : databaseToUser.entrySet()) {
-                frozen.put(entry.getKey(), entry.getValue().freeze());
+            userToDatabase = frozenUser;
+            Map<FieldMetadata, FieldMetadata> frozenDatabase = new HashMap<FieldMetadata, FieldMetadata>();
+            for (Map.Entry<FieldMetadata, FieldMetadata> entry : databaseToUser.entrySet()) {
+                frozenDatabase.put(entry.getKey().freeze(), entry.getValue().freeze());
             }
-            databaseToUser = frozen;
+            databaseToUser = frozenDatabase;
             isFrozen = true;
         }
     }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SelectAnalyzer.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SelectAnalyzer.java
index 4d91d8c..fa85a81 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SelectAnalyzer.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SelectAnalyzer.java
@@ -498,12 +498,7 @@ class SelectAnalyzer extends VisitorAdapter<Visitor<StorageResults>> {
             FieldMetadata fieldMetadata = field.getFieldMetadata();
             // Limit join for contained fields
             if (!result.limitJoins) {
-                int level = 0;
-                ComplexTypeMetadata containingType = fieldMetadata.getContainingType();
-                while (containingType instanceof ContainedComplexTypeMetadata) {
-                    containingType = ((ContainedComplexTypeMetadata) containingType).getContainerType();
-                    level++;
-                }
+                int level = StringUtils.countMatches(fieldMetadata.getPath(), "/"); //$NON-NLS-1$
                 if (level > 2 || !select.getTypes().contains(fieldMetadata.getContainingType())) {
                     result.limitJoins = true;
                 }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StagingTypeMappingRepository.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StagingTypeMappingRepository.java
index 5822cf9..d694307 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StagingTypeMappingRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StagingTypeMappingRepository.java
@@ -11,12 +11,12 @@
 
 package com.amalto.core.storage.hibernate;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.*;
 import com.amalto.core.storage.Storage;
 
 import javax.xml.XMLConstants;
 import java.util.Collections;
+import java.util.UUID;
 
 class StagingTypeMappingRepository extends InternalRepository {
     public StagingTypeMappingRepository(TypeMappingStrategy mappingStrategy) {
@@ -33,20 +33,20 @@ class StagingTypeMappingRepository extends InternalRepository {
             TypeMetadata longType = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.LONG, false);
             TypeMetadata stringType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING);
             TypeMetadata limitedStringType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING);
-            limitedStringType.setData(MetadataRepository.DATA_MAX_LENGTH, 255);
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_STATUS, intType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_SOURCE, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_BLOCK_KEY, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            SimpleTypeFieldMetadata errorField = new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_ERROR, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY);
+            limitedStringType.setData(MetadataRepository.DATA_MAX_LENGTH, UUID.randomUUID().toString().length());
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_STATUS, intType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_SOURCE, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_BLOCK_KEY, limitedStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            SimpleTypeFieldMetadata errorField = new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_STAGING_ERROR, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList());
             errorField.getType().setData(TypeMapping.SQL_TYPE, "text"); //$NON-NLS-1$
             database.addField(errorField);
         }
 
         // Register mapping
         internalRepository.addTypeMetadata(typeMapping.getDatabase());
-        mappings.addMapping(complexType, typeMapping);
+        mappings.addMapping(typeMapping);
         return internalRepository;
     }
 }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StandardQueryHandler.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StandardQueryHandler.java
index e0d4215..abd81a2 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StandardQueryHandler.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StandardQueryHandler.java
@@ -50,7 +50,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
 
     private final StandardQueryHandler.CriterionFieldCondition criterionFieldCondition;
 
-    private final Map<FieldMetadata, String> joinFieldsToAlias = new HashMap<FieldMetadata, String>();
+    private final Map<FieldMetadata, Set<String>> joinFieldsToAlias = new HashMap<FieldMetadata, Set<String>>();
 
     private final MappingRepository mappings;
 
@@ -128,7 +128,6 @@ class StandardQueryHandler extends AbstractQueryHandler {
     @Override
     public StorageResults visit(Join join) {
         FieldMetadata fieldMetadata = join.getRightField().getFieldMetadata();
-
         // Choose the right join type
         String rightTableName = fieldMetadata.getContainingType().getName();
         int joinType;
@@ -164,11 +163,11 @@ class StandardQueryHandler extends AbstractQueryHandler {
                     + mainType.getName() + "' to this field.");
         }
         // Generate all necessary joins to go from main type to join right table.
-        generateJoinPath(rightTableName, joinType, path);
+        generateJoinPath(Collections.singleton(rightTableName), joinType, path);
         return null;
     }
 
-    private void generateJoinPath(String rightTableName, int joinType, List<FieldMetadata> path) {
+    private void generateJoinPath(Set<String> rightTableAliases, int joinType, List<FieldMetadata> path) {
         Iterator<FieldMetadata> pathIterator = path.iterator();
         String previousAlias = mainType.getName();
         while (pathIterator.hasNext()) {
@@ -178,18 +177,25 @@ class StandardQueryHandler extends AbstractQueryHandler {
             if (pathIterator.hasNext()) {
                 if (!joinFieldsToAlias.containsKey(nextField)) {
                     criteria.createAlias(previousAlias + '.' + nextField.getName(), newAlias, joinType);
-                    joinFieldsToAlias.put(nextField, newAlias);
+                    joinFieldsToAlias.put(nextField, new HashSet<String>(Arrays.asList(newAlias)));
                     previousAlias = newAlias;
                 } else {
-                    previousAlias = joinFieldsToAlias.get(nextField);
+                    previousAlias = joinFieldsToAlias.get(nextField).iterator().next();
                 }
             } else {
                 if (!joinFieldsToAlias.containsKey(nextField)) {
-                    criteria.createAlias(previousAlias + '.' + nextField.getName(), rightTableName, joinType);
-                    joinFieldsToAlias.put(nextField, rightTableName);
-                    previousAlias = rightTableName;
+                    for (String rightTableAlias : rightTableAliases) {
+                        criteria.createAlias(previousAlias + '.' + nextField.getName(), rightTableAlias, joinType);
+                        Set<String> aliases = joinFieldsToAlias.get(nextField);
+                        if (aliases == null) {
+                            aliases = new HashSet<String>();
+                            joinFieldsToAlias.put(nextField, aliases);
+                        }
+                        aliases.add(rightTableAlias);
+                    }
+                    previousAlias = rightTableAliases.iterator().next();
                 } else {
-                    previousAlias = joinFieldsToAlias.get(nextField);
+                    previousAlias = joinFieldsToAlias.get(nextField).iterator().next();
                 }
             }
         }
@@ -292,7 +298,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
     public StorageResults visit(final Field field) {
         final FieldMetadata userFieldMetadata = field.getFieldMetadata();
         ComplexTypeMetadata containingType = getContainingType(userFieldMetadata);
-        final String alias = getAlias(containingType, userFieldMetadata);
+        final Set<String> aliases = getAliases(containingType, field);
         userFieldMetadata.accept(new DefaultMetadataVisitor<Void>() {
 
             @Override
@@ -307,9 +313,11 @@ class StandardQueryHandler extends AbstractQueryHandler {
             @Override
             public Void visit(SimpleTypeFieldMetadata simpleField) {
                 if (!simpleField.isMany()) {
-                    projectionList.add(Projections.property(alias + '.' + simpleField.getName()));
+                    for (String alias : aliases) {
+                        projectionList.add(Projections.property(alias + '.' + simpleField.getName()));
+                    }
                 } else {
-                    projectionList.add(new ManyFieldProjection(alias,
+                    projectionList.add(new ManyFieldProjection(aliases,
                             simpleField,
                             resolver,
                             (RDBMSDataSource) storage.getDataSource()));
@@ -320,9 +328,11 @@ class StandardQueryHandler extends AbstractQueryHandler {
             @Override
             public Void visit(EnumerationFieldMetadata enumField) {
                 if (!enumField.isMany()) {
-                    projectionList.add(Projections.property(alias + '.' + enumField.getName()));
+                    for (String alias : aliases) {
+                        projectionList.add(Projections.property(alias + '.' + enumField.getName()));
+                    }
                 } else {
-                    projectionList.add(new ManyFieldProjection(alias,
+                    projectionList.add(new ManyFieldProjection(aliases,
                             enumField,
                             resolver,
                             (RDBMSDataSource) storage.getDataSource()));
@@ -341,28 +351,66 @@ class StandardQueryHandler extends AbstractQueryHandler {
         return containingType;
     }
 
-    private String getAlias(ComplexTypeMetadata type, FieldMetadata databaseField) {
+    /**
+     * <p>
+     * Generate an alias to the <code>field</code> starting from <code>type</code>. This code ensures all paths
+     * to <code>field</code> are covered (this field might be present several times inside the MDM entity
+     * scope).
+     * </p>
+     *
+     * @param type          A type in the query.
+     * @param field A field to include in current Hibernate criteria.
+     * @return A set of aliases that represents the <code>field</code>.
+     */
+    private Set<String> getAliases(ComplexTypeMetadata type, Field field) {
+        if (joinFieldsToAlias.containsKey(field.getFieldMetadata())) {
+            return joinFieldsToAlias.get(field.getFieldMetadata());
+        }
+        FieldMetadata fieldMetadata = field.getFieldMetadata();
         String previousAlias = type.getName();
-        String alias;
-        for (FieldMetadata next : MetadataUtils.path(type, databaseField, false)) {
-            if (next instanceof ReferenceFieldMetadata) {
-                alias = joinFieldsToAlias.get(next);
-                if (alias == null) {
-                    alias = "a" + aliasCount++; //$NON-NLS-1$
-                    joinFieldsToAlias.put(next, alias);
-                    int joinType;
-                    // TMDM-4866: Do a left join in case FK is not mandatory.
-                    if (next.isMandatory()) {
-                        joinType = CriteriaSpecification.INNER_JOIN;
+        String alias = null;
+        Set<List<FieldMetadata>> paths ;
+        if (fieldMetadata instanceof ReferenceFieldMetadata && !fieldMetadata.getContainingType().isInstantiable()) {
+            paths = MetadataUtils.paths(type, fieldMetadata);
+        } else {
+            paths = Collections.singleton(field.getPath());
+        }
+        Set<String> aliases = new HashSet<String>(paths.size());
+        for (List<FieldMetadata> path : paths) {
+            boolean newPath = false;
+            for (FieldMetadata next : path) {
+                if (next instanceof ReferenceFieldMetadata) {
+                    aliases = joinFieldsToAlias.get(next);
+                    if (aliases == null || newPath) {
+                        alias = "a" + aliasCount++; //$NON-NLS-1$
+                        if (aliases == null) {
+                            aliases = new HashSet<String>(Arrays.asList(alias));
+                            joinFieldsToAlias.put(next, aliases);
+                        } else {
+                            aliases.add(alias);
+                        }
+                        int joinType;
+                        // TMDM-4866: Do a left join in case FK is not mandatory (only if there's one path).
+                        if (next.isMandatory() && paths.size() == 1) {
+                            joinType = CriteriaSpecification.INNER_JOIN;
+                        } else {
+                            joinType = CriteriaSpecification.LEFT_JOIN;
+                        }
+                        criteria.createAlias(previousAlias + '.' + next.getName(), alias, joinType);
+                        newPath = true;
+                    }
+                    if (alias != null) {
+                        previousAlias = alias;
                     } else {
-                        joinType = CriteriaSpecification.LEFT_JOIN;
+                        previousAlias = aliases.iterator().next();
                     }
-                    criteria.createAlias(previousAlias + '.' + next.getName(), alias, joinType);
                 }
-                previousAlias = alias;
             }
+            aliases.add(previousAlias);
+            previousAlias = type.getName();
+            alias = null;
         }
-        return previousAlias;
+        return aliases;
     }
 
     @Override
@@ -468,22 +516,25 @@ class StandardQueryHandler extends AbstractQueryHandler {
             Field field = (Field) orderByExpression;
             FieldMetadata userFieldMetadata = field.getFieldMetadata();
             ComplexTypeMetadata containingType = getContainingType(userFieldMetadata);
-            String alias = getAlias(containingType, userFieldMetadata);
-            condition.criterionFieldName = alias + '.' + userFieldMetadata.getName();
+            Set<String> aliases = getAliases(containingType, field);
+            condition.criterionFieldNames = new ArrayList<String>(aliases.size());
+            for (String alias : aliases) {
+                condition.criterionFieldNames.add(alias + '.' + userFieldMetadata.getName());
+            }
         }
         if (condition != null) {
-            String fieldName = condition.criterionFieldName;
-            OrderBy.Direction direction = orderBy.getDirection();
-            switch (direction) {
-            case ASC:
-                criteria.addOrder(Order.asc(fieldName));
-                break;
-            case DESC:
-                criteria.addOrder(Order.desc(fieldName));
-                break;
+            for (String fieldName : condition.criterionFieldNames) {
+                OrderBy.Direction direction = orderBy.getDirection();
+                switch (direction) {
+                    case ASC:
+                        criteria.addOrder(Order.asc(fieldName));
+                        break;
+                    case DESC:
+                        criteria.addOrder(Order.desc(fieldName));
+                        break;
+                }
             }
         }
-
         return null;
     }
 
@@ -515,7 +566,9 @@ class StandardQueryHandler extends AbstractQueryHandler {
     @Override
     public StorageResults visit(Max max) {
         FieldCondition fieldCondition = max.getExpression().accept(criterionFieldCondition);
-        projectionList.add(Projections.max(fieldCondition.criterionFieldName));
+        for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+            projectionList.add(Projections.max(criterionFieldName));
+        }
         return null;
     }
 
@@ -592,7 +645,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
             if (fieldCondition == null) {
                 return NO_OP_CRITERION;
             }
-            if (fieldCondition.criterionFieldName.isEmpty()) {
+            if (fieldCondition.criterionFieldNames.isEmpty()) {
                 // Case #1: doing a simple instance type check on main selected type.
                 return Restrictions.eq("class", storageClassLoader.getClassFromType(isa.getType())); //$NON-NLS-1$
             } else {
@@ -605,10 +658,10 @@ class StandardQueryHandler extends AbstractQueryHandler {
                             + mainType.getName() + "'.");
                 }
                 // Generate the joins
-                String alias = getAlias(mainType, fieldCondition.fieldMetadata);
-                generateJoinPath(alias, JoinFragment.INNER_JOIN, path);
+                Set<String> aliases = getAliases(mainType, fieldCondition.field);
+                generateJoinPath(aliases, JoinFragment.INNER_JOIN, path);
                 // Find the criteria that does the join to the table to check (only way to get the SQL alias for table).
-                Criteria foundSubCriteria = findCriteria(criteria, alias);
+                Criteria foundSubCriteria = findCriteria(criteria, aliases);
                 String name = storageClassLoader.getClassFromType(isa.getType()).getName();
                 return new FieldTypeCriterion(foundSubCriteria, name);
             }
@@ -621,9 +674,22 @@ class StandardQueryHandler extends AbstractQueryHandler {
                 return NO_OP_CRITERION;
             }
             if (fieldCondition.isMany) {
-                throw new UnsupportedOperationException("Does not support isNull operation on collections.");
+                throw new UnsupportedOperationException("Does not support 'is null' operation on collections.");
+            }
+            if (fieldCondition.criterionFieldNames.isEmpty()) {
+                throw new IllegalStateException("No field name for 'is null' condition on " + isNull.getField());
+            } else {
+                // Criterion affect multiple fields
+                Criterion current = null;
+                for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                    if (current == null) {
+                        current = Restrictions.isNull(criterionFieldName);
+                    } else {
+                        current = Restrictions.and(current, Restrictions.isNull(criterionFieldName));
+                    }
+                }
+                return current;
             }
-            return Restrictions.isNull(fieldCondition.criterionFieldName);
         }
 
         @Override
@@ -633,9 +699,35 @@ class StandardQueryHandler extends AbstractQueryHandler {
                 return NO_OP_CRITERION;
             }
             if (fieldCondition.isMany) {
-                return Restrictions.isEmpty(fieldCondition.criterionFieldName);
+                if (fieldCondition.criterionFieldNames.isEmpty()) {
+                    throw new IllegalStateException("No field name for 'is empty' condition on " + isEmpty.getField());
+                } else {
+                    // Criterion affect multiple fields
+                    Criterion current = null;
+                    for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                        if (current == null) {
+                            current = Restrictions.isEmpty(criterionFieldName);
+                        } else {
+                            current = Restrictions.and(current, Restrictions.isEmpty(criterionFieldName));
+                        }
+                    }
+                    return current;
+                }
             } else {
-                return Restrictions.eq(fieldCondition.criterionFieldName, StringUtils.EMPTY);
+                if (fieldCondition.criterionFieldNames.isEmpty()) {
+                    throw new IllegalStateException("No field name for 'is empty' condition on " + isEmpty.getField());
+                } else {
+                    // Criterion affect multiple fields
+                    Criterion current = null;
+                    for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                        if (current == null) {
+                            current = Restrictions.eq(criterionFieldName, StringUtils.EMPTY);
+                        } else {
+                            current = Restrictions.and(current, Restrictions.eq(criterionFieldName, StringUtils.EMPTY));
+                        }
+                    }
+                    return current;
+                }
             }
         }
 
@@ -646,9 +738,35 @@ class StandardQueryHandler extends AbstractQueryHandler {
                 return NO_OP_CRITERION;
             }
             if (fieldCondition.isMany) {
-                return Restrictions.isNotEmpty(fieldCondition.criterionFieldName);
+                if (fieldCondition.criterionFieldNames.isEmpty()) {
+                    throw new IllegalStateException("No field name for 'not is empty' condition on " + notIsEmpty.getField());
+                } else {
+                    // Criterion affect multiple fields
+                    Criterion current = null;
+                    for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                        if (current == null) {
+                            current = Restrictions.isNotEmpty(criterionFieldName);
+                        } else {
+                            current = Restrictions.and(current, Restrictions.isNotEmpty(criterionFieldName));
+                        }
+                    }
+                    return current;
+                }
             } else {
-                return Restrictions.not(Restrictions.eq(fieldCondition.criterionFieldName, StringUtils.EMPTY));
+                if (fieldCondition.criterionFieldNames.isEmpty()) {
+                    throw new IllegalStateException("No field name for 'not is empty' condition on " + notIsEmpty.getField());
+                } else {
+                    // Criterion affect multiple fields
+                    Criterion current = null;
+                    for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                        if (current == null) {
+                            current = Restrictions.not(Restrictions.eq(criterionFieldName, StringUtils.EMPTY));
+                        } else {
+                            current = Restrictions.and(current, Restrictions.not(Restrictions.eq(criterionFieldName, StringUtils.EMPTY)));
+                        }
+                    }
+                    return current;
+                }
             }
         }
 
@@ -664,9 +782,22 @@ class StandardQueryHandler extends AbstractQueryHandler {
                 return NO_OP_CRITERION;
             }
             if (fieldCondition.isMany) {
-                throw new UnsupportedOperationException("Does not support notIsNull operation on collections.");
+                throw new UnsupportedOperationException("Does not support 'not is null' operation on collections.");
+            }
+            if (fieldCondition.criterionFieldNames.isEmpty()) {
+                throw new IllegalStateException("No field name for 'not is null' condition on " + notIsNull.getField());
+            } else {
+                // Criterion affect multiple fields
+                Criterion current = null;
+                for (String criterionFieldName : fieldCondition.criterionFieldNames) {
+                    if (current == null) {
+                        current = Restrictions.isNotNull(criterionFieldName);
+                    } else {
+                        current = Restrictions.and(current, Restrictions.isNotNull(criterionFieldName));
+                    }
+                }
+                return current;
             }
-            return Restrictions.isNotNull(fieldCondition.criterionFieldName);
         }
 
         @Override
@@ -701,7 +832,20 @@ class StandardQueryHandler extends AbstractQueryHandler {
                 end = MetadataUtils.convert(endValue, expression.getTypeName());
             }
             if (condition != null) {
-                return Restrictions.between(condition.criterionFieldName, start, end);
+                if (condition.criterionFieldNames.isEmpty()) {
+                    throw new IllegalStateException("No field name for 'range' condition on " + range.getExpression());
+                } else {
+                    // Criterion affect multiple fields
+                    Criterion current = null;
+                    for (String criterionFieldName : condition.criterionFieldNames) {
+                        if (current == null) {
+                            current = Restrictions.between(criterionFieldName, start, end);
+                        } else {
+                            current = Restrictions.and(current, Restrictions.between(criterionFieldName, start, end));
+                        }
+                    }
+                    return current;
+                }
             } else {
                 return null;
             }
@@ -748,33 +892,36 @@ class StandardQueryHandler extends AbstractQueryHandler {
             if (condition.getLeft() instanceof Field) {
                 Field leftField = (Field) condition.getLeft();
                 FieldMetadata fieldMetadata = leftField.getFieldMetadata();
-                String alias = fieldMetadata.getContainingType().getName();
+                Set<String> aliases = Collections.singleton(fieldMetadata.getContainingType().getName());
                 // TODO Ugly code path to fix once test coverage is ok.
                 if (!mainType.equals(fieldMetadata.getContainingType()) || fieldMetadata instanceof ReferenceFieldMetadata) {
-                    (new Field(fieldMetadata)).accept(StandardQueryHandler.this);
-                    alias = getAlias(mainType, fieldMetadata);
+                    leftField.accept(StandardQueryHandler.this);
+                    aliases = getAliases(mainType, leftField);
                     if (!fieldMetadata.isMany()) {
-                        if (fieldMetadata instanceof ReferenceFieldMetadata) {
-                            // ignored CompoundFieldMetadata
-                            if (!(((ReferenceFieldMetadata) fieldMetadata).getReferencedField() instanceof CompoundFieldMetadata)) {
-                                leftFieldCondition.criterionFieldName = alias + '.'
-                                        + ((ReferenceFieldMetadata) fieldMetadata).getReferencedField().getName();
+                        leftFieldCondition.criterionFieldNames.clear();
+                        for (String alias : aliases) {
+                            if (fieldMetadata instanceof ReferenceFieldMetadata) {
+                                // ignored CompoundFieldMetadata
+                                if (!(((ReferenceFieldMetadata) fieldMetadata).getReferencedField() instanceof CompoundFieldMetadata)) {
+                                    leftFieldCondition.criterionFieldNames.add(alias + '.'
+                                            + ((ReferenceFieldMetadata) fieldMetadata).getReferencedField().getName());
+                                }
+                            } else {
+                                leftFieldCondition.criterionFieldNames.add(alias + '.' + fieldMetadata.getName());
                             }
-                        } else {
-                            leftFieldCondition.criterionFieldName = alias + '.' + fieldMetadata.getName();
                         }
                     }
                 }
                 if (leftFieldCondition.isMany || rightFieldCondition.isMany) {
                     // This is what could be done with Hibernate 4 for searches that includes conditions on collections:
-                    // criteria = criteria.createCriteria(leftFieldCondition.criterionFieldName);
+                    // criteria = criteria.createCriteria(leftFieldCondition.criterionFieldNames);
                     // This is what is done on Hibernate 3.5.6
                     if (criteria instanceof CriteriaImpl) {
                         Iterator iterator = ((CriteriaImpl) criteria).iterateSubcriteria();
                         Criteria typeCheckCriteria = criteria;
                         while (iterator.hasNext()) {
                             Criteria subCriteria = (Criteria) iterator.next();
-                            if (alias.equals(subCriteria.getAlias())) {
+                            if (aliases.contains(subCriteria.getAlias())) {
                                 typeCheckCriteria = subCriteria;
                                 break;
                             }
@@ -804,8 +951,17 @@ class StandardQueryHandler extends AbstractQueryHandler {
                     if (!(Boolean) compareValue) {
                         // Special case for boolean: when looking for 'false' value, consider null values as 'false'
                         // too.
-                        return or(eq(leftFieldCondition.criterionFieldName, compareValue),
-                                isNull(leftFieldCondition.criterionFieldName));
+                        Criterion current = null;
+                        for (String criterionFieldName : leftFieldCondition.criterionFieldNames) {
+                            if (current == null) {
+                                current = or(eq(criterionFieldName, compareValue),
+                                        isNull(criterionFieldName));
+                            } else {
+                                current = or(current, or(eq(criterionFieldName, compareValue),
+                                        isNull(criterionFieldName)));
+                            }
+                        }
+                        return current;
                     }
                 }
                 if (predicate == Predicate.EQUALS) {
@@ -816,19 +972,37 @@ class StandardQueryHandler extends AbstractQueryHandler {
                         if (!(referencedField instanceof CompoundFieldMetadata)) {
                             throw new IllegalArgumentException("Expected field '" + referencedField + "' to be a composite key.");
                         }
-                        String alias = getAlias(fieldMetadata.getContainingType(), fieldMetadata);
-                        FieldMetadata[] fields = ((CompoundFieldMetadata) referencedField).getFields();
-                        Object[] keyValues = (Object[]) compareValue;
-                        Criterion[] keyValueCriteria = new Criterion[keyValues.length];
-                        int i = 0;
-                        for (FieldMetadata keyField : fields) {
-                            Object keyValue = MetadataUtils.convert(String.valueOf(keyValues[i]), keyField);
-                            keyValueCriteria[i] = eq(alias + "." + keyField.getName(), keyValue); //$NON-NLS-1$
-                            i++;
+                        Set<String> aliases = getAliases(mainType, leftField);
+                        Criterion current = null;
+                        for (String alias : aliases) {
+                            FieldMetadata[] fields = ((CompoundFieldMetadata) referencedField).getFields();
+                            Object[] keyValues = (Object[]) compareValue;
+                            Criterion[] keyValueCriteria = new Criterion[keyValues.length];
+                            int i = 0;
+                            for (FieldMetadata keyField : fields) {
+                                Object keyValue = MetadataUtils.convert(String.valueOf(keyValues[i]), keyField);
+                                keyValueCriteria[i] = eq(alias + '.' + keyField.getName(), keyValue);
+                                i++;
+                            }
+                            Criterion newCriterion = makeAnd(keyValueCriteria);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
                         }
-                        return makeAnd(keyValueCriteria);
+                        return current;
                     } else {
-                        return eq(leftFieldCondition.criterionFieldName, compareValue);
+                        Criterion current = null;
+                        for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                            Criterion newCriterion = eq(fieldName, compareValue);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
+                        }
+                        return current;
                     }
                 } else if (predicate == Predicate.CONTAINS) {
                     String value = String.valueOf(compareValue);
@@ -843,45 +1017,168 @@ class StandardQueryHandler extends AbstractQueryHandler {
                         value = "%"; //$NON-NLS-1$
                     }
                     if (datasource.isCaseSensitiveSearch()) {
-                        return like(leftFieldCondition.criterionFieldName, value);
+                        Criterion current = null;
+                        for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                            Criterion newCriterion = like(fieldName, value);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
+                        }
+                        return current;
                     } else {
-                        return ilike(leftFieldCondition.criterionFieldName, value, MatchMode.ANYWHERE);
+                        Criterion current = null;
+                        for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                            Criterion newCriterion = ilike(fieldName, value, MatchMode.ANYWHERE);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
+                        }
+                        return current;
                     }
                 } else if (predicate == Predicate.STARTS_WITH) {
                     String value = compareValue + "%";
                     if (datasource.isCaseSensitiveSearch()) {
-                        return like(leftFieldCondition.criterionFieldName, value);
+                        Criterion current = null;
+                        for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                            Criterion newCriterion = like(fieldName, value);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
+                        }
+                        return current;
                     } else {
-                        return ilike(leftFieldCondition.criterionFieldName, String.valueOf(value), MatchMode.START);
+                        Criterion current = null;
+                        for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                            Criterion newCriterion = ilike(fieldName, value, MatchMode.START);
+                            if (current == null) {
+                                current = newCriterion;
+                            } else {
+                                current = or(newCriterion, current);
+                            }
+                        }
+                        return current;
                     }
                 } else if (predicate == Predicate.GREATER_THAN) {
-                    return gt(leftFieldCondition.criterionFieldName, compareValue);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = gt(fieldName, compareValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.LOWER_THAN) {
-                    return lt(leftFieldCondition.criterionFieldName, compareValue);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = lt(fieldName, compareValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.GREATER_THAN_OR_EQUALS) {
-                    return ge(leftFieldCondition.criterionFieldName, compareValue);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = ge(fieldName, compareValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.LOWER_THAN_OR_EQUALS) {
-                    return le(leftFieldCondition.criterionFieldName, compareValue);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = le(fieldName, compareValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else {
                     throw new NotImplementedException("No support for predicate '" + predicate.getClass() + "'");
                 }
             } else { // Since we expect left part to be a field, this 'else' means we're comparing 2 fields
+                if (rightFieldCondition.criterionFieldNames.size() > 1) {
+                    throw new UnsupportedOperationException("Can't compare to multiple right fields (was " + rightFieldCondition.criterionFieldNames.size() + ").");
+                }
+                String rightValue = rightFieldCondition.criterionFieldNames.get(0);
                 if (predicate == Predicate.EQUALS) {
-                    return Restrictions.eqProperty(leftFieldCondition.criterionFieldName, rightFieldCondition.criterionFieldName);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = Restrictions.eqProperty(fieldName, rightValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.GREATER_THAN) {
-                    return Restrictions.gtProperty(leftFieldCondition.criterionFieldName, rightFieldCondition.criterionFieldName);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = Restrictions.gtProperty(fieldName, rightValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.LOWER_THAN) {
-                    return Restrictions.ltProperty(leftFieldCondition.criterionFieldName, rightFieldCondition.criterionFieldName);
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = Restrictions.ltProperty(fieldName, rightValue);
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.GREATER_THAN_OR_EQUALS) {
                     // No GTE for properties, do it "manually"
-                    return or(Restrictions.gtProperty(leftFieldCondition.criterionFieldName,
-                            rightFieldCondition.criterionFieldName), Restrictions.eqProperty(
-                            leftFieldCondition.criterionFieldName, rightFieldCondition.criterionFieldName));
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = or(
+                                Restrictions.gtProperty(fieldName, rightValue),
+                                Restrictions.eqProperty(fieldName, rightValue)
+                        );
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else if (predicate == Predicate.LOWER_THAN_OR_EQUALS) {
                     // No LTE for properties, do it "manually"
-                    return or(Restrictions.ltProperty(leftFieldCondition.criterionFieldName,
-                            rightFieldCondition.criterionFieldName), Restrictions.eqProperty(
-                            leftFieldCondition.criterionFieldName, rightFieldCondition.criterionFieldName));
+                    Criterion current = null;
+                    for (String fieldName : leftFieldCondition.criterionFieldNames) {
+                        Criterion newCriterion = or(
+                                Restrictions.ltProperty(fieldName, rightValue),
+                                Restrictions.eqProperty(fieldName, rightValue)
+                        );
+                        if (current == null) {
+                            current = newCriterion;
+                        } else {
+                            current = or(newCriterion, current);
+                        }
+                    }
+                    return current;
                 } else {
                     throw new NotImplementedException("No support for predicate '" + predicate.getClass() + "'");
                 }
@@ -889,8 +1186,8 @@ class StandardQueryHandler extends AbstractQueryHandler {
         }
     }
 
-    public static Criteria findCriteria(Criteria mainCriteria, String alias) {
-        if (alias.equals(mainCriteria.getAlias())) {
+    public static Criteria findCriteria(Criteria mainCriteria, Set<String> aliases) {
+        if (aliases.contains(mainCriteria.getAlias())) {
             return mainCriteria;
         }
         if (mainCriteria instanceof CriteriaImpl) {
@@ -898,7 +1195,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
             Iterator iterator = ((CriteriaImpl) mainCriteria).iterateSubcriteria();
             while (iterator.hasNext()) {
                 Criteria subCriteria = (Criteria) iterator.next();
-                if (alias.equals(subCriteria.getAlias())) {
+                if (aliases.contains(subCriteria.getAlias())) {
                     foundSubCriteria = subCriteria;
                     break;
                 }
@@ -927,7 +1224,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
 
         private FieldCondition createInternalCondition(String fieldName) {
             FieldCondition condition = new FieldCondition();
-            condition.criterionFieldName = fieldName;
+            condition.criterionFieldNames.add(fieldName);
             condition.isMany = false;
             condition.isProperty = true;
             return condition;
@@ -937,7 +1234,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
             FieldCondition condition = new FieldCondition();
             condition.isProperty = false;
             condition.isMany = false;
-            condition.criterionFieldName = StringUtils.EMPTY;
+            condition.criterionFieldNames.clear();
             return condition;
         }
 
@@ -1008,10 +1305,11 @@ class StandardQueryHandler extends AbstractQueryHandler {
             FieldCondition condition = new FieldCondition();
             condition.isMany = field.getFieldMetadata().isMany();
             // Use line below to allow searches on collection fields (but Hibernate 4 should be used).
-            // condition.criterionFieldName = field.getFieldMetadata().isMany() ? "elements" : getFieldName(field,
+            // condition.criterionFieldNames = field.getFieldMetadata().isMany() ? "elements" : getFieldName(field,
             // StandardQueryHandler.this.mappingMetadataRepository);
-            condition.criterionFieldName = getFieldName(field);
+            condition.criterionFieldNames.add(getFieldName(field));
             condition.fieldMetadata = field.getFieldMetadata();
+            condition.field = field;
             condition.isProperty = true;
             return condition;
         }
@@ -1021,9 +1319,9 @@ class StandardQueryHandler extends AbstractQueryHandler {
             FieldCondition condition = new FieldCondition();
             condition.isMany = indexedField.getFieldMetadata().isMany();
             // Use line below to allow searches on collection fields (but Hibernate 4 should be used).
-            // condition.criterionFieldName = field.getFieldMetadata().isMany() ? "elements" : getFieldName(field,
+            // condition.criterionFieldNames = field.getFieldMetadata().isMany() ? "elements" : getFieldName(field,
             // StandardQueryHandler.this.mappingMetadataRepository);
-            condition.criterionFieldName = getFieldName(indexedField);
+            condition.criterionFieldNames.add(getFieldName(indexedField));
             condition.isProperty = true;
             condition.position = indexedField.getPosition();
             return condition;
@@ -1097,7 +1395,7 @@ class StandardQueryHandler extends AbstractQueryHandler {
         @Override
         public FieldCondition visit(ComplexTypeExpression expression) {
             FieldCondition fieldCondition = new FieldCondition();
-            fieldCondition.criterionFieldName = StringUtils.EMPTY;
+            fieldCondition.criterionFieldNames.clear();
             fieldCondition.isMany = false;
             fieldCondition.isProperty = true;
             return fieldCondition;
@@ -1108,7 +1406,10 @@ class StandardQueryHandler extends AbstractQueryHandler {
             FieldCondition fieldCondition = new FieldCondition();
             Field field = type.getField();
             FieldMetadata fieldMetadata = field.getFieldMetadata();
-            fieldCondition.criterionFieldName = getAlias(fieldMetadata.getContainingType(), fieldMetadata) + ".class"; //$NON-NLS-1$
+            Set<String> aliases = getAliases(fieldMetadata.getContainingType(), field);
+            for (String alias : aliases) {
+                fieldCondition.criterionFieldNames.add(alias + ".class"); //$NON-NLS-1$
+            }
             fieldCondition.isMany = false;
             fieldCondition.isProperty = true;
             return fieldCondition;
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatefulContext.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatefulContext.java
new file mode 100644
index 0000000..dcbf9f8
--- /dev/null
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatefulContext.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2006-2013 Talend Inc. - www.talend.com
+ *
+ * This source code is available under agreement available at
+ * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
+ *
+ * You should have received a copy of the agreement
+ * along with this program; if not, write to Talend SA
+ * 9 rue Pages 92150 Suresnes, France
+ */
+
+package com.amalto.core.storage.hibernate;
+
+import com.amalto.core.metadata.MetadataUtils;
+import org.talend.mdm.commmon.metadata.*;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class StatefulContext implements MappingCreatorContext {
+
+    private final Map<FieldMetadata, String> enforcedUniqueNames = new HashMap<FieldMetadata, String>();
+
+    private final AtomicInteger uniqueInheritanceCounter = new AtomicInteger();
+
+    public String getFieldColumn(FieldMetadata field) {
+        if (!field.getContainingType().getSuperTypes().isEmpty() && !field.getContainingType().isInstantiable()) {
+            boolean isUnique = isUniqueWithinTypeHierarchy(field.getContainingType(), field.getName());
+            if (field.getDeclaringType() == field.getContainingType() && !isUnique) {
+                // Non instantiable types are mapped using a "table per hierarchy" strategy, if field name isn't unique
+                // make sure name becomes unique to avoid conflict (Hibernate doesn't issue warning/errors in case of
+                // overlap).
+                synchronized (enforcedUniqueNames) {
+                    String enforcedUniqueName = enforcedUniqueNames.get(field);
+                    if (enforcedUniqueName == null) {
+                        enforcedUniqueName = getFieldColumn(field.getName()) + uniqueInheritanceCounter.incrementAndGet();
+                        enforcedUniqueNames.put(field, enforcedUniqueName);
+                    }
+                    return enforcedUniqueName;
+                }
+            } else {
+                return getFieldColumn(field.getName());
+            }
+        } else {
+            return getFieldColumn(field.getName());
+        }
+    }
+
+    /**
+     * Controls whether a field name is unique within type hierarchy accessible from <code>type</code> (i.e. go to the
+     * top level type and recursively checks for field with name <code>name</code>).
+     *
+     * @param type A type part of an inheritance hierarchy
+     * @param name A field name.
+     * @return <code>true</code> if there's no other field named <code>name</code> in the type hierarchy accessible from
+     * <code>type</code>.
+     */
+    private static boolean isUniqueWithinTypeHierarchy(ComplexTypeMetadata type, final String name) {
+        ComplexTypeMetadata topLevelType = (ComplexTypeMetadata) MetadataUtils.getSuperConcreteType(type);
+        int occurrenceCount = topLevelType.accept(new DefaultMetadataVisitor<Integer>() {
+
+            int count = 0;
+
+            private void handleField(FieldMetadata simpleField) {
+                if (name.equals(simpleField.getName())) {
+                    count++;
+                }
+            }
+
+            @Override
+            public Integer visit(FieldMetadata fieldMetadata) {
+                handleField(fieldMetadata);
+                return count;
+            }
+
+            @Override
+            public Integer visit(ContainedTypeFieldMetadata containedField) {
+                handleField(containedField);
+                return count;
+            }
+
+            @Override
+            public Integer visit(ReferenceFieldMetadata referenceField) {
+                handleField(referenceField);
+                return count;
+            }
+
+            @Override
+            public Integer visit(SimpleTypeFieldMetadata simpleField) {
+                handleField(simpleField);
+                return count;
+            }
+
+            @Override
+            public Integer visit(EnumerationFieldMetadata enumField) {
+                handleField(enumField);
+                return count;
+            }
+
+            @Override
+            public Integer visit(ComplexTypeMetadata complexType) {
+                super.visit(complexType);
+                for (ComplexTypeMetadata subType : complexType.getSubTypes()) {
+                    subType.accept(this);
+                }
+                return count;
+            }
+        });
+        return occurrenceCount <= 1;
+    }
+
+    public String getFieldColumn(String name) {
+        return "x_" + name.replace('-', '_').toLowerCase(); //$NON-NLS-1$
+    }
+}
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatelessContext.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatelessContext.java
new file mode 100644
index 0000000..32b4f9d
--- /dev/null
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/StatelessContext.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2006-2013 Talend Inc. - www.talend.com
+ *
+ * This source code is available under agreement available at
+ * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
+ *
+ * You should have received a copy of the agreement
+ * along with this program; if not, write to Talend SA
+ * 9 rue Pages 92150 Suresnes, France
+ */
+
+package com.amalto.core.storage.hibernate;
+
+import org.talend.mdm.commmon.metadata.FieldMetadata;
+
+import java.util.List;
+
+public class StatelessContext implements MappingCreatorContext {
+
+    private final List<String> prefixes;
+
+    public StatelessContext(List<String> prefixes) {
+        this.prefixes = prefixes;
+    }
+
+    @Override
+    public String getFieldColumn(FieldMetadata field) {
+        StringBuilder buffer = new StringBuilder();
+        for (String currentPrefix : prefixes) {
+            buffer.append(currentPrefix).append('_');
+        }
+        String name = field.getName();
+        // Note #1: Hibernate (starting from 4.0) internally sets a lower case letter as first letter if field starts with a
+        // upper case character. To prevent any error due to missing field, lower case the field name.
+        // Note #2: Prefix everything with "x_" so there won't be any conflict with database internal type names.
+        // Note #3: Having '-' character is bad for Java code generation, so replace it with '_'.
+        return "x_" + (buffer.toString().replace('-', '_') + name.replace('-', '_')).toLowerCase(); //$NON-NLS-1$
+    }
+
+    @Override
+    public String getFieldColumn(String fieldName) {
+        return "x_" + fieldName.replace('-', '_').toLowerCase(); //$NON-NLS-1$
+    }
+}
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredMappingCreator.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredMappingCreator.java
new file mode 100644
index 0000000..d6feacf
--- /dev/null
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredMappingCreator.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2006-2012 Talend Inc. - www.talend.com
+ *
+ * This source code is available under agreement available at
+ * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
+ *
+ * You should have received a copy of the agreement
+ * along with this program; if not, write to Talend SA
+ * 9 rue Pages 92150 Suresnes, France
+ */
+
+package com.amalto.core.storage.hibernate;
+
+import org.talend.mdm.commmon.metadata.*;
+import org.apache.commons.lang.StringUtils;
+
+import javax.xml.XMLConstants;
+import java.util.*;
+
+class SystemScatteredMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
+
+    public static final String GENERATED_ID = "x_talend_id"; //$NON-NLS-1$
+
+    protected static final int UUID_LENGTH = UUID.randomUUID().toString().length() + 10;
+
+    private final MetadataRepository internalRepository;
+
+    private final MappingRepository mappings;
+
+    private final boolean preferClobUse;
+
+    private final boolean enforceTechnicalFK;
+
+    private final Stack<ComplexTypeMetadata> currentType = new Stack<ComplexTypeMetadata>();
+
+    private final Stack<TypeMapping> currentMapping = new Stack<TypeMapping>();
+
+    private final Set<TypeMetadata> processedTypes = new HashSet<TypeMetadata>();
+
+    private final MappingCreatorContext context;
+
+    private TypeMapping entityMapping;
+
+    public SystemScatteredMappingCreator(MetadataRepository repository,
+                                         MappingRepository mappings,
+                                         MappingCreatorContext context,
+                                         boolean shouldCompressLongStrings,
+                                         boolean enforceTechnicalFK) {
+        this.internalRepository = repository;
+        this.mappings = mappings;
+        this.context = context;
+        this.preferClobUse = shouldCompressLongStrings;
+        this.enforceTechnicalFK = enforceTechnicalFK;
+    }
+
+    private TypeMapping handleField(FieldMetadata field) {
+        SimpleTypeFieldMetadata newFlattenField;
+        newFlattenField = new SimpleTypeFieldMetadata(currentType.peek(),
+                false,
+                field.isMany(),
+                field.isMandatory(),
+                context.getFieldColumn(field),
+                field.getType(),
+                field.getWriteUsers(),
+                field.getHideUsers(),
+                field.getWorkflowAccessRights());
+        TypeMetadata declaringType = field.getDeclaringType();
+        if (declaringType != field.getContainingType() && declaringType.isInstantiable()) {
+            SoftTypeRef type = new SoftTypeRef(internalRepository,
+                    declaringType.getNamespace(),
+                    declaringType.getName(),
+                    true);
+            newFlattenField.setDeclaringType(type);
+        }
+        String data = field.getType().getData(MetadataRepository.DATA_MAX_LENGTH);
+        if (data != null && preferClobUse) {
+            newFlattenField.getType().setData(TypeMapping.SQL_TYPE, "clob"); //$NON-NLS-1$
+            newFlattenField.setData(MetadataRepository.DATA_ZIPPED, Boolean.FALSE);
+        }
+        currentType.peek().addField(newFlattenField);
+        entityMapping.map(field, newFlattenField);
+        currentMapping.peek().map(field, newFlattenField);
+        return null;
+    }
+
+    private static String newNonInstantiableTypeName(ComplexTypeMetadata fieldReferencedType) {
+        return getNonInstantiableTypeName(fieldReferencedType.getName());
+    }
+
+    private static String getNonInstantiableTypeName(String typeName) {
+        if (!typeName.startsWith("X_")) { //$NON-NLS-1$
+            return "X_" + typeName.replace('-', '_'); //$NON-NLS-1$
+        } else {
+            return typeName;
+        }
+    }
+
+    @Override
+    public TypeMapping visit(ReferenceFieldMetadata referenceField) {
+        ComplexTypeMetadata fieldReferencedType = referenceField.getReferencedType();
+        ComplexTypeMetadata referencedType;
+        if (fieldReferencedType.isInstantiable()) {
+            String typeName = fieldReferencedType.getName().replace('-', '_');
+            referencedType = new SoftTypeRef(internalRepository,
+                    fieldReferencedType.getNamespace(),
+                    typeName,
+                    true);
+        } else {
+            referencedType = new SoftTypeRef(internalRepository,
+                    fieldReferencedType.getNamespace(),
+                    newNonInstantiableTypeName(fieldReferencedType),
+                    true);
+        }
+
+        String referencedTypeName = referencedType.getName().replace('-', '_');
+        FieldMetadata referencedFieldCopy = new SoftIdFieldRef(internalRepository, referencedTypeName);
+
+        ComplexTypeMetadata database = currentType.peek();
+
+        boolean fkIntegrity = referenceField.isFKIntegrity() && (fieldReferencedType != entityMapping.getUser()); // Don't enforce FK integrity for references to itself.
+        ReferenceFieldMetadata newFlattenField = new ReferenceFieldMetadata(currentType.peek(),
+                referenceField.isKey(),
+                referenceField.isMany(),
+                referenceField.isMandatory(),
+                context.getFieldColumn(referenceField),
+                referencedType,
+                referencedFieldCopy,
+                Collections.<FieldMetadata>emptyList(),
+                fkIntegrity,
+                referenceField.allowFKIntegrityOverride(),
+                new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
+                referenceField.getWriteUsers(),
+                referenceField.getHideUsers(),
+                referenceField.getWorkflowAccessRights());
+        newFlattenField.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH); // TODO Not very true...
+        database.addField(newFlattenField);
+        entityMapping.map(referenceField, newFlattenField);
+        currentMapping.peek().map(referenceField, newFlattenField);
+        return null;
+    }
+
+    @Override
+    public TypeMapping visit(ContainedComplexTypeMetadata containedType) {
+        String typeName = containedType.getName().replace('-', '_');
+        String databaseSuperType = createContainedType(getNonInstantiableTypeName(typeName), null, containedType);
+        for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
+            String subTypeName = subType.getName().replace('-', '_');
+            createContainedType(getNonInstantiableTypeName(subTypeName), databaseSuperType, subType);
+        }
+        return null;
+    }
+
+    private String createContainedType(String typeName, String superTypeName, ComplexTypeMetadata originalContainedType) {
+        ComplexTypeMetadata internalContainedType = (ComplexTypeMetadata) internalRepository.getType(typeName);
+        if (internalContainedType == null) {
+            internalContainedType = new ComplexTypeMetadataImpl(originalContainedType.getNamespace(),
+                    typeName,
+                    originalContainedType.getWriteUsers(),
+                    originalContainedType.getDenyCreate(),
+                    originalContainedType.getHideUsers(),
+                    originalContainedType.getDenyDelete(ComplexTypeMetadata.DeleteType.PHYSICAL),
+                    originalContainedType.getDenyDelete(ComplexTypeMetadata.DeleteType.LOGICAL),
+                    originalContainedType.getSchematron(),
+                    originalContainedType.getPrimaryKeyInfo(),
+                    originalContainedType.getLookupFields(),
+                    false,
+                    originalContainedType.getWorkflowAccessRights());
+            internalRepository.addTypeMetadata(internalContainedType);
+            if (superTypeName == null) {
+                // Generate a technical ID only if contained type does not have super type (subclasses will inherit it).
+                SimpleTypeFieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(internalContainedType,
+                        true,
+                        false,
+                        true,
+                        GENERATED_ID,
+                        new SoftTypeRef(internalRepository, internalRepository.getUserNamespace(), Types.UUID, false),
+                        originalContainedType.getWriteUsers(),
+                        originalContainedType.getHideUsers(),
+                        originalContainedType.getWorkflowAccessRights());
+                internalContainedType.addField(fieldMetadata);
+                fieldMetadata.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
+            } else {
+                SoftTypeRef type = new SoftTypeRef(internalRepository,
+                        internalContainedType.getNamespace(),
+                        superTypeName,
+                        false);
+                internalContainedType.addSuperType(type);
+            }
+            internalRepository.addTypeMetadata(internalContainedType);
+        }
+        // Visit contained type fields
+        TypeMapping mapping = mappings.getMappingFromUser(originalContainedType);
+        if (mapping != null) {
+            currentMapping.push(mapping);
+        } else {
+            mapping = new FlatTypeMapping(originalContainedType, internalContainedType, mappings);
+            mappings.addMapping(mapping);
+        }
+        currentMapping.push(mapping);
+        currentType.push(internalContainedType);
+        {
+            super.visit(originalContainedType);
+        }
+        currentType.pop();
+        currentMapping.pop();
+        return typeName;
+    }
+
+    @Override
+    public TypeMapping visit(ContainedTypeFieldMetadata containedField) {
+        String containedTypeName = newNonInstantiableTypeName(containedField.getContainedType());
+        SoftTypeRef typeRef = new SoftTypeRef(internalRepository,
+                containedField.getDeclaringType().getNamespace(),
+                containedTypeName,
+                false);
+        ReferenceFieldMetadata newFlattenField = new ReferenceFieldMetadata(currentType.peek(),
+                false,
+                containedField.isMany(),
+                containedField.isMandatory(),
+                context.getFieldColumn(containedField),
+                typeRef,
+                new SoftIdFieldRef(internalRepository, containedTypeName),
+                Collections.<FieldMetadata>emptyList(),
+                enforceTechnicalFK,
+                false,
+                new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
+                containedField.getWriteUsers(),
+                containedField.getHideUsers(),
+                containedField.getWorkflowAccessRights());
+        newFlattenField.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
+        newFlattenField.setData(MappingGenerator.SQL_DELETE_CASCADE, Boolean.TRUE.toString());
+        currentType.peek().addField(newFlattenField);
+        currentMapping.peek().map(containedField, newFlattenField);
+        entityMapping.map(containedField, newFlattenField);
+        if (!processedTypes.contains(containedField.getContainedType())) {
+            processedTypes.add(containedField.getContainedType());
+            containedField.getContainedType().accept(this);
+        }
+        return null;
+    }
+
+    @Override
+    public TypeMapping visit(SimpleTypeFieldMetadata simpleField) {
+        return handleField(simpleField);
+    }
+
+    @Override
+    public TypeMapping visit(EnumerationFieldMetadata enumField) {
+        return handleField(enumField);
+    }
+
+    @Override
+    public TypeMapping visit(ComplexTypeMetadata complexType) {
+        entityMapping = new SystemScatteredTypeMapping(complexType, mappings);
+        ComplexTypeMetadata database = entityMapping.getDatabase();
+        if (!complexType.isInstantiable()) {
+            // In this mapping prefix non instantiable types with "x_" so table name is not mixed up with an entity
+            // table with same name.
+            database.setName(newNonInstantiableTypeName(database));
+        }
+        currentMapping.push(entityMapping);
+        currentType.push(database);
+        {
+            internalRepository.addTypeMetadata(database);
+            if (complexType.getKeyFields().isEmpty() && complexType.getSuperTypes().isEmpty()) {
+                // Assumes super type will define an id.
+                SoftTypeRef type = new SoftTypeRef(internalRepository, StringUtils.EMPTY, Types.UUID, false);
+                SimpleTypeFieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(database,
+                        true,
+                        false,
+                        true,
+                        GENERATED_ID,
+                        type,
+                        Collections.<String>emptyList(),
+                        Collections.<String>emptyList(),
+                        Collections.<String>emptyList());
+                database.addField(fieldMetadata);
+                fieldMetadata.setData(MetadataRepository.DATA_MAX_LENGTH, UUID_LENGTH);
+            }
+            for (TypeMetadata superType : complexType.getSuperTypes()) {
+                if (superType.isInstantiable()) {
+                    SoftTypeRef type = new SoftTypeRef(internalRepository,
+                            superType.getNamespace(),
+                            superType.getName().replace('-', '_'),
+                            superType.isInstantiable());
+                    database.addSuperType(type);
+                } else {
+                    SoftTypeRef type = new SoftTypeRef(internalRepository,
+                            superType.getNamespace(),
+                            getNonInstantiableTypeName(superType.getName()),
+                            superType.isInstantiable());
+                    database.addSuperType(type);
+                }
+            }
+            super.visit(complexType);
+            for (FieldMetadata keyField : complexType.getKeyFields()) {
+                database.registerKey(database.getField(context.getFieldColumn(keyField.getName())));
+            }
+        }
+        currentType.pop();
+        currentMapping.pop();
+        if (!currentType.isEmpty()) { // This is unexpected
+            throw new IllegalStateException("Type remained in process stack.");
+        }
+        return entityMapping;
+    }
+}
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredTypeMapping.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredTypeMapping.java
new file mode 100644
index 0000000..505df4f
--- /dev/null
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemScatteredTypeMapping.java
@@ -0,0 +1,462 @@
+/*
+ * Copyright (C) 2006-2012 Talend Inc. - www.talend.com
+ *
+ * This source code is available under agreement available at
+ * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
+ *
+ * You should have received a copy of the agreement
+ * along with this program; if not, write to Talend SA
+ * 9 rue Pages 92150 Suresnes, France
+ */
+
+package com.amalto.core.storage.hibernate;
+
+import com.amalto.core.storage.Storage;
+import com.amalto.core.storage.record.DataRecord;
+import com.amalto.core.storage.record.metadata.DataRecordMetadata;
+import com.amalto.core.storage.record.metadata.UnsupportedDataRecordMetadata;
+import org.apache.commons.lang.NotImplementedException;
+import org.hibernate.Session;
+import org.hibernate.collection.PersistentList;
+import org.hibernate.engine.CollectionEntry;
+import org.hibernate.engine.SessionImplementor;
+import org.hibernate.persister.collection.CollectionPersister;
+import org.talend.mdm.commmon.metadata.*;
+
+import java.io.*;
+import java.lang.reflect.Constructor;
+import java.util.*;
+
+/**
+ * Represents type mapping between data model as specified by the user and data model as used by hibernate storage.
+ */
+class SystemScatteredTypeMapping extends TypeMapping {
+
+    private Map<String, FieldMetadata> userToDatabase = new HashMap<String, FieldMetadata>();
+
+    private Map<String, FieldMetadata> databaseToUser = new HashMap<String, FieldMetadata>();
+
+    public SystemScatteredTypeMapping(ComplexTypeMetadata user, MappingRepository mappings) {
+        super(user, mappings);
+    }
+
+    public void setValues(Session session, DataRecord from, Wrapper to) {
+        _setValues(session, from, to);
+    }
+
+    Object _setValues(Session session, DataRecord from, Wrapper to) {
+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
+        TypeMapping mapping = mappings.getMappingFromUser(from.getType());
+        Collection<FieldMetadata> fields;
+        if (mapping != null) {
+            fields = mapping.getUser().getFields();
+        } else {
+            fields = from.getType().getFields();
+        }
+        for (FieldMetadata field : fields) {
+            FieldMetadata mappedDatabaseField;
+            if (mapping != null) {
+                mappedDatabaseField = mapping.getDatabase(field);
+            } else {
+                mappedDatabaseField = getDatabase(field);
+            }
+            if (mappedDatabaseField == null) {
+                continue;
+                // throw new IllegalStateException("Field '" + field.getName() + "' was expected to have a database mapping");
+            }
+            if (field instanceof ContainedTypeFieldMetadata) {
+                if (!(mappedDatabaseField instanceof ReferenceFieldMetadata)) {
+                    throw new IllegalStateException("Contained elements are expected to be mapped to reference.");
+                }
+                ReferenceFieldMetadata referenceFieldMetadata = (ReferenceFieldMetadata) mappedDatabaseField;
+                if (!field.isMany()) {
+                    DataRecord referencedObject = (DataRecord) readValue(from, field, mappedDatabaseField, session);
+                    if (referencedObject != null) {
+                        TypeMapping mappingFromUser = mappings.getMappingFromUser(referencedObject.getType());
+                        ComplexTypeMetadata referencedType = mappingFromUser != null ? mappingFromUser.getDatabase() : referencedObject.getType();
+                        Wrapper existingValue = (Wrapper) to.get(referenceFieldMetadata.getName());
+                        boolean needCreate = existingValue == null;
+                        if (!needCreate) {
+                            ComplexTypeMetadata existingType = ((StorageClassLoader) contextClassLoader).getTypeFromClass(existingValue.getClass());
+                            needCreate = !existingType.equals(referencedType);
+                        }
+                        Wrapper object = needCreate ? createObject(contextClassLoader, referencedType) : existingValue;
+                        to.set(referenceFieldMetadata.getName(), _setValues(session, referencedObject, object));
+                        if (needCreate) {
+                            session.persist(object);
+                        }
+                    } else {
+                        to.set(referenceFieldMetadata.getName(), null);
+                    }
+                } else {
+                    List<DataRecord> dataRecords = (List<DataRecord>) readValue(from, field, mappedDatabaseField, session);
+                    Object value;
+                    if (mapping != null) {
+                        value = to.get(mapping.getDatabase(field).getName());
+                    } else {
+                        value = to.get(getDatabase(field).getName());
+                    }
+                    if (dataRecords != null) {
+                        List<Wrapper> existingValue = (List<Wrapper>) value;
+                        if (existingValue != null) {
+                            ((PersistentList) existingValue).forceInitialization();
+                        }
+                        List<Wrapper> objects = existingValue == null ? new ArrayList<Wrapper>(dataRecords.size()) : existingValue;
+                        int i = 0;
+                        for (DataRecord dataRecord : dataRecords) {
+                            if (i < objects.size() && objects.get(i) != null) {
+                                objects.set(i, (Wrapper) _setValues(session, dataRecord, objects.get(i)));
+                            } else {
+                                Wrapper object = createObject(contextClassLoader, dataRecord.getType());
+                                objects.add((Wrapper) _setValues(session, dataRecord, object));
+                                session.persist(object);
+                            }
+                            i++;
+                        }
+                        // TMDM-5257: Remove the deleted items
+                        while (objects.size() > dataRecords.size()) {
+                            objects.remove(objects.size() - 1);
+                        }
+                        to.set(referenceFieldMetadata.getName(), objects);
+                    } else {
+                        if (value != null && value instanceof List) {
+                            ((List) value).clear();
+                        }
+                    }
+                }
+            } else if (field instanceof ReferenceFieldMetadata) {
+                if (!field.isMany()) {
+                    DataRecord referencedObject = (DataRecord) readValue(from, field, mappedDatabaseField, session);
+                    if (referencedObject != null) {
+                        Collection<FieldMetadata> keyFields = referencedObject.getType().getKeyFields();
+                        Object referenceId;
+                        if (keyFields.size() > 1) {
+                            List<Object> referenceIdList = new LinkedList<Object>();
+                            for (FieldMetadata keyField : keyFields) {
+                                referenceIdList.add(readValue(referencedObject, keyField, mappedDatabaseField, session));
+                            }
+                            referenceId = referenceIdList;
+                        } else {
+                            referenceId = readValue(referencedObject, keyFields.iterator().next(), mappedDatabaseField, session);
+                        }
+                        to.set(mappedDatabaseField.getName(), getReferencedObject(contextClassLoader, session, mappings.getMappingFromUser(referencedObject.getType()).getDatabase(), referenceId));
+                    } else {
+                        to.set(mappedDatabaseField.getName(), null);
+                    }
+                } else {
+                    List<DataRecord> referencedObjectList = (List<DataRecord>) readValue(from, field, mappedDatabaseField, session);
+                    if (referencedObjectList != null) {
+                        List<Object> wrappers = new LinkedList<Object>();
+                        for (DataRecord dataRecord : referencedObjectList) {
+                            Collection<FieldMetadata> keyFields = dataRecord.getType().getKeyFields();
+                            Object referenceId;
+                            if (keyFields.size() > 1) {
+                                List<Object> referenceIdList = new LinkedList<Object>();
+                                for (FieldMetadata keyField : keyFields) {
+                                    referenceIdList.add(readValue(dataRecord, keyField, mappedDatabaseField, session));
+                                }
+                                referenceId = referenceIdList;
+                            } else {
+                                referenceId = readValue(dataRecord, keyFields.iterator().next(), mappedDatabaseField, session);
+                            }
+                            wrappers.add(getReferencedObject(contextClassLoader, session, dataRecord.getType(), referenceId));
+                        }
+                        to.set(mappedDatabaseField.getName(), wrappers);
+                    } else {
+                        Object value = to.get(mappedDatabaseField.getName());
+                        if (value != null && value instanceof List) {
+                            ((List) value).clear();
+                        }
+                    }
+                }
+            } else {
+                if (mappedDatabaseField.isMany()) {
+                    List<Object> oldValues = (List<Object>) to.get(mappedDatabaseField.getName());
+                    List<Object> newValues = (List<Object>) readValue(from, field, mappedDatabaseField, session);
+                    if (oldValues != null) {
+                        resetList(oldValues, newValues);
+                    } else {
+                        to.set(mappedDatabaseField.getName(), newValues);
+                    }
+                } else {
+                    to.set(mappedDatabaseField.getName(), readValue(from, field, mappedDatabaseField, session));
+                }
+            }
+        }
+        return to;
+    }
+
+    public DataRecord setValues(Wrapper from, DataRecord to) {
+        StorageClassLoader contextClassLoader = (StorageClassLoader) Thread.currentThread().getContextClassLoader();
+        ComplexTypeMetadata typeFromClass = contextClassLoader.getTypeFromClass(from.getClass());
+        for (FieldMetadata field : typeFromClass.getFields()) {
+            FieldMetadata userField = getUser(field);
+            String fieldName = field.getName();
+            Object value = readValue(from, field, userField);
+            if (userField != null) {
+                if (userField instanceof ContainedTypeFieldMetadata) {
+                    if (!userField.isMany()) {
+                        Wrapper valueAsWrapper = (Wrapper) value;
+                        if (value != null) {
+                            DataRecord containedDataRecord = new DataRecord(getActualContainedType(userField, valueAsWrapper), UnsupportedDataRecordMetadata.INSTANCE);
+                            to.set(userField, setValues(valueAsWrapper, containedDataRecord));
+                        }
+                    } else {
+                        List<Wrapper> wrapperList = (List<Wrapper>) value;
+                        if (wrapperList != null) {
+                            List<Wrapper> fullList = getFullList((PersistentList) value);
+                            for (Wrapper wrapper : fullList) {
+                                if (wrapper != null) {
+                                    to.set(userField, setValues(wrapper, new DataRecord(getActualContainedType(userField, wrapper), UnsupportedDataRecordMetadata.INSTANCE)));
+                                }
+                            }
+                        }
+                    }
+                } else if (userField instanceof ReferenceFieldMetadata) {
+                    if (!userField.isMany()) {
+                        Wrapper wrapper = (Wrapper) value;
+                        if (wrapper != null) {
+                            TypeMapping mapping = mappings.getMappingFromUser(contextClassLoader.getTypeFromClass(wrapper.getClass()));
+                            DataRecord referencedRecord = new DataRecord(mapping.getUser(), UnsupportedDataRecordMetadata.INSTANCE);
+                            for (FieldMetadata fkField : ((ReferenceFieldMetadata) field).getReferencedType().getFields()) {
+                                if (mapping.getUser(fkField) != null) {
+                                    referencedRecord.set(mapping.getUser(fkField), wrapper.get(fkField.getName()));
+                                }
+                            }
+                            to.set(userField, referencedRecord);
+                        }
+                    } else {
+                        List<Wrapper> wrapperList = (List<Wrapper>) value;
+                        if (wrapperList != null) {
+                            List<Wrapper> fullList;
+                            if (value instanceof PersistentList) {
+                                fullList = getFullList((PersistentList) value);
+                            } else {
+                                fullList = (List<Wrapper>) value;
+                            }
+                            for (Wrapper wrapper : fullList) {
+                                if (wrapper != null) {
+                                    TypeMapping mapping = mappings.getMappingFromUser(contextClassLoader.getTypeFromClass(wrapper.getClass()));
+                                    DataRecord referencedRecord = new DataRecord(mapping.getUser(), UnsupportedDataRecordMetadata.INSTANCE);
+                                    for (FieldMetadata fkField : ((ReferenceFieldMetadata) field).getReferencedType().getFields()) {
+                                        if (mapping.getUser(fkField) != null) {
+                                            referencedRecord.set(mapping.getUser(fkField), wrapper.get(fkField.getName()));
+                                        }
+                                    }
+                                    to.set(userField, referencedRecord);
+                                }
+                            }
+                        }
+                    }
+                } else {
+                    to.set(userField, value);
+                }
+            } else {
+                DataRecordMetadata recordMetadata = to.getRecordMetadata();
+                Map<String,String> recordProperties = recordMetadata.getRecordProperties();
+                if (!ScatteredMappingCreator.GENERATED_ID.equals(fieldName) && value != null) {
+                    try {
+                        recordProperties.put(fieldName, String.valueOf(value));
+                    } catch (Exception e) {
+                        throw new RuntimeException("Unexpected set error.", e);
+                    }
+                }
+            }
+        }
+        return to;
+    }
+
+    /*
+     * See TMDM-5524: Hibernate sometimes "hides" values of a collection when condition is on contained value. This piece
+     * of code forces load.
+     */
+    private static <T> List<T> getFullList(PersistentList list) {
+        if (list == null) {
+            return null;
+        }
+        List<T> fullList = new LinkedList<T>();
+        SessionImplementor session = list.getSession();
+        if (!session.isConnected()) {
+            throw new IllegalStateException("Session is not connected: impossible to read values from database.");
+        }
+        CollectionEntry entry = session.getPersistenceContext().getCollectionEntry(list);
+        CollectionPersister persister = entry.getLoadedPersister();
+        int databaseSize = persister.getSize(entry.getKey(), session);
+        if (list.size() == databaseSize && !list.contains(null)) {
+            // No need to reload a list (no omission in list and size() corresponds to size read from database).
+            return (List<T>) list;
+        }
+        for (int i = 0; i < databaseSize; i++) {
+            T wrapper = (T) persister.getElementByIndex(entry.getLoadedKey(), i, session, list.getOwner());
+            fullList.add(wrapper);
+        }
+        // Returns a unmodifiable list -> returned list is *not* a persistent list so change tracking is not possible,
+        // returning a unmodifiable list is a safety for code using returned list.
+        return Collections.unmodifiableList(fullList);
+    }
+
+    @Override
+    public String getDatabaseTimestamp() {
+        return Storage.METADATA_TIMESTAMP;
+    }
+
+    @Override
+    public String getDatabaseTaskId() {
+        return Storage.METADATA_TASK_ID;
+    }
+
+    // Returns actual contained type (in case in reference to hold contained record can have sub types).
+    // Not expected to be use for foreign keys, and also very specific to this mapping implementation.
+    private ComplexTypeMetadata getActualContainedType(FieldMetadata userField, Wrapper value) {
+        Class<?> clazz = value.getClass();
+        if (clazz.getName().contains("javassist")) { //$NON-NLS-1$
+            clazz = clazz.getSuperclass();
+        }
+        ComplexTypeMetadata typeFromClass = ((StorageClassLoader) Thread.currentThread().getContextClassLoader()).getTypeFromClass(clazz);
+        TypeMapping mappingFromDatabase = mappings.getMappingFromDatabase(typeFromClass);
+        String actualValueType;
+        if (mappingFromDatabase != null) {
+            actualValueType = mappingFromDatabase.getUser().getName();
+        } else {
+            actualValueType = clazz.getSimpleName();
+        }
+        if (actualValueType.equalsIgnoreCase(userField.getType().getName())) {
+            return (ComplexTypeMetadata) userField.getType();
+        } else {
+            Collection<ComplexTypeMetadata> subTypes = ((ComplexTypeMetadata) userField.getType()).getSubTypes();
+            for (ComplexTypeMetadata subType : subTypes) {
+                if (subType.getName().equalsIgnoreCase(actualValueType)) {
+                    return subType;
+                }
+            }
+        }
+        throw new IllegalStateException("Could not set value with class '" + String.valueOf(value) + "' to field '" + userField.getName() + "'.");
+    }
+
+    private Wrapper createObject(ClassLoader storageClassLoader, ComplexTypeMetadata referencedType) {
+        try {
+            TypeMapping mappingFromUser = mappings.getMappingFromUser(referencedType);
+            Class<? extends Wrapper> referencedClass;
+            if (mappingFromUser != null) {
+                ComplexTypeMetadata databaseReferenceType = mappingFromUser.getDatabase();
+                referencedClass = ((StorageClassLoader) storageClassLoader).getClassFromType(databaseReferenceType);
+            } else {
+                referencedClass = ((StorageClassLoader) storageClassLoader).getClassFromType(referencedType);
+            }
+            return referencedClass.newInstance();
+        } catch (Exception e) {
+            throw new RuntimeException("Could not create wrapper object for type '" + referencedType.getName() + "'", e);
+        }
+    }
+
+    private Object getReferencedObject(ClassLoader storageClassLoader, Session session, ComplexTypeMetadata referencedType, Object referencedIdValue) {
+        Class<?> referencedClass;
+        try {
+            referencedClass = ((StorageClassLoader) storageClassLoader).getClassFromType(referencedType);
+        } catch (Exception e) {
+            throw new RuntimeException("Could not get class for type '" + referencedType.getName() + "'", e);
+        }
+        try {
+            if (referencedIdValue == null) {
+                return null; // Means no reference (reference is null).
+            }
+            if (referencedIdValue instanceof Wrapper) {
+                return referencedIdValue; // It's already the referenced object.
+            }
+            // Try to load object from current session
+            if (referencedIdValue instanceof List) {
+                // Handle composite id values
+                Serializable result;
+                try {
+                    Class<?> idClass = storageClassLoader.loadClass(referencedClass.getName() + "_ID"); //$NON-NLS-1$
+                    Class[] parameterClasses = new Class[((List) referencedIdValue).size()];
+                    int i = 0;
+                    for (Object o : (List) referencedIdValue) {
+                        if (o == null) {
+                            throw new IllegalStateException("Id cannot have a null value.");
+                        }
+                        parameterClasses[i++] = o.getClass();
+                    }
+                    Constructor<?> constructor = idClass.getConstructor(parameterClasses);
+                    result = (Serializable) constructor.newInstance(((List) referencedIdValue).toArray());
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+                Serializable referencedValueId = result;
+
+                Object sessionObject = session.load(referencedClass, referencedValueId);
+                if (sessionObject != null) {
+                    return sessionObject;
+                }
+            } else if (referencedIdValue instanceof Serializable) {
+                Object sessionObject = session.load(referencedClass, (Serializable) referencedIdValue);
+                if (sessionObject != null) {
+                    return sessionObject;
+                }
+            } else {
+                throw new NotImplementedException("Unexpected state.");
+            }
+            Class<?> fieldJavaType = referencedIdValue.getClass();
+            // Null package might happen with proxy classes generated by Hibernate
+            if (fieldJavaType.getPackage() != null && fieldJavaType.getPackage().getName().startsWith("java.")) {  //$NON-NLS-1$
+                Wrapper referencedObject = (Wrapper) referencedClass.newInstance();
+                for (FieldMetadata fieldMetadata : referencedType.getFields()) {
+                    if (fieldMetadata.isKey()) {
+                        referencedObject.set(fieldMetadata.getName(), referencedIdValue);
+                    }
+                }
+                return referencedObject;
+            } else {
+                return referencedIdValue;
+            }
+        } catch (Exception e) {
+            throw new RuntimeException("Could not create referenced object of type '" + referencedClass + "' with id '" + String.valueOf(referencedIdValue) + "'", e);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "SCATTERED (" + user.getName() + ")"; //$NON-NLS-1$ //$NON-NLS-2$
+    }
+
+    protected void map(FieldMetadata user, FieldMetadata database) {
+        if (isFrozen) {
+            throw new IllegalStateException("Mapping is frozen.");
+        }
+        userToDatabase.put(user.getContainingType().getName() + '_' + user.getName(), database);
+        databaseToUser.put(database.getContainingType().getName() + '_' + database.getName(), user);
+    }
+
+    public FieldMetadata getDatabase(FieldMetadata from) {
+        return userToDatabase.get(from.getContainingType().getName() + '_' + from.getName());
+    }
+
+    public FieldMetadata getUser(FieldMetadata to) {
+        return databaseToUser.get(to.getContainingType().getName() + '_' + to.getName());
+    }
+
+    /**
+     * "Freeze" both database and internal types.
+     *
+     * @see TypeMetadata#freeze()
+     */
+    public void freeze() {
+        if (!isFrozen) {
+            // Ensure mapped type are frozen.
+            database.freeze();
+            user.freeze();
+            // Freeze field mappings.
+            Map<String, FieldMetadata> frozen = new HashMap<String, FieldMetadata>();
+            for (Map.Entry<String, FieldMetadata> entry : userToDatabase.entrySet()) {
+                frozen.put(entry.getKey(), entry.getValue().freeze());
+            }
+            userToDatabase = frozen;
+            frozen = new HashMap<String, FieldMetadata>();
+            for (Map.Entry<String, FieldMetadata> entry : databaseToUser.entrySet()) {
+                frozen.put(entry.getKey(), entry.getValue().freeze());
+            }
+            databaseToUser = frozen;
+            isFrozen = true;
+        }
+    }
+}
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemTypeMappingRepository.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemTypeMappingRepository.java
index 25eee30..2edd8fd 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemTypeMappingRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/SystemTypeMappingRepository.java
@@ -12,7 +12,6 @@
 package com.amalto.core.storage.hibernate;
 
 import com.amalto.core.storage.Storage;
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.*;
 
 import javax.xml.XMLConstants;
@@ -24,6 +23,31 @@ class SystemTypeMappingRepository extends InternalRepository {
         super(strategy);
     }
 
+    @Override
+    public MetadataRepository visit(MetadataRepository repository) {
+        MetadataRepository result = super.visit(repository);
+        for (TypeMetadata type : repository.getNonInstantiableTypes()) {
+            type.accept(this);
+        }
+        return result;
+    }
+
+    @Override
+    MetadataVisitor<TypeMapping> getTypeMappingCreator(TypeMetadata type, TypeMappingStrategy strategy) {
+        MetadataVisitor<TypeMapping> defaultMappingCreator = super.getTypeMappingCreator(type, strategy);
+        if (defaultMappingCreator instanceof ScatteredMappingCreator) {
+            MappingCreatorContext scatteredContext = new StatefulContext();
+            return new SystemScatteredMappingCreator(internalRepository,
+                    mappings,
+                    scatteredContext,
+                    strategy.preferClobUse(),
+                    strategy.useTechnicalFk());
+
+        } else {
+            return defaultMappingCreator;
+        }
+    }
+
     public MetadataRepository visit(ComplexTypeMetadata complexType) {
         MetadataVisitor<TypeMapping> creator = getTypeMappingCreator(complexType, strategy);
         TypeMapping typeMapping = complexType.accept(creator);
@@ -33,12 +57,12 @@ class SystemTypeMappingRepository extends InternalRepository {
         if (database.isInstantiable() && !database.isFrozen() && database.getSuperTypes().isEmpty()) {
             TypeMetadata longType = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.LONG, false);
             TypeMetadata stringType = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING, false);
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
         }
         // Register mapping
         internalRepository.addTypeMetadata(typeMapping.getDatabase());
-        mappings.addMapping(complexType, typeMapping);
+        mappings.addMapping(typeMapping);
         return internalRepository;
     }
 }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/TypeMappingCreator.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/TypeMappingCreator.java
index cd52e8b..6127d4f 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/TypeMappingCreator.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/TypeMappingCreator.java
@@ -29,6 +29,8 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     private final MappingRepository mappings;
 
+    private final MappingCreatorContext context;
+
     private TypeMapping typeMapping;
 
     private boolean forceKey = false;
@@ -36,19 +38,7 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
     public TypeMappingCreator(MetadataRepository repository, MappingRepository mappings) {
         this.mappings = mappings;
         this.internalRepository = repository;
-    }
-
-    String getColumnName(FieldMetadata field) {
-        StringBuilder buffer = new StringBuilder();
-        for (String currentPrefix : prefix) {
-            buffer.append(currentPrefix).append('_');
-        }
-        String name = field.getName();
-        // Note #1: Hibernate (starting from 4.0) internally sets a lower case letter as first letter if field starts with a
-        // upper case character. To prevent any error due to missing field, lower case the field name.
-        // Note #2: Prefix everything with "x_" so there won't be any conflict with database internal type names.
-        // Note #3: Having '-' character is bad for Java code generation, so replace it with '_'.
-        return "x_" + (buffer.toString().replace('-', '_') + name.replace('-', '_')).toLowerCase(); //$NON-NLS-1$
+        this.context = new StatelessContext(prefix);
     }
 
     private static boolean isDatabaseMandatory(FieldMetadata field, TypeMetadata declaringType) {
@@ -61,7 +51,7 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     @Override
     public TypeMapping visit(ReferenceFieldMetadata referenceField) {
-        String name = getColumnName(referenceField);
+        String name = context.getFieldColumn(referenceField);
         String typeName = referenceField.getReferencedType().getName().replace('-', '_');
         ComplexTypeMetadata referencedType = new SoftTypeRef(internalRepository, referenceField.getReferencedType().getNamespace(), typeName, true);
         FieldMetadata referencedField = new SoftIdFieldRef(internalRepository, typeName);
@@ -82,11 +72,10 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                     new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING),
                     referenceField.getWriteUsers(),
                     referenceField.getHideUsers(),
-                    referenceField.getWorkflowAccessRights(),
-                    name);
+                    referenceField.getWorkflowAccessRights());
             database.addField(newFlattenField);
         } else {
-            newFlattenField = new SoftFieldRef(internalRepository, getColumnName(referenceField), referenceField.getContainingType());
+            newFlattenField = new SoftFieldRef(internalRepository, context.getFieldColumn(referenceField), referenceField.getContainingType());
         }
         typeMapping.map(referenceField, newFlattenField);
         return typeMapping;
@@ -94,7 +83,7 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
 
     @Override
     public TypeMapping visit(ContainedComplexTypeMetadata containedType) {
-        mappings.addMapping(containedType, typeMapping);
+        mappings.addMapping(typeMapping);
         Collection<FieldMetadata> fields = containedType.getFields();
         for (FieldMetadata field : fields) {
             field.accept(this);
@@ -106,7 +95,7 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
     public TypeMapping visit(ContainedTypeFieldMetadata containedField) {
         prefix.add(containedField.getName());
         {
-            ContainedComplexTypeMetadata containedType = containedField.getContainedType();
+            ComplexTypeMetadata containedType = containedField.getContainedType();
             containedType.accept(this);
             for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
                 for (FieldMetadata subTypeField : subType.getFields()) {
@@ -128,12 +117,11 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                     false,
                     simpleField.isMany(),
                     isDatabaseMandatory(simpleField, declaringType),
-                    getColumnName(simpleField),
+                    context.getFieldColumn(simpleField),
                     simpleField.getType(),
                     simpleField.getWriteUsers(),
                     simpleField.getHideUsers(),
-                    simpleField.getWorkflowAccessRights(),
-                    getColumnName(simpleField));
+                    simpleField.getWorkflowAccessRights());
             database.addField(newFlattenField);
         } else {
             SoftTypeRef internalDeclaringType;
@@ -146,12 +134,11 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                     false,
                     simpleField.isMany(),
                     isDatabaseMandatory(simpleField, declaringType),
-                    getColumnName(simpleField),
+                    context.getFieldColumn(simpleField),
                     simpleField.getType(),
                     simpleField.getWriteUsers(),
                     simpleField.getHideUsers(),
-                    simpleField.getWorkflowAccessRights(),
-                    getColumnName(simpleField));
+                    simpleField.getWorkflowAccessRights());
             newFlattenField.setDeclaringType(internalDeclaringType);
             database.addField(newFlattenField);
         }
@@ -170,15 +157,16 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
                     isKey,
                     enumField.isMany(),
                     isDatabaseMandatory(enumField, enumField.getDeclaringType()),
-                    getColumnName(enumField),
+                    context.getFieldColumn(enumField),
                     enumField.getType(),
                     enumField.getWriteUsers(),
                     enumField.getHideUsers(),
-                    enumField.getWorkflowAccessRights(),
-                    getColumnName(enumField));
+                    enumField.getWorkflowAccessRights());
             database.addField(newFlattenField);
         } else {
-            newFlattenField = new SoftFieldRef(internalRepository, getColumnName(enumField), enumField.getContainingType());
+            newFlattenField = new SoftFieldRef(internalRepository,
+                    context.getFieldColumn(enumField),
+                    enumField.getContainingType());
         }
         typeMapping.map(enumField, newFlattenField);
         return typeMapping;
@@ -195,7 +183,7 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
         ComplexTypeMetadata database = typeMapping.getDatabase();
         Collection<TypeMetadata> superTypes = complexType.getSuperTypes();
         for (TypeMetadata superType : superTypes) {
-            database.addSuperType(new SoftTypeRef(internalRepository, superType.getNamespace(), superType.getName(), true), internalRepository);
+            database.addSuperType(new SoftTypeRef(internalRepository, superType.getNamespace(), superType.getName(), true));
         }
         forceKey = true;
         for (FieldMetadata keyField : keyFields) {
@@ -204,7 +192,16 @@ class TypeMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
         forceKey = false;
         if (typeMapping.getUser().getKeyFields().isEmpty() && typeMapping.getUser().getSuperTypes().isEmpty()) { // Assumes super type defines key field.
             SoftTypeRef type = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING, false);
-            database.addField(new SimpleTypeFieldMetadata(database, true, false, true, "X_TALEND_ID", type, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), "X_TALEND_ID")); //$NON-NLS-1$ //$NON-NLS-2$
+            SimpleTypeFieldMetadata fieldMetadata = new SimpleTypeFieldMetadata(database,
+                    true,
+                    false,
+                    true,
+                    ScatteredMappingCreator.GENERATED_ID,
+                    type,
+                    Collections.<String>emptyList(),
+                    Collections.<String>emptyList(),
+                    Collections.<String>emptyList());
+            database.addField(fieldMetadata);
         }
         return typeMapping;
     }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UpdateReportMappingCreator.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UpdateReportMappingCreator.java
index 000d788..75f37f2 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UpdateReportMappingCreator.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UpdateReportMappingCreator.java
@@ -31,16 +31,16 @@ class UpdateReportMappingCreator extends DefaultMetadataVisitor<TypeMapping> {
         TypeMetadata stringType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING);
         TypeMetadata longStringType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING);
         TypeMetadata longType = new SimpleTypeMetadata(XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.LONG);
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_user_name", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, true, false, true, "x_source", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, true, false, true, "x_time_in_millis", longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_operation_type", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_revision_id", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_data_cluster", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_data_model", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_concept", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_key", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY)); //$NON-NLS-1$
-        SimpleTypeFieldMetadata items_xml = new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_items_xml", longStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_user_name", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, true, false, true, "x_source", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, true, false, true, "x_time_in_millis", longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_operation_type", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_revision_id", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_data_cluster", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_data_model", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_concept", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        databaseUpdateReportType.addField(new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_key", stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList())); //$NON-NLS-1$
+        SimpleTypeFieldMetadata items_xml = new SimpleTypeFieldMetadata(databaseUpdateReportType, false, false, false, "x_items_xml", longStringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()); //$NON-NLS-1$
         items_xml.getType().setData(TypeMapping.SQL_TYPE, "text"); //$NON-NLS-1$
         databaseUpdateReportType.addField(items_xml);
         DATABASE_UPDATE_REPORT_TYPE = (ComplexTypeMetadata) databaseUpdateReportType.freeze();
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UserTypeMappingRepository.java b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UserTypeMappingRepository.java
index 9744da0..813d04e 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UserTypeMappingRepository.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/hibernate/UserTypeMappingRepository.java
@@ -11,7 +11,6 @@
 
 package com.amalto.core.storage.hibernate;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.*;
 import com.amalto.core.storage.Storage;
 
@@ -31,12 +30,12 @@ class UserTypeMappingRepository extends InternalRepository {
         if (database.isInstantiable() && !database.isFrozen()) {
             TypeMetadata longType = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.LONG, false);
             TypeMetadata stringType = new SoftTypeRef(internalRepository, XMLConstants.W3C_XML_SCHEMA_NS_URI, Types.STRING, false);
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
-            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList(), StringUtils.EMPTY));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, true, Storage.METADATA_TIMESTAMP, longType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
+            database.addField(new SimpleTypeFieldMetadata(database, false, false, false, Storage.METADATA_TASK_ID, stringType, Collections.<String>emptyList(), Collections.<String>emptyList(), Collections.<String>emptyList()));
         }
         // Register mapping
         internalRepository.addTypeMetadata(typeMapping.getDatabase());
-        mappings.addMapping(complexType, typeMapping);
+        mappings.addMapping(typeMapping);
         return internalRepository;
     }
 }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/record/DataRecord.java b/org.talend.mdm.core/src/com/amalto/core/storage/record/DataRecord.java
index fee0331..43c5316 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/record/DataRecord.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/record/DataRecord.java
@@ -102,6 +102,14 @@ public class DataRecord {
             } else if (recordMetadata.getRecordProperties().containsKey(field.getName())) { // Try to read from metadata
                 return recordMetadata.getRecordProperties().get(field.getName());
             }
+            // Last chance for finding value: reused field might not be hashCode-equals so does a by-name lookup.
+            if (field instanceof ContainedTypeFieldMetadata) {
+                for (Map.Entry<FieldMetadata, Object> entry : fieldToValue.entrySet()) {
+                    if (field.getName().equals(entry.getKey().getName())) {
+                        return entry.getValue();
+                    }
+                }
+            }
             return null;
         }
     }
diff --git a/org.talend.mdm.core/src/com/amalto/core/storage/record/XmlStringDataRecordReader.java b/org.talend.mdm.core/src/com/amalto/core/storage/record/XmlStringDataRecordReader.java
index 40a5929..7a98aac 100644
--- a/org.talend.mdm.core/src/com/amalto/core/storage/record/XmlStringDataRecordReader.java
+++ b/org.talend.mdm.core/src/com/amalto/core/storage/record/XmlStringDataRecordReader.java
@@ -158,12 +158,12 @@ public class XmlStringDataRecordReader implements DataRecordReader<String> {
                                 } else if (fieldType instanceof ContainedComplexTypeMetadata) { // Reads xsi:type for actual contained type.
                                     Attribute actualType = startElement.getAttributeByName(new QName(XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, "type")); //$NON-NLS-1$
                                     if (actualType != null) {
-                                        TypeMetadata potentialActualType = repository.getNonInstantiableType(fieldType.getNamespace(), actualType.getValue());
-                                        if (potentialActualType != null) {
-                                            fieldType = potentialActualType;
-                                        } else {
-                                            if (LOGGER.isDebugEnabled()) {
-                                                LOGGER.debug("Ignoring xsi:type '" + actualType + "' because it is not a data model type.");
+                                        if (!actualType.getValue().equals(fieldType.getName())) {
+                                            for (ComplexTypeMetadata subType : ((ContainedComplexTypeMetadata) fieldType).getSubTypes()) {
+                                                if (actualType.getValue().equals(subType.getName())) {
+                                                    fieldType = subType;
+                                                    break;
+                                                }
                                             }
                                         }
                                     }
diff --git a/org.talend.mdm.core/test/com/amalto/core/integrity/ForeignKeyIntegrityTest.java b/org.talend.mdm.core/test/com/amalto/core/integrity/ForeignKeyIntegrityTest.java
index 73b79c5..99f8780 100644
--- a/org.talend.mdm.core/test/com/amalto/core/integrity/ForeignKeyIntegrityTest.java
+++ b/org.talend.mdm.core/test/com/amalto/core/integrity/ForeignKeyIntegrityTest.java
@@ -427,7 +427,7 @@ public class ForeignKeyIntegrityTest extends TestCase {
 
         // Check FK integrity checks following TMDM-3515
         Set<ReferenceFieldMetadata> references = getReferencedFields(repository, "BusinessFunction");
-        assertEquals(2, references.size());
+        assertEquals(10, references.size());
 
         IntegrityCheckDataSourceMock dataSource = new IntegrityCheckDataSourceMock(repository);
         FKIntegrityChecker integrityChecker = FKIntegrityChecker.getInstance();
@@ -452,7 +452,7 @@ public class ForeignKeyIntegrityTest extends TestCase {
 
         // Check FK integrity checks following TMDM-3739
         Set<ReferenceFieldMetadata> references = getReferencedFields(repository, "Contrat");
-        assertEquals(14, references.size());
+        assertEquals(30, references.size());
 
         String dataCluster = "DataCluster";
         String typeName = "Contrat";
@@ -497,7 +497,7 @@ public class ForeignKeyIntegrityTest extends TestCase {
 
         MetadataRepository repository = getMetadataRepository("model17.xsd");
         Set<ReferenceFieldMetadata> references = getReferencedFields(repository, "Contrat");
-        assertEquals(14, references.size());
+        assertEquals(30, references.size());
         ReferenceFieldMetadata referencedField = references.iterator().next();
 
         String dataCluster = "DataCluster";
diff --git a/org.talend.mdm.core/test/com/amalto/core/query/InheritanceTest.java b/org.talend.mdm.core/test/com/amalto/core/query/InheritanceTest.java
index df14882..cc5aacc 100644
--- a/org.talend.mdm.core/test/com/amalto/core/query/InheritanceTest.java
+++ b/org.talend.mdm.core/test/com/amalto/core/query/InheritanceTest.java
@@ -86,9 +86,10 @@ public class InheritanceTest extends StorageTestCase {
     public void testTypeOrdering() throws Exception {
         List<ComplexTypeMetadata> sortedList = MetadataUtils.sortTypes(repository);
         // New order following XML schema library
-        String[] expectedOrder = {"Group", "Persons", "Employee", "Update", "SS", "Country", "Address", "Supplier", "B",
-                "D", "A", "C", "Person", "EntityWithQuiteALongNameWithoutIncludingAnyUnderscore", "ProductFamily",
-                "TypeA", "ff", "E1", "E2", "Concurrent", "Manager", "Store", "Product", "a2", "a1" };
+        String[] expectedOrder = {"Store", "Update", "B", "D", "A", "C", "Country", "Group",
+                "EntityWithQuiteALongNameWithoutIncludingAnyUnderscore", "Persons", "Employee", "Concurrent", "SS",
+                "ProductFamily", "ff", "E1", "E2", "Manager", "Address", "Supplier", "Product", "TypeA", "a2", "a1",
+                "Person"};
         int i = 0;
         for (ComplexTypeMetadata sortedType : sortedList) {
             assertEquals(expectedOrder[i++], sortedType.getName());
@@ -116,7 +117,7 @@ public class InheritanceTest extends StorageTestCase {
         };
         sortedList = MetadataUtils.sortTypes(repository, Arrays.asList(types));
         // New order following XML schema library
-        expectedOrder = new String[] {"Country", "Address", "Product"};
+        expectedOrder = new String[] {"Product", "Country", "Address"};
         i = 0;
         for (ComplexTypeMetadata sortedType : sortedList) {
             assertEquals(expectedOrder[i++], sortedType.getName());
diff --git a/org.talend.mdm.core/test/com/amalto/core/query/StorageIntegrityTest.java b/org.talend.mdm.core/test/com/amalto/core/query/StorageIntegrityTest.java
index 6b01d29..e5fb3a8 100644
--- a/org.talend.mdm.core/test/com/amalto/core/query/StorageIntegrityTest.java
+++ b/org.talend.mdm.core/test/com/amalto/core/query/StorageIntegrityTest.java
@@ -203,8 +203,8 @@ public class StorageIntegrityTest extends TestCase {
 
     private Storage prepareStorage(MetadataRepository repository) {
         Storage storage = new HibernateStorage("MDMStorageIntegrityTest");
-        storage.init(ServerContext.INSTANCE.get().getDataSource(StorageTestCase.DATABASE + "-Default", "MDM", StorageType.MASTER));
-        storage.prepare(repository, false);
+        storage.init(ServerContext.INSTANCE.get().getDataSource(StorageTestCase.DATABASE + "-DS1", "MDM", StorageType.MASTER));
+        storage.prepare(repository, true);
         return storage;
     }
 }
diff --git a/org.talend.mdm.core/test/com/amalto/core/query/TestDataRecordCreator.java b/org.talend.mdm.core/test/com/amalto/core/query/TestDataRecordCreator.java
index 567934a..a4e2865 100644
--- a/org.talend.mdm.core/test/com/amalto/core/query/TestDataRecordCreator.java
+++ b/org.talend.mdm.core/test/com/amalto/core/query/TestDataRecordCreator.java
@@ -101,7 +101,7 @@ class TestDataRecordCreator extends DefaultMetadataVisitor<DataRecord> {
                         return s;
                     }
                 } else {
-                    return "" + random.nextLong();
+                    return field.getPath();
                 }
             } else if ("integer".equals(type.getName())
                     || "positiveInteger".equals(type.getName())
diff --git a/org.talend.mdm.core/test/com/amalto/core/storage/record/DataRecordDefaultWriterTest.java b/org.talend.mdm.core/test/com/amalto/core/storage/record/DataRecordDefaultWriterTest.java
index cd61986..51e7d18 100644
--- a/org.talend.mdm.core/test/com/amalto/core/storage/record/DataRecordDefaultWriterTest.java
+++ b/org.talend.mdm.core/test/com/amalto/core/storage/record/DataRecordDefaultWriterTest.java
@@ -27,7 +27,7 @@ public class DataRecordDefaultWriterTest extends TestCase {
     public void testWrite() throws IOException {
         String xml = "<referenceField>[111][222][444]</referenceField>"; //$NON-NLS-1$
 
-        FieldMetadata fieldMetadata = new ReferenceFieldMetadata(null, true, false, true, "referenceField", null, null, Collections.<FieldMetadata>emptyList(), true, true, null, null, null, null, null); //$NON-NLS-1$
+        FieldMetadata fieldMetadata = new ReferenceFieldMetadata(null, true, false, true, "referenceField", null, null, Collections.<FieldMetadata>emptyList(), true, true, null, null, null, null); //$NON-NLS-1$
         DataRecord record = new DataRecord(null, null);
         Object[] values = new Object[3];
         values[0] = "111"; //$NON-NLS-1$
