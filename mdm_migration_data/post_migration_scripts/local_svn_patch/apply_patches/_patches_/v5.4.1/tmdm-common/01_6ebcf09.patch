diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/AliasedFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/AliasedFieldMetadata.java
index ef3ed65..dfba7a1 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/AliasedFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/AliasedFieldMetadata.java
@@ -35,8 +35,7 @@ public class AliasedFieldMetadata extends SimpleTypeFieldMetadata {
                 fieldType,
                 allowWriteUsers,
                 hideUsers,
-                aliasedField.getWorkflowAccessRights(),
-                aliasedField.getPath());
+                aliasedField.getWorkflowAccessRights());
         this.realFieldName = aliasedField.getName();
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadata.java
index 1833940..79c9673 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadata.java
@@ -19,6 +19,12 @@ import java.util.List;
  */
 public interface ComplexTypeMetadata extends TypeMetadata {
 
+    ComplexTypeMetadata getEntity();
+
+    FieldMetadata getContainer();
+
+    void setContainer(FieldMetadata field);
+
     /**
      * @return A {@link List} of {@link FieldMetadata} that represents key information for the complex type. This method
      *         might return an empty list if no key field is defined for this type.
@@ -124,6 +130,12 @@ public interface ComplexTypeMetadata extends TypeMetadata {
 
     List<FieldMetadata> getLookupFields();
 
+    void declareUsage(ContainedComplexTypeMetadata usage);
+
+    void freezeUsages();
+
+    void setSubTypes(List<ComplexTypeMetadata> subTypes);
+
     enum DeleteType {
         /**
          * Logical delete (a.k.a. send to trash)
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadataImpl.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadataImpl.java
index 1e0bfbc..a9b7e3f 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadataImpl.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ComplexTypeMetadataImpl.java
@@ -33,7 +33,7 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
 
     private final Map<String, FieldMetadata> keyFields = new LinkedHashMap<String, FieldMetadata>();
 
-    private final Collection<TypeMetadata> superTypes = new LinkedList<TypeMetadata>();
+    private final Collection<TypeMetadata> superTypes = new HashSet<TypeMetadata>();
 
     private final List<String> denyCreate;
 
@@ -55,12 +55,14 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
 
     private String name;
 
-    private MetadataRepository repository;
-
     private boolean isFrozen;
     
     private final List<String> workflowAccessRights;
 
+    private FieldMetadata containingField;
+
+    private List<ContainedComplexTypeMetadata> usages = new ArrayList<ContainedComplexTypeMetadata>();
+
     public ComplexTypeMetadataImpl(String nameSpace, String name, boolean instantiable) {
         this(nameSpace,
                 name,
@@ -102,11 +104,10 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
         this.workflowAccessRights = workflowAccessRights;
     }
 
-    public void addSuperType(TypeMetadata superType, MetadataRepository repository) {
+    public void addSuperType(TypeMetadata superType) {
         if (isFrozen) {
             throw new IllegalStateException("Type '" + name + "' is frozen and can not be modified.");
         }
-        this.repository = repository;
         superTypes.add(superType);
     }
 
@@ -169,25 +170,26 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
                         throw new IllegalArgumentException("Reusable type could not be null for fieldName '" + fieldName + "'"); //$NON-NLS-1$ //$NON-NLS-2$
                     }
                     if (!reusableTypeName.isEmpty() && !currentType.getName().equals(reusableTypeName)) { // Look real type in sub types
-                        boolean isFindRealType = false;
+                        boolean foundRealType = false;
                         for (TypeMetadata subType : currentType.getSubTypes()) {
                             if (subType instanceof ComplexTypeMetadata && subType.getName().equals(reusableTypeName)) {
                                 currentType = (ComplexTypeMetadata) subType;
-                                isFindRealType = true;
+                                foundRealType = true;
                                 break;
                             }
                         }
-                        if (!isFindRealType) {
+                        if (!foundRealType) {
                             throw new IllegalArgumentException("Type '" + reusableTypeName + "' could not be found."); //$NON-NLS-1$ //$NON-NLS-2$
                         }
                     }
                 }
+                List<String> pathElements = new ArrayList<String>();
                 while (tokenizer.hasMoreTokens()) {
-                    String currentFieldName = tokenizer.nextToken();
-                    currentField = currentType.getField(currentFieldName);
-                    if (tokenizer.hasMoreTokens()) {
-                        currentType = (ComplexTypeMetadata) currentField.getType();
-                    }
+                    pathElements.add(tokenizer.nextToken());
+                }
+                currentField = findField(currentType, pathElements, 0);
+                if (currentField == null) {
+                    throw new IllegalArgumentException("Type '" + name + "' does not contain field '" + fieldName + "'.");
                 }
             }
             fieldPathCache.put(fieldName, currentField);
@@ -195,6 +197,25 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
         }
     }
 
+    private static FieldMetadata findField(ComplexTypeMetadata type, List<String> pathElements, int level) {
+        FieldMetadata field = type.getField(pathElements.get(level));
+        if (field == null) {
+            for (ComplexTypeMetadata subType : type.getSubTypes()) {
+                field = findField(subType, pathElements, level);
+                if (field != null) {
+                    return field;
+                }
+            }
+            return null;
+        } else {
+            if (level == pathElements.size() - 1) {
+                return field;
+            } else {
+                return findField((ComplexTypeMetadata) field.getType(), pathElements, level + 1);
+            }
+        }
+    }
+
     public boolean isInstantiable() {
         return isInstantiable;
     }
@@ -225,16 +246,30 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
         this.isInstantiable = isInstantiable;
     }
 
+    @Override
+    public ComplexTypeMetadata getEntity() {
+        if (getContainer() == null) {
+            return this;
+        } else {
+            return getContainer().getContainingType().getEntity();
+        }
+    }
+
+    @Override
+    public FieldMetadata getContainer() {
+        return containingField;
+    }
+
+    @Override
+    public void setContainer(FieldMetadata field) {
+        this.containingField = field;
+    }
+
     public Collection<FieldMetadata> getKeyFields() {
         return Collections.unmodifiableCollection(keyFields.values());
     }
 
     public Collection<FieldMetadata> getFields() {
-        if (!isFrozen) {
-            DefaultValidationHandler validationHandler = new DefaultValidationHandler();
-            freeze();
-            validationHandler.end();
-        }
         return Collections.unmodifiableCollection(fieldMetadata.values());
     }
 
@@ -246,14 +281,12 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
                 return true;
             }
         }
-
         // Checks in type inheritance hierarchy.
         for (TypeMetadata superType : superTypes) {
             if (superType.isAssignableFrom(type)) {
                 return true;
             }
         }
-
         return getName().equals(type.getName());
     }
 
@@ -286,20 +319,7 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
         keyFields.put(keyField.getName(), keyField);
     }
 
-    public ComplexTypeMetadata copy(MetadataRepository repository) {
-        ComplexTypeMetadata registeredCopy;
-        if (isInstantiable) {
-            registeredCopy = repository.getComplexType(getName());
-            if (registeredCopy != null) {
-                return registeredCopy;
-            }
-        } else {
-            registeredCopy = (ComplexTypeMetadata) repository.getNonInstantiableType(repository.getUserNamespace(), getName());
-            if (registeredCopy != null) {
-                return registeredCopy;
-            }
-        }
-
+    public ComplexTypeMetadata copy() {
         ComplexTypeMetadataImpl copy = new ComplexTypeMetadataImpl(getNamespace(),
                 getName(),
                 allowWrite,
@@ -308,22 +328,28 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
                 physicalDelete,
                 logicalDelete,
                 schematron,
-                primaryKeyInfo, Collections.<FieldMetadata>emptyList(), isInstantiable, workflowAccessRights);
-        repository.addTypeMetadata(copy);
-
+                primaryKeyInfo,
+                Collections.<FieldMetadata>emptyList(),
+                isInstantiable,
+                workflowAccessRights);
         Collection<FieldMetadata> fields = getFields();
         for (FieldMetadata field : fields) {
-            copy.addField(field.copy(repository));
+            copy.addField(field.copy());
         }
         for (TypeMetadata superType : superTypes) {
-            copy.addSuperType(superType.copy(repository), repository);
+            copy.addSuperType(superType);
+            if (superType instanceof ComplexTypeMetadata) {
+                ((ComplexTypeMetadata) superType).registerSubType(copy);
+            }
+        }
+        for (ComplexTypeMetadata subType : subTypes) {
+            copy.subTypes.add(subType);
         }
-
         Collection<FieldMetadata> typeKeyFields = getKeyFields();
         for (FieldMetadata typeKeyField : typeKeyFields) {
-            copy.registerKey(typeKeyField.copy(repository));
+            copy.registerKey(typeKeyField.copy());
         }
-
+        copy.isFrozen = false;
         return copy;
     }
 
@@ -381,6 +407,24 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
         return lookupFields;
     }
 
+    @Override
+    public void declareUsage(ContainedComplexTypeMetadata usage) {
+        usages.add(usage);
+    }
+
+    @Override
+    public void freezeUsages() {
+        for (ContainedComplexTypeMetadata usage : usages) {
+            usage.finalizeUsage();
+        }
+    }
+
+    @Override
+    public void setSubTypes(List<ComplexTypeMetadata> subTypes) {
+        this.subTypes.clear();
+        this.subTypes.addAll(subTypes);
+    }
+
     public boolean hasField(String fieldName) {
         if (fieldName == null || fieldName.isEmpty()) {
             return false;
@@ -449,7 +493,7 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
                     ((ComplexTypeMetadata) superType).registerSubType(this);
                     Collection<FieldMetadata> superTypeFields = ((ComplexTypeMetadata) superType).getFields();
                     for (FieldMetadata superTypeField : superTypeFields) {
-                        superTypeField.adopt(this, repository);
+                        superTypeField.adopt(this);
                     }
                 }
             }
@@ -493,16 +537,22 @@ public class ComplexTypeMetadataImpl extends MetadataExtensions implements Compl
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof ComplexTypeMetadata)) return false;
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof ComplexTypeMetadata)) {
+            return false;
+        }
         ComplexTypeMetadata that = (ComplexTypeMetadata) o;
-        return that.getName().equals(name) && that.getNamespace().equals(nameSpace);
+        if (!name.equals(that.getName())) return false;
+        if (nameSpace != null ? !nameSpace.equals(that.getNamespace()) : that.getNamespace() != null) return false;
+        return true;
     }
 
     @Override
     public int hashCode() {
-        int result = name.hashCode();
-        result = 31 * result + nameSpace.hashCode();
+        int result = nameSpace != null ? nameSpace.hashCode() : 0;
+        result = 31 * result + name.hashCode();
         return result;
     }
 }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/CompoundFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/CompoundFieldMetadata.java
index 272882c..dc954e5 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/CompoundFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/CompoundFieldMetadata.java
@@ -92,27 +92,32 @@ public class CompoundFieldMetadata extends MetadataExtensions implements FieldMe
 
     @Override
     public String getPath() {
-        throw new UnsupportedOperationException();
+        FieldMetadata containingField = getContainingType().getContainer();
+        if (containingField != null) {
+            return containingField.getPath() + '/' + getName();
+        } else {
+            return getName();
+        }
     }
 
     @Override
     public String getEntityTypeName() {
-        throw new UnsupportedOperationException();
+        return getContainingType().getEntity().getName();
     }
 
     public TypeMetadata getDeclaringType() {
         return fields[0].getDeclaringType();
     }
 
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
+    public void adopt(ComplexTypeMetadata metadata) {
         throw new UnsupportedOperationException();
     }
 
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         FieldMetadata[] fieldsCopy = new FieldMetadata[fields.length];
         int i = 0;
         for (FieldMetadata field : fields) {
-            fieldsCopy[i++] = field.copy(repository);
+            fieldsCopy[i++] = field.copy();
         }
         return new CompoundFieldMetadata(fieldsCopy);
     }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ConsoleDumpMetadataVisitor.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ConsoleDumpMetadataVisitor.java
index 0a316b7..e466ab8 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ConsoleDumpMetadataVisitor.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ConsoleDumpMetadataVisitor.java
@@ -13,7 +13,6 @@ package org.talend.mdm.commmon.metadata;
 
 import org.apache.log4j.Logger;
 
-import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -110,49 +109,34 @@ public class ConsoleDumpMetadataVisitor extends DefaultMetadataVisitor<Void> {
                 log("\t[FKInfo=" + fieldMetadata.getName() + "]"); //$NON-NLS-1$ //$NON-NLS-2$
             }
         }
+        log("\t[Full path: " + referenceField.getEntityTypeName() + "/" + referenceField.getPath() + "]");
         logUsers(referenceField);
         return null;
     }
 
     public Void visit(SimpleTypeFieldMetadata simpleField) {
         if (simpleField.isKey()) {
-            log("[Field (Simple) (Key)] " + simpleField.getName()); //$NON-NLS-1$
+            log("[Field (Simple) (Key) -> " + simpleField.getType().getName() + "] " + simpleField.getName()); //$NON-NLS-1$ //$NON-NLS-2$
         } else {
-            log("[Field (Simple)] " + simpleField.getName() + (simpleField.isMany() ? "*" : "")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+            log("[Field (Simple) -> " + simpleField.getType().getName() + "] " + simpleField.getName() + (simpleField.isMany() ? "*" : "")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
         }
         logUsers(simpleField);
+        log("\t[Full path:" + simpleField.getEntityTypeName() + "/" + simpleField.getPath() + "]");
         return null;
     }
 
     public Void visit(EnumerationFieldMetadata enumField) {
-        log("[Field (Enumeration)] " + enumField.getName()); //$NON-NLS-1$
+        log("[Field (Enumeration) -> " + enumField.getType().getName() + "] " + enumField.getName()); //$NON-NLS-1$ //$NON-NLS-2$
         logUsers(enumField);
-        return null;
-    }
-
-    @Override
-    public Void visit(ContainedComplexTypeMetadata containedType) {
-        if (processedTypes.contains(containedType)) {
-            return null;
-        } else {
-            processedTypes.add(containedType);
-        }
-        Collection<FieldMetadata> fields = containedType.getFields();
-        indent++;
-        {
-            for (FieldMetadata field : fields) {
-                field.accept(this);
-            }
-        }
-        indent--;
+        log("\t[Full path:" + enumField.getEntityTypeName() + "/" + enumField.getPath() + "]");
         return null;
     }
 
     @Override
     public Void visit(ContainedTypeFieldMetadata containedField) {
-        log("[Field (Contained type) -> " + containedField.getContainedType().getName() + ")] " + containedField.getName() + (containedField.isMany() ? "*" : ""));  //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+        log("[Field (Contained type) -> " + containedField.getContainedType().getName() + "] " + containedField.getName() + (containedField.isMany() ? "*" : ""));  //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
         logUsers(containedField);
-
+        log("\t[Full path:" + containedField.getEntityTypeName() + "/" + containedField.getPath() + "]");
         indent++;
         {
             containedField.getContainedType().accept(this);
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeMetadata.java
index 751d9e6..264824b 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeMetadata.java
@@ -11,45 +11,279 @@
 
 package org.talend.mdm.commmon.metadata;
 
-import org.apache.commons.lang.StringUtils;
+import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 
-import java.util.Collections;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
 
-/**
- * A "contained" type represents a type inside another type (but this type can not be used as MDM entity type). Usually
- * contained types are created for XSD anonymous types.
- */
-public class ContainedComplexTypeMetadata extends ComplexTypeMetadataImpl {
+public class ContainedComplexTypeMetadata implements ComplexTypeMetadata {
+
+    private ComplexTypeMetadata containedType;
+
+    private FieldMetadata container;
+
+    private boolean isFrozen;
+
+    private ContainedComplexTypeMetadata(ComplexTypeMetadata containedType, FieldMetadata container) {
+        this.containedType = containedType;
+        this.container = container;
+        if (containedType.getName().startsWith(MetadataRepository.ANONYMOUS_PREFIX)) {
+            this.containedType = (ComplexTypeMetadata) containedType.copy();
+            for (FieldMetadata field : this.containedType.getFields()) {
+                field.setContainingType(this);
+            }
+        } else {
+            this.containedType.declareUsage(this);
+        }
+    }
+
+    public static ComplexTypeMetadata contain(ComplexTypeMetadata type, FieldMetadata containingField) {
+        return new ContainedComplexTypeMetadata(type, containingField);
+    }
+
+    void finalizeUsage() {
+        containedType = (ComplexTypeMetadata) containedType.copy();
+        for (FieldMetadata field : containedType.getFields()) {
+            field.setContainingType(this);
+        }
+        List<ComplexTypeMetadata> subTypes = new LinkedList<ComplexTypeMetadata>();
+        for (ComplexTypeMetadata subType : containedType.getSubTypes()) {
+            ComplexTypeMetadata copy = (ComplexTypeMetadata) subType.copy();
+            ComplexTypeMetadata containedCopy = ContainedComplexTypeMetadata.contain(copy, container);
+            for (FieldMetadata subTypeField : copy.getFields()) {
+                subTypeField.setContainingType(containedCopy);
+            }
+            subTypes.add(containedCopy);
+        }
+        containedType.setSubTypes(subTypes);
+        containedType = (ComplexTypeMetadata) containedType.freeze();
+    }
+
+    @Override
+    public ComplexTypeMetadata getEntity() {
+        return container.getContainingType().getEntity();
+    }
+
+    @Override
+    public FieldMetadata getContainer() {
+        return container;
+    }
+
+    @Override
+    public void setContainer(FieldMetadata field) {
+        container = field;
+    }
+
+    @Override
+    public Collection<FieldMetadata> getKeyFields() {
+        return containedType.getKeyFields();
+    }
+
+    @Override
+    public void registerKey(FieldMetadata keyField) {
+        containedType.registerKey(keyField);
+    }
+
+    @Override
+    public FieldMetadata getField(String fieldName) {
+        return containedType.getField(fieldName);
+    }
+
+    @Override
+    public Collection<FieldMetadata> getFields() {
+        return containedType.getFields();
+    }
+
+    @Override
+    public void addField(FieldMetadata fieldMetadata) {
+        containedType.addField(fieldMetadata);
+    }
 
-    private final ComplexTypeMetadata containerType;
+    @Override
+    public List<String> getWriteUsers() {
+        return containedType.getWriteUsers();
+    }
 
-    public ContainedComplexTypeMetadata(ComplexTypeMetadata containerType, String nameSpace, String name) {
-        // Inherits permissions from container type.
-        super(nameSpace,
-                name,
-                containerType.getWriteUsers(),
-                containerType.getDenyCreate(),
-                containerType.getHideUsers(),
-                containerType.getDenyDelete(DeleteType.PHYSICAL),
-                containerType.getDenyDelete(DeleteType.LOGICAL),
-                StringUtils.EMPTY,
-                Collections.<FieldMetadata>emptyList(),
-                Collections.<FieldMetadata>emptyList(),
-                false,
-                containerType.getWorkflowAccessRights());
-        this.containerType = containerType;
+    @Override
+    public List<String> getHideUsers() {
+        return containedType.getHideUsers();
     }
 
-    /**
-     * @return The {@link ComplexTypeMetadata} that contains this type. Please note that container type might also be
-     *         a contained type.
-     */
-    public ComplexTypeMetadata getContainerType() {
-        return containerType;
+    @Override
+    public List<String> getDenyCreate() {
+        return containedType.getDenyCreate();
+    }
+
+    @Override
+    public List<String> getDenyDelete(DeleteType type) {
+        return containedType.getDenyDelete(type);
+    }
+
+    @Override
+    public List<String> getWorkflowAccessRights() {
+        return containedType.getWorkflowAccessRights();
+    }
+
+    @Override
+    public String getSchematron() {
+        return containedType.getSchematron();
+    }
+
+    @Override
+    public List<FieldMetadata> getPrimaryKeyInfo() {
+        return containedType.getPrimaryKeyInfo();
+    }
+
+    @Override
+    public boolean hasField(String fieldName) {
+        return containedType.hasField(fieldName);
+    }
+
+    @Override
+    public Collection<ComplexTypeMetadata> getSubTypes() {
+        return containedType.getSubTypes();
+    }
+
+    @Override
+    public void registerSubType(ComplexTypeMetadata type) {
+        containedType.registerSubType(type);
+    }
+
+    @Override
+    public List<FieldMetadata> getLookupFields() {
+        return containedType.getLookupFields();
+    }
+
+    @Override
+    public void declareUsage(ContainedComplexTypeMetadata usage) {
+    }
+
+    @Override
+    public void freezeUsages() {
+    }
+
+    @Override
+    public void setSubTypes(List<ComplexTypeMetadata> subTypes) {
+        containedType.setSubTypes(subTypes);
+    }
+
+    @Override
+    public Collection<TypeMetadata> getSuperTypes() {
+        return containedType.getSuperTypes();
+    }
+
+    @Override
+    public void addSuperType(TypeMetadata superType) {
+        containedType.addSuperType(superType);
+    }
+
+    @Override
+    public String getName() {
+        return containedType.getName();
+    }
+
+    @Override
+    public void setName(String name) {
+        containedType.setName(name);
+    }
+
+    @Override
+    public String getNamespace() {
+        return containedType.getNamespace();
+    }
+
+    @Override
+    public boolean isAssignableFrom(TypeMetadata type) {
+        return containedType.isAssignableFrom(type);
+    }
+
+    @Override
+    public TypeMetadata copy() {
+        return containedType.copy();
+    }
+
+    @Override
+    public TypeMetadata copyShallow() {
+        return containedType.copyShallow();
+    }
+
+    @Override
+    public TypeMetadata freeze() {
+        if (!isFrozen) {
+            isFrozen = true;
+            containedType = (ComplexTypeMetadata) containedType.freeze();
+            if (containedType != null) {
+                containedType.declareUsage(this);
+            }
+        }
+        return this;
+    }
+
+    @Override
+    public boolean isInstantiable() {
+        return containedType.isInstantiable();
+    }
+
+    @Override
+    public void setInstantiable(boolean isInstantiable) {
+        containedType.setInstantiable(isInstantiable);
+    }
+
+    @Override
+    public boolean isFrozen() {
+        return containedType.isFrozen();
+    }
+
+    @Override
+    public void validate(ValidationHandler handler) {
+        containedType.validate(handler);
+    }
+
+    @Override
+    public ValidationRule createValidationRule() {
+        return containedType.createValidationRule();
     }
 
     @Override
     public <T> T accept(MetadataVisitor<T> visitor) {
         return visitor.visit(this);
     }
+
+    @Override
+    public void setData(String key, Object data) {
+        containedType.setData(key, data);
+    }
+
+    @Override
+    public <X> X getData(String key) {
+        return containedType.getData(key);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof ContainedComplexTypeMetadata)) return false;
+
+        ContainedComplexTypeMetadata that = (ContainedComplexTypeMetadata) o;
+
+        if (!container.getContainingType().equals(that.container.getContainingType())) return false;
+        if (!container.getName().equals(that.container.getName())) return false;
+        if (!containedType.equals(that.containedType)) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = containedType.hashCode();
+        result = 31 * result + container.getContainingType().hashCode();
+        result = 31 * result + container.getName().hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Contained([" + containedType.getNamespace() + ':' + containedType.getName() + "], container=" + container.getName() + ')';
+    }
 }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeRef.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeRef.java
index 7aca5e1..e69de29 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeRef.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedComplexTypeRef.java
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2006-2013 Talend Inc. - www.talend.com
- *
- * This source code is available under agreement available at
- * %InstallDIR%\features\org.talend.rcp.branding.%PRODUCTNAME%\%PRODUCTNAME%license.txt
- *
- * You should have received a copy of the agreement
- * along with this program; if not, write to Talend SA
- * 9 rue Pages 92150 Suresnes, France
- */
-
-package org.talend.mdm.commmon.metadata;
-
-import java.util.Collection;
-import java.util.LinkedList;
-import java.util.List;
-
-/**
- * Represents a contained type (in a sense of nested contained type in a MDM entity type) but in this case actual type
- * definition is located in a shared type of the {@link MetadataRepository}. This happens when a type declares a element
- * of a type that is not a MDM entity type.
- */
-public class ContainedComplexTypeRef extends ContainedComplexTypeMetadata {
-
-    private ComplexTypeMetadata reference;
-
-    public ContainedComplexTypeRef(ComplexTypeMetadata containerType, String nameSpace, String name, ComplexTypeMetadata reference) {
-        super(containerType, nameSpace, name);
-        this.reference = reference;
-    }
-
-    @Override
-    public FieldMetadata getField(String fieldName) {
-        return reference.getField(fieldName);
-    }
-
-    @Override
-    public boolean hasField(String fieldName) {
-        return reference.hasField(fieldName);
-    }
-
-    @Override
-    public void addField(FieldMetadata fieldMetadata) {
-    }
-
-    @Override
-    public Collection<TypeMetadata> getSuperTypes() {
-        return reference.getSuperTypes();
-    }
-
-    @Override
-    public Collection<FieldMetadata> getFields() {
-        return reference.getFields();
-    }
-
-    @Override
-    public TypeMetadata freeze() {
-        reference = (ComplexTypeMetadata) reference.freeze();
-        return this;
-    }
-
-    @Override
-    public String getName() {
-        return reference.getName();
-    }
-
-    @Override
-    public String getNamespace() {
-        return reference.getNamespace();
-    }
-
-    @Override
-    public boolean isAssignableFrom(TypeMetadata type) {
-        return reference.isAssignableFrom(type);
-    }
-
-    @Override
-    public Collection<ComplexTypeMetadata> getSubTypes() {
-        List<ComplexTypeMetadata> subTypes = new LinkedList<ComplexTypeMetadata>();
-        for (ComplexTypeMetadata subType : reference.getSubTypes()) {
-            subTypes.add(subType);
-            subTypes.addAll(subType.getSubTypes());
-        }
-        return subTypes;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o){
-            return true;
-        }
-        if (ContainedComplexTypeRef.class.equals(o.getClass())){
-            ContainedComplexTypeRef ref = (ContainedComplexTypeRef) o;
-            return ref.reference.getClass().equals(reference.getClass()) && reference.equals(ref.reference);
-        }
-        return o.getClass().equals(reference.getClass()) && reference.equals(o);
-    }
-
-    @Override
-    public int hashCode() {
-        return reference.hashCode();
-    }
-}
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedTypeFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedTypeFieldMetadata.java
index 2792a7f..cf6ac1c 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedTypeFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ContainedTypeFieldMetadata.java
@@ -11,12 +11,10 @@
 
 package org.talend.mdm.commmon.metadata;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.validation.CompositeValidationRule;
 import org.talend.mdm.commmon.metadata.validation.ValidationFactory;
 import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.List;
@@ -38,11 +36,9 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
 
     private final boolean isMandatory;
 
-    private final String path;
-
     private TypeMetadata declaringType;
 
-    private ContainedComplexTypeMetadata fieldType;
+    private ComplexTypeMetadata fieldType;
 
     private ComplexTypeMetadata containingType;
 
@@ -54,16 +50,15 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
                                       boolean isMany,
                                       boolean isMandatory,
                                       String name,
-                                      ContainedComplexTypeMetadata fieldType,
+                                      ComplexTypeMetadata fieldType,
                                       List<String> allowWriteUsers,
                                       List<String> hideUsers,
-                                      List<String> workflowAccessRights,
-                                      String path) {
+                                      List<String> workflowAccessRights) {
         if (fieldType == null) {
             throw new IllegalArgumentException("Contained type cannot be null.");
         }
         this.isMandatory = isMandatory;
-        this.fieldType = fieldType;
+        this.fieldType = ContainedComplexTypeMetadata.contain(fieldType, this);
         this.containingType = containingType;
         this.declaringType = containingType;
         this.isMany = isMany;
@@ -71,7 +66,6 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
         this.allowWriteUsers = allowWriteUsers;
         this.hideUsers = hideUsers;
         this.workflowAccessRights = workflowAccessRights;
-        this.path = path;
     }
 
     public String getName() {
@@ -99,7 +93,7 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
             return this;
         }
         isFrozen = true;
-        fieldType = (ContainedComplexTypeMetadata) fieldType.freeze();
+        fieldType = (ComplexTypeMetadata) fieldType.freeze();
         return this;
     }
 
@@ -125,25 +119,30 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
 
     @Override
     public String getPath() {
-        return StringUtils.substringAfter(path, "/"); //$NON-NLS-1$
+        FieldMetadata containingField = containingType.getContainer();
+        if (containingField != null) {
+            return containingField.getPath() + '/' + name;
+        } else {
+            return name;
+        }
     }
 
     @Override
     public String getEntityTypeName() {
-        return StringUtils.substringBefore(path, "/"); //$NON-NLS-1$
+        return containingType.getEntity().getName();
     }
 
     public TypeMetadata getDeclaringType() {
         return declaringType;
     }
 
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        FieldMetadata copy = copy(repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        FieldMetadata copy = copy();
         copy.setContainingType(metadata);
         metadata.addField(copy);
     }
 
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         return new ContainedTypeFieldMetadata(containingType,
                 isMany,
                 isMandatory,
@@ -151,8 +150,7 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
                 fieldType,
                 allowWriteUsers,
                 hideUsers,
-                workflowAccessRights,
-                path);
+                workflowAccessRights);
     }
 
     public List<String> getHideUsers() {
@@ -190,7 +188,7 @@ public class ContainedTypeFieldMetadata extends MetadataExtensions implements Fi
                 '}';   //$NON-NLS-1$
     }
 
-    public ContainedComplexTypeMetadata getContainedType() {
+    public ComplexTypeMetadata getContainedType() {
         return fieldType;
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/EnumerationFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/EnumerationFieldMetadata.java
index 10f7ad5..1fc6075 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/EnumerationFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/EnumerationFieldMetadata.java
@@ -11,7 +11,6 @@
 
 package org.talend.mdm.commmon.metadata;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.validation.ValidationFactory;
 import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 
@@ -29,7 +28,7 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
     private final List<String> allowWriteUsers;
 
     private final List<String> hideUsers;
-    
+
     private final List<String> workflowAccessRights;
 
     private TypeMetadata declaringType;
@@ -38,8 +37,6 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
 
     private final boolean isMandatory;
 
-    private final String path;
-
     private ComplexTypeMetadata containingType;
 
     private String name;
@@ -54,8 +51,7 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
                                     TypeMetadata fieldType,
                                     List<String> allowWriteUsers,
                                     List<String> hideUsers,
-                                    List<String> workflowAccessRights,
-                                    String path) {
+                                    List<String> workflowAccessRights) {
         this.containingType = containingType;
         this.declaringType = containingType;
         this.isKey = isKey;
@@ -66,7 +62,6 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
         this.allowWriteUsers = allowWriteUsers;
         this.hideUsers = hideUsers;
         this.workflowAccessRights = workflowAccessRights;
-        this.path = path;
     }
 
     public String getName() {
@@ -114,25 +109,29 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
 
     @Override
     public String getPath() {
-        return StringUtils.substringAfter(path, "/"); //$NON-NLS-1$
+        FieldMetadata containingField = containingType.getContainer();
+        if (containingField != null) {
+            return containingField.getPath() + '/' + name;
+        } else {
+            return name;
+        }
     }
 
     @Override
     public String getEntityTypeName() {
-        return StringUtils.substringBefore(path, "/"); //$NON-NLS-1$
+        return containingType.getEntity().getName();
     }
 
     public TypeMetadata getDeclaringType() {
         return declaringType;
     }
 
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        FieldMetadata copy = copy(repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        FieldMetadata copy = copy();
         copy.setContainingType(metadata);
-        metadata.addField(copy);
     }
 
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         return new EnumerationFieldMetadata(containingType,
                 isKey(),
                 isMany,
@@ -141,8 +140,7 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
                 fieldType,
                 allowWriteUsers,
                 hideUsers,
-                workflowAccessRights,
-                path);
+                workflowAccessRights);
     }
 
     public List<String> getHideUsers() {
@@ -156,7 +154,7 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
     public List<String> getWorkflowAccessRights() {
         return this.workflowAccessRights;
     }
-    
+
     public boolean isMany() {
         return isMany;
     }
@@ -203,7 +201,8 @@ public class EnumerationFieldMetadata extends MetadataExtensions implements Fiel
         if (fieldType != null ? !fieldType.equals(that.fieldType) : that.fieldType != null) return false;
         if (hideUsers != null ? !hideUsers.equals(that.hideUsers) : that.hideUsers != null) return false;
         if (name != null ? !name.equals(that.name) : that.name != null) return false;
-        if (workflowAccessRights != null ? !workflowAccessRights.equals(that.workflowAccessRights) : that.workflowAccessRights != null) return false;
+        if (workflowAccessRights != null ? !workflowAccessRights.equals(that.workflowAccessRights) : that.workflowAccessRights != null)
+            return false;
 
         return true;
     }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/FieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/FieldMetadata.java
index 87ea63e..2e90779 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/FieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/FieldMetadata.java
@@ -80,19 +80,17 @@ public interface FieldMetadata extends MetadataVisitable, MetadataExtensible {
     /**
      * "Adopt" this field in <code>metadata</code> type. This method performs all necessary operations so this field
      * behaves as is field was declared in <code>metadata</code>.
-     * 
+     *
      * @param metadata The new type.
-     * @param repository The {@link MetadataRepository} of the type to adopt.
      */
-    void adopt(ComplexTypeMetadata metadata, MetadataRepository repository);
+    void adopt(ComplexTypeMetadata metadata);
 
     /**
      * Copy the field and all depending information in <code>repository</code>.
      * 
-     * @param repository The {@link MetadataRepository} to copy to.
      * @return A copy of this field.
      */
-    FieldMetadata copy(MetadataRepository repository);
+    FieldMetadata copy();
 
     /**
      * Changes containing type for this field. Use this method with extra caution.
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/MetadataRepository.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/MetadataRepository.java
index d7789be..d878ea9 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/MetadataRepository.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/MetadataRepository.java
@@ -65,25 +65,24 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
 
     private final Stack<ComplexTypeMetadata> currentTypeStack = new Stack<ComplexTypeMetadata>();
 
-    private final Stack<String> currentPath = new Stack<String>();
-
     private String targetNamespace;
 
     private int anonymousCounter = 0;
 
     public MetadataRepository() {
+        NoOpValidationHandler noOpValidationHandler = new NoOpValidationHandler();
         // Load XML Schema types
         InputStream xmlSchemaDef = MetadataRepository.class.getResourceAsStream("XMLSchema.xsd"); //$NON-NLS-1$
         if (xmlSchemaDef == null) {
             throw new IllegalStateException("Could not find XML schema definition.");
         }
-        load(xmlSchemaDef, new NoOpValidationHandler());
+        load(xmlSchemaDef, noOpValidationHandler);
         // TMDM-4444: Adds standard Talend types such as UUID.
         InputStream internalTypes = MetadataRepository.class.getResourceAsStream("talend_types.xsd"); //$NON-NLS-1$
         if (internalTypes == null) {
             throw new IllegalStateException("Could not find internal type data model.");
         }
-        load(internalTypes);
+        load(internalTypes, noOpValidationHandler);
     }
 
     public TypeMetadata getType(String name) {
@@ -200,11 +199,13 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         }
         XmlSchemaWalker.walk(schema, this);
         // TMDM-4876 Additional processing for entity inheritance
-        resolveAdditionalSuperTypes(this, handler);
-        // "Freeze" all types (a consequence of this will be validation of all fields).
+        resolveAdditionalSuperTypes(this);
+        // "Freeze" all types (ensure all soft references now point to actual types in the repository).
         nonInstantiableTypes.put(getUserNamespace(), freezeTypes(nonInstantiableTypes.get(getUserNamespace())));
         entityTypes.put(getUserNamespace(), freezeTypes(entityTypes.get(getUserNamespace())));
-        // Validates data model
+        // "Freeze" all reusable type usages in the data model.
+        freezeUsages(nonInstantiableTypes.get(getUserNamespace()));
+        freezeUsages(entityTypes.get(getUserNamespace()));
         for (TypeMetadata type : getUserComplexTypes()) {
             if (!XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(type.getNamespace())) {
                 type.validate(handler);
@@ -221,6 +222,17 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         }
     }
 
+    private void freezeUsages(Map<String, TypeMetadata> types) {
+        if (types == null) {
+            return;
+        }
+        for (TypeMetadata type : types.values()) {
+            if (type instanceof ComplexTypeMetadata) {
+                ((ComplexTypeMetadata) type).freezeUsages();
+            }
+        }
+    }
+
     private Map<String, TypeMetadata> freezeTypes(Map<String, TypeMetadata> typesToFreeze) {
         if (typesToFreeze == null) {
             return null;
@@ -232,32 +244,25 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         return workingTypes;
     }
 
-    private static void resolveAdditionalSuperTypes(MetadataRepository repository, ValidationHandler handler) {
+    private static void resolveAdditionalSuperTypes(MetadataRepository repository) {
         Collection<ComplexTypeMetadata> types = repository.getUserComplexTypes();
         for (TypeMetadata current : types) {
             String complexTypeName = current.getData(COMPLEX_TYPE_NAME);
             if (complexTypeName != null) {
                 TypeMetadata nonInstantiableType = repository.getNonInstantiableType(USER_NAMESPACE, complexTypeName);
                 if (!nonInstantiableType.getSuperTypes().isEmpty()) {
-                    // TODO Move to validation rule
-                    if (nonInstantiableType.getSuperTypes().size() > 1) {
-                        handler.error(nonInstantiableType,
-                                "Multiple inheritance is not supported.",
-                                nonInstantiableType.<Element>getData(MetadataRepository.XSD_DOM_ELEMENT),
-                                nonInstantiableType.<Integer>getData(MetadataRepository.XSD_LINE_NUMBER),
-                                nonInstantiableType.<Integer>getData(MetadataRepository.XSD_COLUMN_NUMBER),
-                                ValidationError.MULTIPLE_INHERITANCE_NOT_ALLOWED);
-                    }
-                    TypeMetadata superType = nonInstantiableType.getSuperTypes().iterator().next();
-                    ComplexTypeMetadata entitySuperType = null;
-                    for (TypeMetadata entity : types) {
-                        if (superType.getName().equals(entity.getData(COMPLEX_TYPE_NAME))) {
-                            entitySuperType = (ComplexTypeMetadata) entity;
-                            break;
+                    if (!nonInstantiableType.getSuperTypes().isEmpty() && !nonInstantiableType.isFrozen()) {
+                        TypeMetadata superType = nonInstantiableType.getSuperTypes().iterator().next();
+                        ComplexTypeMetadata entitySuperType = null;
+                        for (TypeMetadata entity : types) {
+                            if (superType.getName().equals(entity.getData(COMPLEX_TYPE_NAME))) {
+                                entitySuperType = (ComplexTypeMetadata) entity;
+                                break;
+                            }
+                        }
+                        if (entitySuperType != null) {
+                            current.addSuperType(entitySuperType);
                         }
-                    }
-                    if (entitySuperType != null) {
-                        current.addSuperType(entitySuperType, repository);
                     }
                 }
             }
@@ -348,7 +353,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         }
         if (getNonInstantiableType(targetNamespace, typeName) == null) {
             for (TypeMetadata superType : superTypes) {
-                typeMetadata.addSuperType(superType, this);
+                typeMetadata.addSuperType(superType);
             }
             addTypeMetadata(typeMetadata);
         }
@@ -403,7 +408,10 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                         contentModel.getTargetNamespace(),
                         contentModel.getName(),
                         false);
-                currentTypeStack.peek().addSuperType(superType, this);
+                if (currentTypeStack.peek() instanceof ContainedComplexTypeMetadata) {
+                    superType.declareUsage((ContainedComplexTypeMetadata) currentTypeStack.peek());
+                }
+                currentTypeStack.peek().addSuperType(superType);
                 particle = type.getContent();
                 if (particle instanceof XSDParticle) {
                     XSDParticle currentParticle = (XSDParticle) particle;
@@ -427,7 +435,6 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
 
     @Override
     public void visitElement(XSDElementDeclaration element) {
-        currentPath.push(element.getName());
         if (currentTypeStack.isEmpty()) { // "top level" elements means new MDM entity type
             String typeName = element.getName();
             if (entityTypes.get(getUserNamespace()) != null) {
@@ -495,7 +502,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                             substitutionGroup.getTargetNamespace(),
                             substitutionGroup.getName(),
                             true);
-                    type.addSuperType(superType, this);
+                    type.addSuperType(superType);
                 }
             }
             // Register keys (TMDM-4470).
@@ -533,10 +540,8 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
             }
             currentTypeStack.peek().addField(fieldMetadata);
         }
-        currentPath.pop();
     }
 
-    // TODO To refactor once test coverage is good.
     private FieldMetadata createFieldMetadata(XSDElementDeclaration element,
                                               ComplexTypeMetadata containingType,
                                               int minOccurs,
@@ -570,7 +575,6 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         List<String> hideUsers = state.getHide();
         List<String> allowWriteUsers = state.getAllowWrite();
         List<String> workflowAccessRights = state.getWorkflowAccessRights();
-        // TODO If allowWriteUsers is empty, put ICoreConstants.admin???
         XSDTypeDefinition schemaType = element.getType();
         if (schemaType instanceof XSDSimpleTypeDefinition) {
             XSDSimpleTypeDefinition simpleSchemaType = (XSDSimpleTypeDefinition) schemaType;
@@ -595,8 +599,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                         fieldType,
                         allowWriteUsers,
                         hideUsers,
-                        workflowAccessRights,
-                        getCurrentPath());
+                        workflowAccessRights);
                 referenceField.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
                 referenceField.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
                 referenceField.setData(XSD_DOM_ELEMENT, element.getElement());
@@ -631,8 +634,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                                 fieldType,
                                 allowWriteUsers,
                                 hideUsers,
-                                workflowAccessRights,
-                                getCurrentPath());
+                                workflowAccessRights);
                         enumField.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
                         enumField.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
                         enumField.setData(XSD_DOM_ELEMENT, element.getElement());
@@ -646,8 +648,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                                 fieldType,
                                 allowWriteUsers,
                                 hideUsers,
-                                workflowAccessRights,
-                                getCurrentPath());
+                                workflowAccessRights);
                         field.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
                         field.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
                         field.setData(XSD_DOM_ELEMENT, element.getElement());
@@ -662,8 +663,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                             fieldType,
                             allowWriteUsers,
                             hideUsers,
-                            workflowAccessRights,
-                            getCurrentPath());
+                            workflowAccessRights);
                     field.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
                     field.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
                     field.setData(XSD_DOM_ELEMENT, element.getElement());
@@ -676,18 +676,17 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
             if (qName != null) {
                 TypeMetadata metadata = getType(element.getType().getTargetNamespace(), element.getType().getName());
                 if (metadata != null) {
-                    referencedType = new ContainedComplexTypeRef(currentTypeStack.peek(), targetNamespace, element.getName(), new SoftTypeRef(this, targetNamespace, schemaType.getName(), false));
+                    fieldType = new SoftTypeRef(this, targetNamespace, schemaType.getName(), false);
                     isContained = true;
                 } else {
                     if (schemaType == null) {
                         throw new IllegalArgumentException("Field '" + fieldName + "' from type '" + containingType.getName() + "' has an invalid type.");
                     }
                     if (schemaType instanceof XSDComplexTypeDefinition) {
-                        referencedType = new ContainedComplexTypeRef(currentTypeStack.peek(), targetNamespace, element.getName(), new SoftTypeRef(this, targetNamespace, schemaType.getName(), false));
+                        fieldType = new SoftTypeRef(this, schemaType.getTargetNamespace(), schemaType.getName(), false);
                         isContained = true;
                     } else if (schemaType instanceof XSDSimpleTypeDefinition) {
                         fieldType = new SoftTypeRef(this, schemaType.getTargetNamespace(), schemaType.getName(), false);
-                        XmlSchemaWalker.walk(schemaType, this);
                     } else {
                         throw new NotImplementedException("Support for '" + schemaType.getClass() + "'.");
                     }
@@ -696,17 +695,11 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                 isContained = true;
                 XSDElementDeclaration refName = element.getResolvedElementDeclaration();
                 if (schemaType != null) {
-                    referencedType = new ContainedComplexTypeMetadata(currentTypeStack.peek(), targetNamespace, ANONYMOUS_PREFIX + String.valueOf(anonymousCounter++));
-                    fieldType = referencedType;
+                    fieldType = new ComplexTypeMetadataImpl(targetNamespace, ANONYMOUS_PREFIX + String.valueOf(anonymousCounter++), false);
                     isContained = true;
-                    currentTypeStack.push((ComplexTypeMetadata) referencedType);
-                    XmlSchemaWalker.walk(schemaType, this);
-                    currentTypeStack.pop();
                 } else if (refName != null) {
                     // Reference being an element, consider references as references to entity type.
-                    SoftTypeRef reference = new SoftTypeRef(this, refName.getTargetNamespace(), refName.getName(), true);
-                    referencedType = new ContainedComplexTypeRef(currentTypeStack.peek(), targetNamespace, element.getName(), reference);
-                    fieldType = referencedType;
+                    fieldType = new SoftTypeRef(this, refName.getTargetNamespace(), refName.getName(), true);
                 } else {
                     throw new NotImplementedException();
                 }
@@ -717,14 +710,20 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                     isMany,
                     isMandatory,
                     fieldName,
-                    (ContainedComplexTypeMetadata) referencedType,
+                    (ComplexTypeMetadata) fieldType,
                     allowWriteUsers,
                     hideUsers,
-                    workflowAccessRights,
-                    getCurrentPath());
+                    workflowAccessRights);
             containedField.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
             containedField.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
             containedField.setData(XSD_DOM_ELEMENT, element.getElement());
+            if (fieldType.getName().startsWith(ANONYMOUS_PREFIX)) {
+                currentTypeStack.push((ComplexTypeMetadata) containedField.getType());
+                {
+                    XmlSchemaWalker.walk(schemaType, this);
+                }
+                currentTypeStack.pop();
+            }
             return containedField;
         } else {
             FieldMetadata field = new SimpleTypeFieldMetadata(containingType,
@@ -735,8 +734,7 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
                     fieldType,
                     allowWriteUsers,
                     hideUsers,
-                    workflowAccessRights,
-                    getCurrentPath());
+                    workflowAccessRights);
             field.setData(XSD_LINE_NUMBER, XSDParser.getStartLine(element.getElement()));
             field.setData(XSD_COLUMN_NUMBER, XSDParser.getStartColumn(element.getElement()));
             field.setData(XSD_DOM_ELEMENT, element.getElement());
@@ -744,18 +742,6 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
         }
     }
 
-    private String getCurrentPath() {
-        StringBuilder path = new StringBuilder();
-        Iterator<String> iterator = currentPath.iterator();
-        while (iterator.hasNext()) {
-            path.append(iterator.next());
-            if (iterator.hasNext()) {
-                path.append('/');
-            }
-        }
-        return path.toString();
-    }
-
     private static class NoOpValidationHandler implements ValidationHandler {
         @Override
         public void error(TypeMetadata type, String message, Element element, Integer lineNumber, Integer columnNumber, ValidationError error) {
@@ -797,4 +783,4 @@ public class MetadataRepository implements MetadataVisitable, XSDVisitor, Serial
             return 0;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ReferenceFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ReferenceFieldMetadata.java
index afd08c8..c62093f 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ReferenceFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/ReferenceFieldMetadata.java
@@ -11,7 +11,6 @@
 
 package org.talend.mdm.commmon.metadata;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.validation.ValidationFactory;
 import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 import org.w3c.dom.Element;
@@ -38,8 +37,6 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
 
     private final TypeMetadata declaringType;
 
-    private final String path;
-
     private TypeMetadata fieldType;
 
     private boolean isKey;
@@ -68,8 +65,7 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
                                   boolean allowFKIntegrityOverride,
                                   TypeMetadata fieldType,
                                   List<String> allowWriteUsers,
-                                  List<String> hideUsers,
-                                  String path) {
+                                  List<String> hideUsers) {
         this(containingType,
                 isKey,
                 isMany,
@@ -83,8 +79,7 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
                 fieldType,
                 allowWriteUsers,
                 hideUsers,
-                Collections.<String>emptyList(),
-                path);
+                Collections.<String>emptyList());
     }
 
     public ReferenceFieldMetadata(ComplexTypeMetadata containingType,
@@ -100,8 +95,7 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
                                   TypeMetadata fieldType,
                                   List<String> allowWriteUsers,
                                   List<String> hideUsers,
-                                  List<String> workflowAccessRights,
-                                  String path) {
+                                  List<String> workflowAccessRights) {
         this.isMandatory = isMandatory;
         this.name = name;
         this.referencedField = referencedField;
@@ -118,7 +112,6 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
         this.writeUsers = allowWriteUsers;
         this.hideUsers = hideUsers;
         this.workflowAccessRights = workflowAccessRights;
-        this.path = path;
     }
 
     public FieldMetadata getReferencedField() {
@@ -193,12 +186,17 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
 
     @Override
     public String getPath() {
-        return StringUtils.substringAfter(path, "/"); //$NON-NLS-1$
+        FieldMetadata containingField = containingType.getContainer();
+        if (containingField != null) {
+            return containingField.getPath() + '/' + name;
+        } else {
+            return name;
+        }
     }
 
     @Override
     public String getEntityTypeName() {
-        return StringUtils.substringBefore(path, "/"); //$NON-NLS-1$
+        return containingType.getEntity().getName();
     }
 
     public TypeMetadata getDeclaringType() {
@@ -213,8 +211,8 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
         return allowFKIntegrityOverride;
     }
 
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        FieldMetadata copy = copy(repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        FieldMetadata copy = copy();
         copy.setContainingType(metadata);
         metadata.addField(copy);
     }
@@ -231,19 +229,19 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
         return visitor.visit(this);
     }
 
-    public FieldMetadata copy(MetadataRepository repository) {
-        ComplexTypeMetadata referencedTypeCopy = (ComplexTypeMetadata) referencedType.copy(repository);
-        FieldMetadata referencedFieldCopy = referencedField.copy(repository);
+    public FieldMetadata copy() {
+        ComplexTypeMetadata referencedTypeCopy = referencedType;
+        FieldMetadata referencedFieldCopy = referencedField.copy();
         List<FieldMetadata> foreignKeyInfoCopy;
         if (hasForeignKeyInfo()) {
             foreignKeyInfoCopy = new ArrayList<FieldMetadata>(foreignKeyInfoFields.size());
             for (FieldMetadata foreignKeyInfoField : foreignKeyInfoFields) {
-                foreignKeyInfoCopy.add(foreignKeyInfoField.copy(repository));
+                foreignKeyInfoCopy.add(foreignKeyInfoField.copy());
             }
         } else {
             foreignKeyInfoCopy = Collections.emptyList();
         }
-        ComplexTypeMetadata containingTypeCopy = (ComplexTypeMetadata) containingType.copy(repository);
+        ComplexTypeMetadata containingTypeCopy = (ComplexTypeMetadata) containingType.copyShallow();
         return new ReferenceFieldMetadata(containingTypeCopy,
                 isKey,
                 isMany,
@@ -257,8 +255,7 @@ public class ReferenceFieldMetadata extends MetadataExtensions implements FieldM
                 fieldType,
                 writeUsers,
                 hideUsers,
-                workflowAccessRights,
-                path);
+                workflowAccessRights);
     }
 
     @Override
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeFieldMetadata.java
index 5816e5c..6531ab9 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeFieldMetadata.java
@@ -11,11 +11,9 @@
 
 package org.talend.mdm.commmon.metadata;
 
-import org.apache.commons.lang.StringUtils;
 import org.talend.mdm.commmon.metadata.validation.ValidationFactory;
 import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -35,8 +33,6 @@ public class SimpleTypeFieldMetadata extends MetadataExtensions implements Field
 
     private final boolean isMandatory;
 
-    private final String path;
-
     private TypeMetadata fieldType;
 
     private boolean isKey;
@@ -57,8 +53,7 @@ public class SimpleTypeFieldMetadata extends MetadataExtensions implements Field
                                    TypeMetadata fieldType,
                                    List<String> allowWriteUsers,
                                    List<String> hideUsers,
-                                   List<String> workflowAccessRights,
-                                   String path) {
+                                   List<String> workflowAccessRights) {
         if (fieldType == null) {
             throw new IllegalArgumentException("Field type cannot be null.");
         }
@@ -72,7 +67,6 @@ public class SimpleTypeFieldMetadata extends MetadataExtensions implements Field
         this.allowWriteUsers = allowWriteUsers;
         this.hideUsers = hideUsers;
         this.workflowAccessRights = workflowAccessRights;
-        this.path = path;
     }
 
     public String getName() {
@@ -126,26 +120,31 @@ public class SimpleTypeFieldMetadata extends MetadataExtensions implements Field
 
     @Override
     public String getPath() {
-        return StringUtils.substringAfter(path, "/"); //$NON-NLS-1$
+        FieldMetadata container = containingType.getContainer();
+        if (container != null) {
+            return container.getPath() + '/' + name;
+        } else {
+            return name;
+        }
     }
 
     @Override
     public String getEntityTypeName() {
-        return StringUtils.substringBefore(path, "/"); //$NON-NLS-1$
+        return containingType.getEntity().getName();
     }
 
     public TypeMetadata getDeclaringType() {
         return declaringType;
     }
 
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        FieldMetadata copy = copy(repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        FieldMetadata copy = copy();
         copy.setContainingType(metadata);
         metadata.addField(copy);
     }
 
-    public FieldMetadata copy(MetadataRepository repository) {
-        return new SimpleTypeFieldMetadata(containingType,
+    public FieldMetadata copy() {
+        SimpleTypeFieldMetadata copy = new SimpleTypeFieldMetadata(containingType,
                 isKey,
                 isMany,
                 isMandatory,
@@ -153,7 +152,9 @@ public class SimpleTypeFieldMetadata extends MetadataExtensions implements Field
                 fieldType,
                 allowWriteUsers,
                 hideUsers,
-                workflowAccessRights, path);
+                workflowAccessRights);
+        copy.setDeclaringType(declaringType);
+        return copy;
     }
 
     public List<String> getHideUsers() {
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeMetadata.java
index 0cab529..758152e 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SimpleTypeMetadata.java
@@ -72,10 +72,10 @@ public class SimpleTypeMetadata extends MetadataExtensions implements TypeMetada
         return getName().equals(type.getName());
     }
 
-    public TypeMetadata copy(MetadataRepository repository) {
+    public TypeMetadata copy() {
         SimpleTypeMetadata copy = new SimpleTypeMetadata(nameSpace, name);
         for (TypeMetadata superType : superTypes) {
-            copy.addSuperType(superType.copy(repository), repository);
+            copy.addSuperType(superType.copy());
         }
         return copy;
     }
@@ -138,7 +138,7 @@ public class SimpleTypeMetadata extends MetadataExtensions implements TypeMetada
         }
     }
 
-    public void addSuperType(TypeMetadata superType, MetadataRepository repository) {
+    public void addSuperType(TypeMetadata superType) {
         superTypes.add(superType);
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftFieldRef.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftFieldRef.java
index ccbb1ee..01feecb 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftFieldRef.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftFieldRef.java
@@ -117,7 +117,7 @@ public class SoftFieldRef implements FieldMetadata {
                         true,
                         type);
             } else {
-                frozenField = type.getField(fieldName).copy(repository).freeze();
+                frozenField = type.getField(fieldName).copy().freeze();
             }
         }
         // Add additional data (line number...).
@@ -202,14 +202,14 @@ public class SoftFieldRef implements FieldMetadata {
     }
 
     @Override
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        FieldMetadata copy = getField().copy(this.repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        FieldMetadata copy = getField().copy();
         copy.setContainingType(metadata);
         metadata.addField(copy);
     }
 
     @Override
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         return this;
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftIdFieldRef.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftIdFieldRef.java
index dbbc877..8020490 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftIdFieldRef.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftIdFieldRef.java
@@ -188,12 +188,12 @@ public class SoftIdFieldRef implements FieldMetadata {
     }
 
     @Override
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
-        getField().adopt(metadata, repository);
+    public void adopt(ComplexTypeMetadata metadata) {
+        getField().adopt(metadata);
     }
 
     @Override
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         return new SoftIdFieldRef(this.repository, typeName);
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftTypeRef.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftTypeRef.java
index 6991f5f..ffb50de 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftTypeRef.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/SoftTypeRef.java
@@ -13,7 +13,6 @@ package org.talend.mdm.commmon.metadata;
 
 import java.util.*;
 
-import org.apache.commons.lang.NotImplementedException;
 import org.talend.mdm.commmon.metadata.validation.ValidationFactory;
 import org.talend.mdm.commmon.metadata.validation.ValidationRule;
 import org.w3c.dom.Element;
@@ -39,6 +38,8 @@ public class SoftTypeRef implements ComplexTypeMetadata {
 
     private TypeMetadata frozenType;
 
+    private List<ContainedComplexTypeMetadata> usages = new ArrayList<ContainedComplexTypeMetadata>();
+
     private SoftTypeRef(MetadataRepository repository, FieldMetadata fieldRef) {
         if (fieldRef == null) {
             throw new IllegalArgumentException("Field reference cannot be null.");
@@ -130,11 +131,11 @@ public class SoftTypeRef implements ComplexTypeMetadata {
     }
 
     @Override
-    public TypeMetadata copy(MetadataRepository repository) {
+    public TypeMetadata copy() {
         if (typeName != null) {
             return new SoftTypeRef(repository, namespace, typeName, instantiable);
         } else {
-            return new SoftTypeRef(repository, fieldRef.copy(repository));
+            return new SoftTypeRef(repository, fieldRef.copy());
         }
     }
 
@@ -157,16 +158,16 @@ public class SoftTypeRef implements ComplexTypeMetadata {
             }
             frozenType = type.freeze();
             Set<Map.Entry<String, Object>> data = additionalData.entrySet();
-                        for (Map.Entry<String, Object> currentData : data) {
-                            frozenType.setData(currentData.getKey(), currentData.getValue());
-                        }
+            for (Map.Entry<String, Object> currentData : data) {
+                frozenType.setData(currentData.getKey(), currentData.getValue());
+            }
         }
         return frozenType;
     }
 
     @Override
-    public void addSuperType(TypeMetadata superType, MetadataRepository repository) {
-        getType().addSuperType(superType, repository);
+    public void addSuperType(TypeMetadata superType) {
+        getType().addSuperType(superType);
     }
 
     @Override
@@ -185,18 +186,13 @@ public class SoftTypeRef implements ComplexTypeMetadata {
     }
 
     @Override
-    public boolean equals(Object obj) {
-        return obj instanceof TypeMetadata && getType().equals(obj);
-    }
-
-    @Override
     public boolean isInstantiable() {
         return instantiable;
     }
 
     @Override
     public boolean isFrozen() {
-        return getType().isFrozen();
+        return false;
     }
 
     @Override
@@ -237,6 +233,21 @@ public class SoftTypeRef implements ComplexTypeMetadata {
     }
 
     @Override
+    public ComplexTypeMetadata getEntity() {
+        return getTypeAsComplex().getEntity();
+    }
+
+    @Override
+    public FieldMetadata getContainer() {
+        return getTypeAsComplex().getContainer();
+    }
+
+    @Override
+    public void setContainer(FieldMetadata field) {
+        getTypeAsComplex().setContainer(field);
+    }
+
+    @Override
     public Collection<FieldMetadata> getKeyFields() {
         return getTypeAsComplex().getKeyFields();
     }
@@ -293,7 +304,6 @@ public class SoftTypeRef implements ComplexTypeMetadata {
 
     @Override
     public void registerSubType(ComplexTypeMetadata type) {
-        getTypeAsComplex().registerSubType(type);
     }
 
     @Override
@@ -302,13 +312,49 @@ public class SoftTypeRef implements ComplexTypeMetadata {
     }
 
     @Override
+    public void declareUsage(ContainedComplexTypeMetadata usage) {
+        usages.add(usage);
+    }
+
+    @Override
+    public void freezeUsages() {
+        throw new IllegalStateException("Usage freeze must be called on resolved type references.");
+    }
+
+    @Override
+    public void setSubTypes(List<ComplexTypeMetadata> subTypes) {
+        getTypeAsComplex().setSubTypes(subTypes);
+    }
+
+    @Override
     public void registerKey(FieldMetadata keyField) {
         getTypeAsComplex().registerKey(keyField);
     }
 
     @Override
     public int hashCode() {
-        return getType().hashCode();
+        TypeMetadata type = getType();
+        if (type != null) {
+            return type.hashCode();
+        } else {
+            int result = typeName.hashCode();
+            result = 31 * result + (namespace != null ? namespace.hashCode() : 0);
+            result = 31 * result + (instantiable ? 1 : 0);
+            return result;
+        }
     }
 
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof SoftTypeRef)) return false;
+
+        SoftTypeRef that = (SoftTypeRef) o;
+
+        if (instantiable != that.instantiable) return false;
+        if (namespace != null ? !namespace.equals(that.namespace) : that.namespace != null) return false;
+        if (!typeName.equals(that.typeName)) return false;
+
+        return true;
+    }
 }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/TypeMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/TypeMetadata.java
index b06ba65..07ca6f6 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/TypeMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/TypeMetadata.java
@@ -25,7 +25,7 @@ import java.util.Collection;
 public interface TypeMetadata extends MetadataVisitable, MetadataExtensible {
 
     /**
-     * Returns a <b>READ ONLY</b> collection of super types. For adding super type see {@link #addSuperType(TypeMetadata, MetadataRepository)}
+     * Returns a <b>READ ONLY</b> collection of super types. For adding super type see {@link #addSuperType(TypeMetadata)}
      *
      * @return A collection of super types.
      */
@@ -37,9 +37,9 @@ public interface TypeMetadata extends MetadataVisitable, MetadataExtensible {
      * </p>
      *
      * @param superType  A type.
-     * @param repository Repository needed to copy type/fields references if any.
+     *
      */
-    void addSuperType(TypeMetadata superType, MetadataRepository repository);
+    void addSuperType(TypeMetadata superType);
 
     /**
      * @return Type's name as it can be used for the {@link MetadataRepository#getType(String, String)} method.
@@ -67,10 +67,9 @@ public interface TypeMetadata extends MetadataVisitable, MetadataExtensible {
      * Copies this type to another {@link MetadataRepository}. This method provides "deep copy" as it copies all metadata
      * reachable from this type.
      *
-     * @param repository The {@link MetadataRepository} the copy should be added to.
      * @return A copy of the current type registered in <code>repository</code>.
      */
-    TypeMetadata copy(MetadataRepository repository);
+    TypeMetadata copy();
 
     /**
      * Copies this type to another {@link MetadataRepository}. This method provides "shallow copy" as it copies only fields
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedFieldMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedFieldMetadata.java
index c815e85..17412bf 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedFieldMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedFieldMetadata.java
@@ -90,11 +90,11 @@ public class UnresolvedFieldMetadata implements FieldMetadata {
     }
 
     @Override
-    public void adopt(ComplexTypeMetadata metadata, MetadataRepository repository) {
+    public void adopt(ComplexTypeMetadata metadata) {
     }
 
     @Override
-    public FieldMetadata copy(MetadataRepository repository) {
+    public FieldMetadata copy() {
         return this;
     }
 
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedTypeMetadata.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedTypeMetadata.java
index f76e8eb..f401649 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedTypeMetadata.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/UnresolvedTypeMetadata.java
@@ -33,7 +33,7 @@ public class UnresolvedTypeMetadata extends MetadataExtensions implements Comple
     }
 
     @Override
-    public void addSuperType(TypeMetadata superType, MetadataRepository repository) {
+    public void addSuperType(TypeMetadata superType) {
     }
 
     @Override
@@ -56,7 +56,7 @@ public class UnresolvedTypeMetadata extends MetadataExtensions implements Comple
     }
 
     @Override
-    public TypeMetadata copy(MetadataRepository repository) {
+    public TypeMetadata copy() {
         return this;
     }
 
@@ -104,6 +104,20 @@ public class UnresolvedTypeMetadata extends MetadataExtensions implements Comple
     }
 
     @Override
+    public ComplexTypeMetadata getEntity() {
+        return null;
+    }
+
+    @Override
+    public FieldMetadata getContainer() {
+        return null;
+    }
+
+    @Override
+    public void setContainer(FieldMetadata field) {
+    }
+
+    @Override
     public Collection<FieldMetadata> getKeyFields() {
         return Collections.emptyList();
     }
@@ -179,4 +193,16 @@ public class UnresolvedTypeMetadata extends MetadataExtensions implements Comple
     public List<FieldMetadata> getLookupFields() {
         return Collections.emptyList();
     }
+
+    @Override
+    public void declareUsage(ContainedComplexTypeMetadata usage) {
+    }
+
+    @Override
+    public void freezeUsages() {
+    }
+
+    @Override
+    public void setSubTypes(List<ComplexTypeMetadata> subTypes) {
+    }
 }
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/ForeignKeyInfo.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/ForeignKeyInfo.java
index 7d64a85..4c47958 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/ForeignKeyInfo.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/ForeignKeyInfo.java
@@ -48,10 +48,7 @@ class ForeignKeyInfo implements ValidationRule {
                         ValidationError.FOREIGN_KEY_INFO_REPEATABLE);
             }
             if (foreignKeyInfo.getContainingType() != null) {
-                ComplexTypeMetadata foreignKeyInfoContainingType = foreignKeyInfo.getContainingType();
-                while (foreignKeyInfoContainingType instanceof ContainedComplexTypeMetadata) {
-                    foreignKeyInfoContainingType = ((ContainedComplexTypeMetadata) foreignKeyInfoContainingType).getContainerType();
-                }
+                ComplexTypeMetadata foreignKeyInfoContainingType = foreignKeyInfo.getContainingType().getEntity();
                 if (foreignKeyInfoContainingType.isInstantiable() && !foreignKeyInfoContainingType.equals(field.getReferencedType())) {
                     handler.error(foreignKeyInfo,
                             "Foreign key info must reference an element in referenced type.",
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/LookupFieldsValidationRule.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/LookupFieldsValidationRule.java
index d022ae4..66badda 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/LookupFieldsValidationRule.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/LookupFieldsValidationRule.java
@@ -32,10 +32,7 @@ class LookupFieldsValidationRule implements ValidationRule {
                 continue;
             }
             // Lookup field must be defined in the entity (can't reference other entity field).
-            ComplexTypeMetadata containingType = lookupField.freeze().getContainingType();
-            while (containingType instanceof ContainedComplexTypeMetadata) {
-                containingType = ((ContainedComplexTypeMetadata) containingType).getContainerType();
-            }
+            ComplexTypeMetadata containingType = lookupField.freeze().getContainingType().getEntity();
             if (!type.equals(containingType)) {
                 handler.error(type,
                         "Lookup field info must refer a field of the same entity.",
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/PrimaryKeyInfoValidationRule.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/PrimaryKeyInfoValidationRule.java
index 60a0ae4..d20ace6 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/PrimaryKeyInfoValidationRule.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/PrimaryKeyInfoValidationRule.java
@@ -16,7 +16,6 @@ import java.util.List;
 import javax.xml.XMLConstants;
 
 import org.talend.mdm.commmon.metadata.ComplexTypeMetadata;
-import org.talend.mdm.commmon.metadata.ContainedComplexTypeMetadata;
 import org.talend.mdm.commmon.metadata.ContainedTypeFieldMetadata;
 import org.talend.mdm.commmon.metadata.FieldMetadata;
 import org.talend.mdm.commmon.metadata.MetadataRepository;
@@ -42,15 +41,12 @@ class PrimaryKeyInfoValidationRule implements ValidationRule {
         for (FieldMetadata pkInfo : primaryKeyInfo) {
             // PK Info must be defined in the entity (can't reference other entity field).
             ComplexTypeMetadata ctm = pkInfo.getContainingType();
-            while (ctm instanceof ContainedComplexTypeMetadata) {
-                ctm = ((ContainedComplexTypeMetadata) ctm).getContainerType();
-            }
             if (!type.equals(ctm)) {
-                if (!validateDefinedInEntity(type.getFields(),ctm)) {
+                if (!validateDefinedInEntity(type.getFields(), ctm)) {
                     handler.error(type, "Primary key info must refer a field of the same entity.",
-                            pkInfo.<Element> getData(MetadataRepository.XSD_DOM_ELEMENT),
-                            pkInfo.<Integer> getData(MetadataRepository.XSD_LINE_NUMBER),
-                            pkInfo.<Integer> getData(MetadataRepository.XSD_COLUMN_NUMBER),
+                            pkInfo.<Element>getData(MetadataRepository.XSD_DOM_ELEMENT),
+                            pkInfo.<Integer>getData(MetadataRepository.XSD_LINE_NUMBER),
+                            pkInfo.<Integer>getData(MetadataRepository.XSD_COLUMN_NUMBER),
                             ValidationError.PRIMARY_KEY_INFO_NOT_IN_ENTITY);
                     success &= false;
                     continue;
@@ -61,18 +57,18 @@ class PrimaryKeyInfoValidationRule implements ValidationRule {
             // No need to check isMany() if field definition is already wrong.
             if (pkInfo.isMany()) {
                 handler.error(type, "Primary key info element cannot be a repeatable element.",
-                        pkInfo.<Element> getData(MetadataRepository.XSD_DOM_ELEMENT),
-                        pkInfo.<Integer> getData(MetadataRepository.XSD_LINE_NUMBER),
-                        pkInfo.<Integer> getData(MetadataRepository.XSD_COLUMN_NUMBER),
+                        pkInfo.<Element>getData(MetadataRepository.XSD_DOM_ELEMENT),
+                        pkInfo.<Integer>getData(MetadataRepository.XSD_LINE_NUMBER),
+                        pkInfo.<Integer>getData(MetadataRepository.XSD_COLUMN_NUMBER),
                         ValidationError.PRIMARY_KEY_INFO_CANNOT_BE_REPEATABLE);
                 success &= false;
                 continue;
             }
             if (!isPrimitiveTypeField(pkInfo)) {
                 handler.warning(type, "Primary key info should refer to a field with a primitive XSD type.",
-                        pkInfo.<Element> getData(MetadataRepository.XSD_DOM_ELEMENT),
-                        pkInfo.<Integer> getData(MetadataRepository.XSD_LINE_NUMBER),
-                        pkInfo.<Integer> getData(MetadataRepository.XSD_COLUMN_NUMBER),
+                        pkInfo.<Element>getData(MetadataRepository.XSD_DOM_ELEMENT),
+                        pkInfo.<Integer>getData(MetadataRepository.XSD_LINE_NUMBER),
+                        pkInfo.<Integer>getData(MetadataRepository.XSD_COLUMN_NUMBER),
                         ValidationError.PRIMARY_KEY_INFO_TYPE_NOT_PRIMITIVE);
             }
         }
@@ -94,8 +90,8 @@ class PrimaryKeyInfoValidationRule implements ValidationRule {
         }
         return XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(currentType.getNamespace());
     }
-    
-    private boolean validateDefinedInEntity(Collection<FieldMetadata> fieldCollection,ComplexTypeMetadata complexTypeMetadata) {
+
+    private boolean validateDefinedInEntity(Collection<FieldMetadata> fieldCollection, ComplexTypeMetadata complexTypeMetadata) {
         ComplexTypeMetadata typeMetadata = null;
         for (FieldMetadata fieldMetadata : fieldCollection) {
             if (typeMetadata == null && fieldMetadata instanceof SimpleTypeFieldMetadata) {
@@ -105,8 +101,8 @@ class PrimaryKeyInfoValidationRule implements ValidationRule {
                 }
             }
             if (fieldMetadata instanceof ContainedTypeFieldMetadata) {
-                ContainedComplexTypeMetadata containedComplexTypeMetadata = (ContainedComplexTypeMetadata)((ContainedTypeFieldMetadata) fieldMetadata).getType();
-                return validateDefinedInEntity(containedComplexTypeMetadata.getFields(), complexTypeMetadata);                
+                ComplexTypeMetadata containedComplexTypeMetadata = (ComplexTypeMetadata) fieldMetadata.getType();
+                return validateDefinedInEntity(containedComplexTypeMetadata.getFields(), complexTypeMetadata);
             }
         }
         return false;
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/SuperTypeValidationRule.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/SuperTypeValidationRule.java
index 2262288..cbb5f04 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/SuperTypeValidationRule.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/validation/SuperTypeValidationRule.java
@@ -30,6 +30,16 @@ class SuperTypeValidationRule implements ValidationRule {
     public boolean perform(ValidationHandler handler) {
         Collection<TypeMetadata> superTypes = type.getSuperTypes();
         if (!superTypes.isEmpty()) {
+            // Multiple inheritance is not supported.
+            if (superTypes.size() > 1) {
+                handler.error(type,
+                        "Multiple inheritance is not supported.",
+                        type.<Element>getData(MetadataRepository.XSD_DOM_ELEMENT),
+                        type.<Integer>getData(MetadataRepository.XSD_LINE_NUMBER),
+                        type.<Integer>getData(MetadataRepository.XSD_COLUMN_NUMBER),
+                        ValidationError.MULTIPLE_INHERITANCE_NOT_ALLOWED);
+            }
+            // Check for key override in sub types (not allowed).
             List<TypeMetadata> thisSuperTypes = new LinkedList<TypeMetadata>(superTypes);
             for (TypeMetadata superType : thisSuperTypes) {
                 if (type.isInstantiable() == superType.isInstantiable()) {
diff --git a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/xsd/XmlSchemaWalker.java b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/xsd/XmlSchemaWalker.java
index 61bff51..caefbdd 100644
--- a/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/xsd/XmlSchemaWalker.java
+++ b/org.talend.mdm.commmon/src/org/talend/mdm/commmon/metadata/xsd/XmlSchemaWalker.java
@@ -14,6 +14,8 @@ package org.talend.mdm.commmon.metadata.xsd;
 import org.eclipse.emf.common.util.EList;
 import org.eclipse.xsd.*;
 
+import javax.xml.XMLConstants;
+
 /**
  *
  */
@@ -34,9 +36,15 @@ public class XmlSchemaWalker {
     }
 
     public static void walk(XSDTypeDefinition type, XSDVisitor visitor) {
+        if (type == null) {
+            return;
+        }
         if (type instanceof XSDSimpleTypeDefinition) {
             walk(((XSDSimpleTypeDefinition) type), visitor);
         } else if (type instanceof XSDComplexTypeDefinition) {
+            if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(type.getTargetNamespace())) {
+                return;
+            }
             walk(((XSDComplexTypeDefinition) type), visitor);
         } else {
             throw new IllegalArgumentException("Not supported XML Schema type: " + type.getClass().getName());
@@ -44,6 +52,9 @@ public class XmlSchemaWalker {
     }
 
     public static void walk(XSDElementDeclaration element, XSDVisitor visitor) {
+        if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(element.getTargetNamespace())) {
+            return;
+        }
         visitor.visitElement(element);
     }
 
@@ -52,6 +63,9 @@ public class XmlSchemaWalker {
     }
 
     private static void walk(XSDComplexTypeDefinition xmlSchemaType, XSDVisitor visitor) {
+        if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(xmlSchemaType.getTargetNamespace())) {
+            return;
+        }
         visitor.visitComplexType(xmlSchemaType);
     }
 
@@ -60,4 +74,4 @@ public class XmlSchemaWalker {
             walk(((XSDElementDeclaration) component), visitor);
         }
     }
-}
\ No newline at end of file
+}
